import {
  ApprovalQueue,
  BatchApproval,
  NotificationManager
} from "./chunk-WPRSQQBZ.js";
import {
  AuditLogger
} from "./chunk-G7ZQ5H4K.js";
import {
  AutoExecutor
} from "./chunk-LN32IDV7.js";
import {
  DecisionRouter,
  createConfig,
  loadConfigFromEnv
} from "./chunk-LO6AQCOL.js";
import {
  Logger
} from "./chunk-ZB2ZVSPL.js";

// src/index.ts
import { EventEmitter } from "eventemitter3";

// src/core/types.ts
import { z } from "zod";
var RiskLevelSchema = z.enum(["safe", "low", "medium", "high", "critical"]);
var DecisionOutcomeSchema = z.enum([
  "auto_execute",
  // Execute immediately without human review
  "queue_approval",
  // Add to approval queue for batch review
  "escalate",
  // Notify human immediately
  "reject"
  // Reject the action
]);
var ActionCategorySchema = z.enum([
  "trading",
  // Financial operations (DCA, swaps)
  "content",
  // Content creation (tweets, blogs)
  "build",
  // Code generation
  "deployment",
  // Publishing/deploying
  "configuration"
  // System settings
]);
var EngineTypeSchema = z.enum([
  "money",
  "growth",
  "product",
  "orchestrator"
]);
var UrgencySchema = z.enum(["low", "normal", "high", "critical"]);
var ActionMetadataSchema = z.object({
  estimatedValue: z.number().optional(),
  reversible: z.boolean(),
  urgency: UrgencySchema,
  dependencies: z.array(z.string()).optional(),
  linesChanged: z.number().optional(),
  filesChanged: z.number().optional()
});
var ActionSchema = z.object({
  id: z.string(),
  engine: EngineTypeSchema,
  category: ActionCategorySchema,
  type: z.string(),
  description: z.string(),
  params: z.record(z.unknown()),
  metadata: ActionMetadataSchema,
  timestamp: z.number()
});
var RiskFactorSchema = z.object({
  name: z.string(),
  weight: z.number().min(0).max(1),
  value: z.number(),
  threshold: z.number(),
  exceeded: z.boolean(),
  reason: z.string()
});
var RiskAssessmentSchema = z.object({
  actionId: z.string(),
  level: RiskLevelSchema,
  score: z.number().min(0).max(100),
  factors: z.array(RiskFactorSchema),
  recommendation: DecisionOutcomeSchema,
  constraints: z.array(z.string()),
  timestamp: z.number()
});
var DecisionSchema = z.object({
  id: z.string(),
  actionId: z.string(),
  action: ActionSchema,
  assessment: RiskAssessmentSchema,
  outcome: DecisionOutcomeSchema,
  reason: z.string(),
  policyId: z.string().optional(),
  approvedBy: z.string().optional(),
  approvedAt: z.number().optional(),
  executedAt: z.number().optional(),
  rollbackAvailable: z.boolean(),
  timestamp: z.number()
});
var FinancialBoundariesSchema = z.object({
  maxAutoExpense: z.number().default(50),
  maxQueuedExpense: z.number().default(200),
  maxDailySpend: z.number().default(100),
  maxTradeSize: z.number().default(500),
  maxDailyTradingLossPercent: z.number().default(5),
  minTreasuryBalance: z.number().default(1e3)
});
var ContentBoundariesSchema = z.object({
  maxAutoPostsPerDay: z.number().default(10),
  maxAutoBlogsPerWeek: z.number().default(3),
  requireReviewForTopics: z.array(z.string()).default(["financial_advice", "controversial"])
});
var DevelopmentBoundariesSchema = z.object({
  maxAutoCommitLines: z.number().default(100),
  maxAutoFilesChanged: z.number().default(5),
  requireReviewForPaths: z.array(z.string()).default(["src/core/", "src/config/", ".env"]),
  autoDeployToStaging: z.boolean().default(true),
  autoDeployToProduction: z.boolean().default(false)
});
var TradingBoundariesSchema = z.object({
  allowedBots: z.array(z.string()).default(["dca"]),
  allowedTokens: z.array(z.string()).default(["SOL", "USDC"]),
  maxPositionPercent: z.number().default(20),
  requireApprovalForNewTokens: z.boolean().default(true)
});
var TimeBoundariesSchema = z.object({
  activeHoursStart: z.number().default(6),
  activeHoursEnd: z.number().default(22),
  quietHoursStart: z.number().default(23),
  quietHoursEnd: z.number().default(6)
});
var BoundariesSchema = z.object({
  financial: FinancialBoundariesSchema,
  content: ContentBoundariesSchema,
  development: DevelopmentBoundariesSchema,
  trading: TradingBoundariesSchema,
  time: TimeBoundariesSchema
});
var DailyUsageSchema = z.object({
  trades: z.number().default(0),
  content: z.number().default(0),
  builds: z.number().default(0),
  spending: z.number().default(0)
});
var BoundaryCheckResultSchema = z.object({
  passed: z.boolean(),
  violations: z.array(z.string()),
  warnings: z.array(z.string()),
  usageToday: DailyUsageSchema
});
var ApprovalStatusSchema = z.enum(["pending", "approved", "rejected", "expired"]);
var ApprovalRequestSchema = z.object({
  id: z.string(),
  decision: DecisionSchema,
  priority: z.number(),
  urgency: UrgencySchema,
  expiresAt: z.number(),
  notificationsSent: z.array(z.string()),
  status: ApprovalStatusSchema,
  reviewedBy: z.string().optional(),
  reviewedAt: z.number().optional(),
  feedback: z.string().optional(),
  createdAt: z.number()
});
var ExecutionResultSchema = z.object({
  actionId: z.string(),
  decisionId: z.string(),
  success: z.boolean(),
  output: z.unknown().optional(),
  error: z.string().optional(),
  executedAt: z.number(),
  duration: z.number(),
  rolledBack: z.boolean().default(false)
});
var RollbackCheckpointSchema = z.object({
  id: z.string(),
  actionId: z.string(),
  decisionId: z.string(),
  state: z.record(z.unknown()),
  createdAt: z.number()
});
var AuditEntryTypeSchema = z.enum([
  "action_received",
  "risk_assessed",
  "decision_made",
  "queued_approval",
  "approved",
  "rejected",
  "executed",
  "execution_failed",
  "rolled_back",
  "boundary_violation",
  "escalated"
]);
var AuditEntrySchema = z.object({
  id: z.string(),
  timestamp: z.number(),
  type: AuditEntryTypeSchema,
  actionId: z.string(),
  decisionId: z.string().optional(),
  data: z.record(z.unknown()),
  hash: z.string(),
  previousHash: z.string()
});
var NotificationChannelTypeSchema = z.enum(["discord", "telegram", "slack", "email"]);
var NotificationChannelSchema = z.object({
  type: NotificationChannelTypeSchema,
  enabled: z.boolean(),
  config: z.object({
    webhookUrl: z.string().optional(),
    botToken: z.string().optional(),
    chatId: z.string().optional()
  })
});
var AutonomyConfigSchema = z.object({
  enabled: z.boolean().default(true),
  level: z.number().min(1).max(4).default(2),
  boundaries: BoundariesSchema,
  notifications: z.object({
    channels: z.array(NotificationChannelSchema).default([]),
    rateLimitPerMinute: z.number().default(10)
  }),
  approval: z.object({
    maxPendingItems: z.number().default(50),
    autoExpireHours: z.number().default(24),
    notifyOnNewItem: z.boolean().default(true)
  }),
  audit: z.object({
    retentionDays: z.number().default(90),
    storageDir: z.string().default("./data/audit")
  })
});

// src/index.ts
var AutonomyEngine = class extends EventEmitter {
  logger;
  config;
  router;
  executor;
  approvalQueue;
  batchApproval;
  notifications;
  audit;
  running = false;
  constructor(config) {
    super();
    this.logger = new Logger("AutonomyEngine");
    const envConfig = loadConfigFromEnv();
    this.config = createConfig({ ...envConfig, ...config });
    this.router = new DecisionRouter({
      autonomyLevel: this.config.level,
      boundaries: this.config.boundaries
    });
    this.executor = new AutoExecutor();
    this.approvalQueue = new ApprovalQueue({
      maxPendingItems: this.config.approval.maxPendingItems,
      autoExpireHours: this.config.approval.autoExpireHours
    });
    this.batchApproval = new BatchApproval(this.approvalQueue);
    this.notifications = new NotificationManager({
      channels: this.config.notifications.channels,
      rateLimitPerMinute: this.config.notifications.rateLimitPerMinute
    });
    this.audit = new AuditLogger({
      retentionDays: this.config.audit.retentionDays
    });
    this.setupEventHandlers();
  }
  /**
   * Start the autonomy engine
   */
  start() {
    if (this.running) return;
    this.running = true;
    this.logger.info("Autonomy engine started", {
      level: this.config.level,
      notificationsConfigured: this.notifications.isConfigured()
    });
    this.emit("started");
  }
  /**
   * Stop the autonomy engine
   */
  stop() {
    if (!this.running) return;
    this.running = false;
    this.approvalQueue.stop();
    this.logger.info("Autonomy engine stopped");
    this.emit("stopped");
  }
  /**
   * Route an action through the autonomy system
   */
  async route(action) {
    if (!this.running) {
      throw new Error("Autonomy engine not running");
    }
    this.emit("action:received", action);
    this.audit.logActionReceived(action);
    const decision = await this.router.route(action);
    this.audit.logRiskAssessed(action, decision);
    this.audit.logDecisionMade(decision);
    this.emit("decision:made", decision);
    switch (decision.outcome) {
      case "auto_execute":
        await this.handleAutoExecute(decision);
        break;
      case "queue_approval":
        await this.handleQueueApproval(decision);
        break;
      case "escalate":
        await this.handleEscalate(decision);
        break;
      case "reject":
        this.logger.info(`Rejected: ${action.type}`, { reason: decision.reason });
        this.audit.logBoundaryViolation(action, [decision.reason]);
        break;
    }
    return decision;
  }
  /**
   * Approve a pending request
   */
  async approve(requestId, approvedBy = "human", feedback) {
    const request = this.approvalQueue.approve(requestId, approvedBy, feedback);
    if (request) {
      this.audit.logApproved(request);
      this.emit("approval:granted", request);
      await this.notifications.notifyApprovalDecision(request, true);
      await this.handleAutoExecute(request.decision);
    }
    return request;
  }
  /**
   * Reject a pending request
   */
  async reject(requestId, reason, rejectedBy = "human") {
    const request = this.approvalQueue.reject(requestId, reason, rejectedBy);
    if (request) {
      this.audit.logRejected(request, reason);
      this.emit("approval:rejected", request, reason);
      await this.notifications.notifyApprovalDecision(request, false, reason);
    }
    return request;
  }
  /**
   * Get pending approval queue
   */
  getQueue() {
    return this.approvalQueue.getPending();
  }
  /**
   * Get batch approval interface
   */
  getBatch() {
    return this.batchApproval;
  }
  /**
   * Get current boundaries
   */
  getBoundaries() {
    return this.router.getBoundaryChecker().getBoundaries();
  }
  /**
   * Update boundaries at runtime
   */
  updateBoundaries(updates) {
    this.router.updateBoundaries(updates);
    this.logger.info("Boundaries updated");
  }
  /**
   * Get usage statistics for today
   */
  getUsageToday() {
    return this.router.getBoundaryChecker().getUsageToday();
  }
  /**
   * Get queue statistics
   */
  getQueueStats() {
    return this.approvalQueue.getStats();
  }
  /**
   * Get audit entries
   */
  getAuditLog() {
    return this.audit.getEntries();
  }
  /**
   * Get executor stats
   */
  getExecutorStats() {
    return this.executor.getStats();
  }
  /**
   * Check if engine is running
   */
  isRunning() {
    return this.running;
  }
  /**
   * Get autonomy level
   */
  getLevel() {
    return this.config.level;
  }
  /**
   * Get full status
   */
  getStatus() {
    return {
      running: this.running,
      level: this.config.level,
      queue: this.approvalQueue.getStats(),
      usage: this.getUsageToday(),
      executor: this.executor.getStats(),
      audit: this.audit.getStats()
    };
  }
  // Private methods
  setupEventHandlers() {
    this.router.on("decision:auto_execute", (decision) => {
      this.logger.debug(`Auto-execute: ${decision.action.type}`);
    });
    this.router.on("boundary:violation", (action, violations) => {
      this.audit.logBoundaryViolation(action, violations);
    });
    this.approvalQueue.on("item:escalated", async (request) => {
      this.audit.logEscalated(request);
      this.emit("escalation", request);
      await this.notifications.notifyEscalation(request);
    });
    this.executor.on("execution:completed", (result) => {
      this.audit.logExecuted(result);
      this.emit("execution:completed", result);
    });
    this.executor.on("execution:failed", (result) => {
      this.audit.logExecutionFailed(result);
      this.emit("execution:failed", result);
    });
    this.executor.on("execution:rolled_back", (actionId) => {
      this.audit.logRolledBack(actionId, "");
    });
  }
  async handleAutoExecute(decision) {
    this.logger.info(`Auto-executing: ${decision.action.type}`);
    const result = await this.executor.execute(decision);
    if (result.success) {
      this.router.recordExecution(decision.action);
    }
  }
  async handleQueueApproval(decision) {
    const request = this.approvalQueue.add(decision);
    this.audit.logQueuedApproval(request);
    this.emit("approval:queued", request);
    this.logger.info(`Queued for approval: ${decision.action.type}`, {
      requestId: request.id,
      priority: request.priority
    });
    if (this.config.approval.notifyOnNewItem) {
      await this.notifications.notifyApprovalNeeded(request);
      this.approvalQueue.markNotificationSent(request.id, "initial");
    }
  }
  async handleEscalate(decision) {
    const request = this.approvalQueue.add(decision);
    this.audit.logEscalated(request);
    this.emit("escalation", request);
    this.logger.warn(`Escalated: ${decision.action.type}`, {
      requestId: request.id,
      riskLevel: decision.assessment.level
    });
    await this.notifications.notifyEscalation(request);
    this.approvalQueue.markNotificationSent(request.id, "escalation");
  }
};
var instance = null;
function getAutonomy(config) {
  if (!instance) {
    instance = new AutonomyEngine(config);
    instance.start();
  }
  return instance;
}
function resetAutonomy() {
  if (instance) {
    instance.stop();
    instance = null;
  }
}

export {
  RiskLevelSchema,
  DecisionOutcomeSchema,
  ActionCategorySchema,
  EngineTypeSchema,
  UrgencySchema,
  ActionMetadataSchema,
  ActionSchema,
  RiskFactorSchema,
  RiskAssessmentSchema,
  DecisionSchema,
  FinancialBoundariesSchema,
  ContentBoundariesSchema,
  DevelopmentBoundariesSchema,
  TradingBoundariesSchema,
  TimeBoundariesSchema,
  BoundariesSchema,
  DailyUsageSchema,
  BoundaryCheckResultSchema,
  ApprovalStatusSchema,
  ApprovalRequestSchema,
  ExecutionResultSchema,
  RollbackCheckpointSchema,
  AuditEntryTypeSchema,
  AuditEntrySchema,
  NotificationChannelTypeSchema,
  NotificationChannelSchema,
  AutonomyConfigSchema,
  AutonomyEngine,
  getAutonomy,
  resetAutonomy
};
//# sourceMappingURL=chunk-N7PLJLXS.js.map