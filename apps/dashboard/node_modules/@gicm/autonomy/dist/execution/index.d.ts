import { EventEmitter } from 'eventemitter3';
import { b as Action, D as Decision, P as RollbackCheckpoint, E as ExecutionResult } from '../types-BSLNoyKE.js';
import 'zod';

/**
 * Safe Actions Registry
 *
 * Defines pre-approved action types and their execution handlers
 */

type ActionHandler = (action: Action) => Promise<unknown>;
interface SafeActionsConfig {
    /** Additional action types to consider safe */
    additionalSafeTypes?: string[];
    /** Override dangerous action list */
    dangerousTypes?: string[];
}
declare class SafeActions {
    private logger;
    private handlers;
    private safeTypes;
    private dangerousTypes;
    constructor(config?: SafeActionsConfig);
    /**
     * Register a handler for an action type
     */
    registerHandler(actionType: string, handler: ActionHandler): void;
    /**
     * Check if an action type is considered safe
     */
    isSafe(actionType: string): boolean;
    /**
     * Check if an action type is dangerous
     */
    isDangerous(actionType: string): boolean;
    /**
     * Get handler for an action type
     */
    getHandler(actionType: string): ActionHandler | undefined;
    /**
     * Execute an action using registered handler
     */
    execute(action: Action): Promise<unknown>;
    /**
     * Get list of safe action types
     */
    getSafeTypes(): string[];
    /**
     * Get list of dangerous action types
     */
    getDangerousTypes(): string[];
    /**
     * Add an action type to safe list
     */
    addSafeType(actionType: string): void;
    /**
     * Add an action type to dangerous list
     */
    addDangerousType(actionType: string): void;
    /**
     * Register default handlers for common action types
     */
    private registerDefaultHandlers;
}

/**
 * Rollback Manager
 *
 * Creates checkpoints before action execution
 * Enables undo/rollback for reversible actions
 */

type RollbackHandler = (checkpoint: RollbackCheckpoint) => Promise<void>;
interface RollbackManagerConfig {
    /** Maximum checkpoints to keep in memory */
    maxCheckpoints?: number;
    /** Checkpoint TTL in milliseconds (default 24h) */
    checkpointTtl?: number;
}
declare class RollbackManager {
    private logger;
    private checkpoints;
    private handlers;
    private maxCheckpoints;
    private checkpointTtl;
    constructor(config?: RollbackManagerConfig);
    /**
     * Create a checkpoint before executing an action
     */
    createCheckpoint(decision: Decision): Promise<RollbackCheckpoint>;
    /**
     * Restore state from a checkpoint (rollback)
     */
    rollback(checkpointId: string): Promise<void>;
    /**
     * Rollback by action ID
     */
    rollbackByActionId(actionId: string): Promise<void>;
    /**
     * Register a rollback handler for an action type
     */
    registerHandler(actionType: string, handler: RollbackHandler): void;
    /**
     * Check if rollback is available for an action
     */
    canRollback(actionId: string): boolean;
    /**
     * Get checkpoint for an action
     */
    getCheckpoint(checkpointId: string): RollbackCheckpoint | undefined;
    /**
     * Get checkpoint by action ID
     */
    findByActionId(actionId: string): RollbackCheckpoint | undefined;
    /**
     * Get all active checkpoints
     */
    getActiveCheckpoints(): RollbackCheckpoint[];
    /**
     * Clear all checkpoints
     */
    clear(): void;
    /**
     * Capture state before action execution
     */
    private captureState;
    /**
     * Find appropriate rollback handler for a checkpoint
     */
    private findHandler;
    /**
     * Remove expired checkpoints
     */
    private cleanupExpired;
    /**
     * Remove oldest checkpoint
     */
    private removeOldest;
}

/**
 * Auto-Executor for Level 2 Autonomy
 *
 * Executes approved actions with:
 * - Checkpoint creation for reversible actions
 * - Error handling with automatic rollback
 * - Event emission for monitoring
 */

interface AutoExecutorConfig {
    /** Maximum concurrent executions */
    maxConcurrent?: number;
    /** Cooldown after failure in ms */
    cooldownAfterFailureMs?: number;
    /** Enable automatic rollback on failure */
    autoRollback?: boolean;
}
interface AutoExecutorEvents {
    "execution:started": (decision: Decision) => void;
    "execution:completed": (result: ExecutionResult) => void;
    "execution:failed": (result: ExecutionResult) => void;
    "execution:rolled_back": (actionId: string) => void;
    "execution:rate_limited": (action: Action) => void;
}
declare class AutoExecutor extends EventEmitter<AutoExecutorEvents> {
    private logger;
    private safeActions;
    private rollbackManager;
    private config;
    private executing;
    private executionCount;
    private lastExecutionTime;
    private failedActions;
    constructor(config?: AutoExecutorConfig);
    /**
     * Execute an approved action
     */
    execute(decision: Decision): Promise<ExecutionResult>;
    /**
     * Execute multiple decisions in sequence
     */
    executeBatch(decisions: Decision[]): Promise<{
        success: ExecutionResult[];
        failed: ExecutionResult[];
    }>;
    /**
     * Register an action handler
     */
    registerHandler(actionType: string, handler: ActionHandler): void;
    /**
     * Get execution statistics
     */
    getStats(): {
        totalExecutions: number;
        currentlyExecuting: number;
        failedInCooldown: number;
    };
    /**
     * Check if rollback is available for an action
     */
    canRollback(actionId: string): boolean;
    /**
     * Manually rollback an action
     */
    rollback(actionId: string): Promise<void>;
    /**
     * Get safe actions registry
     */
    getSafeActions(): SafeActions;
    /**
     * Get rollback manager
     */
    getRollbackManager(): RollbackManager;
    private checkRateLimit;
    private isInCooldown;
    private createFailedResult;
}

export { type ActionHandler, AutoExecutor, type AutoExecutorConfig, type AutoExecutorEvents, type RollbackHandler, RollbackManager, type RollbackManagerConfig, SafeActions, type SafeActionsConfig };
