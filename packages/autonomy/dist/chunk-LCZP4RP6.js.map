{"version":3,"sources":["../src/execution/auto-executor.ts","../src/execution/safe-actions.ts","../src/execution/rollback-manager.ts"],"sourcesContent":["/**\n * Auto-Executor for Level 2 Autonomy\n *\n * Executes approved actions with:\n * - Checkpoint creation for reversible actions\n * - Error handling with automatic rollback\n * - Event emission for monitoring\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport type { Action, Decision, ExecutionResult } from \"../core/types.js\";\nimport { SafeActions, type ActionHandler } from \"./safe-actions.js\";\nimport { RollbackManager } from \"./rollback-manager.js\";\nimport { Logger } from \"../utils/logger.js\";\nimport { RATE_LIMITS } from \"../core/constants.js\";\n\nexport interface AutoExecutorConfig {\n  /** Maximum concurrent executions */\n  maxConcurrent?: number;\n  /** Cooldown after failure in ms */\n  cooldownAfterFailureMs?: number;\n  /** Enable automatic rollback on failure */\n  autoRollback?: boolean;\n}\n\nexport interface AutoExecutorEvents {\n  \"execution:started\": (decision: Decision) => void;\n  \"execution:completed\": (result: ExecutionResult) => void;\n  \"execution:failed\": (result: ExecutionResult) => void;\n  \"execution:rolled_back\": (actionId: string) => void;\n  \"execution:rate_limited\": (action: Action) => void;\n}\n\nexport class AutoExecutor extends EventEmitter<AutoExecutorEvents> {\n  private logger: Logger;\n  private safeActions: SafeActions;\n  private rollbackManager: RollbackManager;\n  private config: Required<AutoExecutorConfig>;\n\n  private executing: Set<string>;\n  private executionCount: number;\n  private lastExecutionTime: number;\n  private failedActions: Map<string, number>; // actionType -> lastFailureTime\n\n  constructor(config: AutoExecutorConfig = {}) {\n    super();\n    this.logger = new Logger(\"AutoExecutor\");\n    this.safeActions = new SafeActions();\n    this.rollbackManager = new RollbackManager();\n\n    this.config = {\n      maxConcurrent: config.maxConcurrent ?? 5,\n      cooldownAfterFailureMs:\n        config.cooldownAfterFailureMs ?? RATE_LIMITS.cooldownAfterFailureMs,\n      autoRollback: config.autoRollback ?? true,\n    };\n\n    this.executing = new Set();\n    this.executionCount = 0;\n    this.lastExecutionTime = 0;\n    this.failedActions = new Map();\n  }\n\n  /**\n   * Execute an approved action\n   */\n  async execute(decision: Decision): Promise<ExecutionResult> {\n    const action = decision.action;\n\n    // Validate decision is approved\n    if (decision.outcome !== \"auto_execute\") {\n      return this.createFailedResult(\n        decision,\n        \"Decision not approved for auto-execution\"\n      );\n    }\n\n    // Check rate limiting\n    if (!this.checkRateLimit()) {\n      this.emit(\"execution:rate_limited\", action);\n      return this.createFailedResult(decision, \"Rate limit exceeded\");\n    }\n\n    // Check concurrent limit\n    if (this.executing.size >= this.config.maxConcurrent) {\n      return this.createFailedResult(\n        decision,\n        \"Maximum concurrent executions reached\"\n      );\n    }\n\n    // Check cooldown for action type\n    if (this.isInCooldown(action.type)) {\n      return this.createFailedResult(\n        decision,\n        `Action type ${action.type} in cooldown after recent failure`\n      );\n    }\n\n    // Prevent duplicate execution\n    if (this.executing.has(action.id)) {\n      return this.createFailedResult(decision, \"Action already executing\");\n    }\n\n    // Start execution\n    this.executing.add(action.id);\n    this.emit(\"execution:started\", decision);\n    const startTime = Date.now();\n\n    this.logger.info(`Executing: ${action.type}`, {\n      actionId: action.id,\n      decisionId: decision.id,\n    });\n\n    try {\n      // Create checkpoint for reversible actions\n      if (action.metadata.reversible) {\n        await this.rollbackManager.createCheckpoint(decision);\n      }\n\n      // Execute the action\n      const output = await this.safeActions.execute(action);\n\n      // Success!\n      const result: ExecutionResult = {\n        actionId: action.id,\n        decisionId: decision.id,\n        success: true,\n        output,\n        executedAt: Date.now(),\n        duration: Date.now() - startTime,\n        rolledBack: false,\n      };\n\n      this.executionCount++;\n      this.lastExecutionTime = Date.now();\n\n      this.logger.info(`Execution successful: ${action.type}`, {\n        actionId: action.id,\n        duration: result.duration,\n      });\n\n      this.emit(\"execution:completed\", result);\n      return result;\n\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : String(error);\n\n      this.logger.error(`Execution failed: ${action.type}`, {\n        actionId: action.id,\n        error: errorMessage,\n      });\n\n      // Mark action type as failed\n      this.failedActions.set(action.type, Date.now());\n\n      // Attempt rollback if enabled\n      let rolledBack = false;\n      if (this.config.autoRollback && action.metadata.reversible) {\n        try {\n          await this.rollbackManager.rollbackByActionId(action.id);\n          rolledBack = true;\n          this.emit(\"execution:rolled_back\", action.id);\n        } catch (rollbackError) {\n          this.logger.error(`Rollback failed for ${action.id}`, {\n            error: rollbackError instanceof Error ? rollbackError.message : String(rollbackError),\n          });\n        }\n      }\n\n      const result: ExecutionResult = {\n        actionId: action.id,\n        decisionId: decision.id,\n        success: false,\n        error: errorMessage,\n        executedAt: Date.now(),\n        duration: Date.now() - startTime,\n        rolledBack,\n      };\n\n      this.emit(\"execution:failed\", result);\n      return result;\n\n    } finally {\n      this.executing.delete(action.id);\n    }\n  }\n\n  /**\n   * Execute multiple decisions in sequence\n   */\n  async executeBatch(\n    decisions: Decision[]\n  ): Promise<{ success: ExecutionResult[]; failed: ExecutionResult[] }> {\n    const success: ExecutionResult[] = [];\n    const failed: ExecutionResult[] = [];\n\n    for (const decision of decisions) {\n      const result = await this.execute(decision);\n      if (result.success) {\n        success.push(result);\n      } else {\n        failed.push(result);\n      }\n    }\n\n    return { success, failed };\n  }\n\n  /**\n   * Register an action handler\n   */\n  registerHandler(actionType: string, handler: ActionHandler): void {\n    this.safeActions.registerHandler(actionType, handler);\n  }\n\n  /**\n   * Get execution statistics\n   */\n  getStats(): {\n    totalExecutions: number;\n    currentlyExecuting: number;\n    failedInCooldown: number;\n  } {\n    return {\n      totalExecutions: this.executionCount,\n      currentlyExecuting: this.executing.size,\n      failedInCooldown: Array.from(this.failedActions.entries()).filter(\n        ([, time]) => Date.now() - time < this.config.cooldownAfterFailureMs\n      ).length,\n    };\n  }\n\n  /**\n   * Check if rollback is available for an action\n   */\n  canRollback(actionId: string): boolean {\n    return this.rollbackManager.canRollback(actionId);\n  }\n\n  /**\n   * Manually rollback an action\n   */\n  async rollback(actionId: string): Promise<void> {\n    await this.rollbackManager.rollbackByActionId(actionId);\n    this.emit(\"execution:rolled_back\", actionId);\n  }\n\n  /**\n   * Get safe actions registry\n   */\n  getSafeActions(): SafeActions {\n    return this.safeActions;\n  }\n\n  /**\n   * Get rollback manager\n   */\n  getRollbackManager(): RollbackManager {\n    return this.rollbackManager;\n  }\n\n  // Private methods\n\n  private checkRateLimit(): boolean {\n    // Check per-hour limit\n    const hourlyLimit = RATE_LIMITS.maxAutoExecutionsPerHour;\n    // Simplified: just check time since last execution\n    const timeSinceLastMs = Date.now() - this.lastExecutionTime;\n    const minIntervalMs = (60 * 60 * 1000) / hourlyLimit;\n\n    return timeSinceLastMs >= minIntervalMs;\n  }\n\n  private isInCooldown(actionType: string): boolean {\n    const lastFailure = this.failedActions.get(actionType);\n    if (!lastFailure) return false;\n\n    return Date.now() - lastFailure < this.config.cooldownAfterFailureMs;\n  }\n\n  private createFailedResult(decision: Decision, error: string): ExecutionResult {\n    return {\n      actionId: decision.actionId,\n      decisionId: decision.id,\n      success: false,\n      error,\n      executedAt: Date.now(),\n      duration: 0,\n      rolledBack: false,\n    };\n  }\n}\n","/**\n * Safe Actions Registry\n *\n * Defines pre-approved action types and their execution handlers\n */\n\nimport type { Action } from \"../core/types.js\";\nimport { SAFE_ACTION_TYPES, DANGEROUS_ACTION_TYPES } from \"../core/constants.js\";\nimport { Logger } from \"../utils/logger.js\";\n\nexport type ActionHandler = (action: Action) => Promise<unknown>;\n\nexport interface SafeActionsConfig {\n  /** Additional action types to consider safe */\n  additionalSafeTypes?: string[];\n  /** Override dangerous action list */\n  dangerousTypes?: string[];\n  /** Engine connections for real execution */\n  engines?: {\n    money?: MoneyEngineInterface;\n    growth?: GrowthEngineInterface;\n    product?: ProductEngineInterface;\n  };\n}\n\n// Engine interfaces for type safety\nexport interface MoneyEngineInterface {\n  executeDCA?(params: { asset: string; amount: number }): Promise<{ txHash?: string; success: boolean }>;\n  getBalance?(): Promise<{ sol: number; usdc: number }>;\n  transfer?(params: { to: string; amount: number; token: string }): Promise<{ txHash?: string; success: boolean }>;\n}\n\nexport interface GrowthEngineInterface {\n  generateTweet?(params: { topic?: string }): Promise<{ content: string; id?: string }>;\n  postTweet?(content: string): Promise<{ tweetId: string; success: boolean }>;\n  generateBlog?(params: { topic: string }): Promise<{ title: string; content: string }>;\n  publishBlog?(blog: { title: string; content: string }): Promise<{ url: string; success: boolean }>;\n}\n\nexport interface ProductEngineInterface {\n  runDiscovery?(): Promise<{ opportunities: unknown[]; count: number }>;\n  buildFromOpportunity?(opportunityId: string): Promise<{ buildId: string; status: string }>;\n  getBacklog?(): Promise<{ items: unknown[]; count: number }>;\n}\n\nexport class SafeActions {\n  private logger: Logger;\n  private handlers: Map<string, ActionHandler>;\n  private safeTypes: Set<string>;\n  private dangerousTypes: Set<string>;\n  private engines: SafeActionsConfig[\"engines\"];\n\n  constructor(config: SafeActionsConfig = {}) {\n    this.logger = new Logger(\"SafeActions\");\n    this.handlers = new Map();\n    this.safeTypes = new Set([\n      ...SAFE_ACTION_TYPES,\n      ...(config.additionalSafeTypes ?? []),\n    ]);\n    this.dangerousTypes = new Set(\n      config.dangerousTypes ?? [...DANGEROUS_ACTION_TYPES]\n    );\n    this.engines = config.engines;\n\n    // Register default handlers\n    this.registerDefaultHandlers();\n  }\n\n  /**\n   * Register a handler for an action type\n   */\n  registerHandler(actionType: string, handler: ActionHandler): void {\n    this.handlers.set(actionType, handler);\n    this.logger.info(`Handler registered for: ${actionType}`);\n  }\n\n  /**\n   * Connect engines for execution\n   */\n  connectEngines(engines: SafeActionsConfig[\"engines\"]): void {\n    this.engines = { ...this.engines, ...engines };\n    this.logger.info(\"Engines connected\", {\n      money: !!engines?.money,\n      growth: !!engines?.growth,\n      product: !!engines?.product\n    });\n  }\n\n  /**\n   * Check if an action type is considered safe\n   */\n  isSafe(actionType: string): boolean {\n    // Check explicit safe list\n    if (this.safeTypes.has(actionType)) return true;\n\n    // Check if matches any safe pattern\n    for (const safe of this.safeTypes) {\n      if (actionType.includes(safe)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Check if an action type is dangerous\n   */\n  isDangerous(actionType: string): boolean {\n    // Check explicit dangerous list\n    if (this.dangerousTypes.has(actionType)) return true;\n\n    // Check if matches any dangerous pattern\n    for (const dangerous of this.dangerousTypes) {\n      if (actionType.includes(dangerous)) return true;\n    }\n\n    return false;\n  }\n\n  /**\n   * Get handler for an action type\n   */\n  getHandler(actionType: string): ActionHandler | undefined {\n    // Direct match\n    if (this.handlers.has(actionType)) {\n      return this.handlers.get(actionType);\n    }\n\n    // Pattern match (e.g., \"dca_buy\" matches \"dca\" handler)\n    for (const [type, handler] of this.handlers) {\n      if (actionType.includes(type) || type.includes(actionType)) {\n        return handler;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Execute an action using registered handler\n   */\n  async execute(action: Action): Promise<unknown> {\n    const handler = this.getHandler(action.type);\n\n    if (!handler) {\n      throw new Error(`No handler registered for action type: ${action.type}`);\n    }\n\n    this.logger.info(`Executing: ${action.type}`, { actionId: action.id });\n    return handler(action);\n  }\n\n  /**\n   * Get list of safe action types\n   */\n  getSafeTypes(): string[] {\n    return Array.from(this.safeTypes);\n  }\n\n  /**\n   * Get list of dangerous action types\n   */\n  getDangerousTypes(): string[] {\n    return Array.from(this.dangerousTypes);\n  }\n\n  /**\n   * Add an action type to safe list\n   */\n  addSafeType(actionType: string): void {\n    this.safeTypes.add(actionType);\n    this.dangerousTypes.delete(actionType);\n  }\n\n  /**\n   * Add an action type to dangerous list\n   */\n  addDangerousType(actionType: string): void {\n    this.dangerousTypes.add(actionType);\n    this.safeTypes.delete(actionType);\n  }\n\n  /**\n   * Register default handlers for common action types\n   */\n  private registerDefaultHandlers(): void {\n    // ============================================================\n    // UTILITY HANDLERS\n    // ============================================================\n\n    // Log-only handler (for testing or dry runs)\n    this.handlers.set(\"log_only\", async (action) => {\n      this.logger.info(`[DRY RUN] Would execute: ${action.type}`, action.params);\n      return { dryRun: true, action: action.type };\n    });\n\n    // Passthrough handler (assumes caller will execute)\n    this.handlers.set(\"passthrough\", async (action) => {\n      return { passthrough: true, actionId: action.id };\n    });\n\n    // ============================================================\n    // CONTENT HANDLERS (Growth Engine)\n    // ============================================================\n\n    // Generate tweet\n    this.handlers.set(\"generate_tweet\", async (action) => {\n      if (!this.engines?.growth?.generateTweet) {\n        return { scheduled: true, type: action.type, message: \"Growth engine not connected\" };\n      }\n      const params = action.params as { topic?: string } | undefined;\n      const result = await this.engines.growth.generateTweet({ topic: params?.topic });\n      return { success: true, type: action.type, content: result.content };\n    });\n\n    // Post tweet\n    this.handlers.set(\"post_tweet\", async (action) => {\n      if (!this.engines?.growth?.postTweet) {\n        return { scheduled: true, type: action.type, message: \"Growth engine not connected\" };\n      }\n      const params = action.params as { content: string };\n      const result = await this.engines.growth.postTweet(params.content);\n      return { success: result.success, type: action.type, tweetId: result.tweetId };\n    });\n\n    // Generate blog\n    this.handlers.set(\"generate_blog\", async (action) => {\n      if (!this.engines?.growth?.generateBlog) {\n        return { scheduled: true, type: action.type, message: \"Growth engine not connected\" };\n      }\n      const params = action.params as { topic: string };\n      const result = await this.engines.growth.generateBlog({ topic: params.topic });\n      return { success: true, type: action.type, title: result.title, contentLength: result.content.length };\n    });\n\n    // Publish blog\n    this.handlers.set(\"publish_blog\", async (action) => {\n      if (!this.engines?.growth?.publishBlog) {\n        return { scheduled: true, type: action.type, message: \"Growth engine not connected\" };\n      }\n      const params = action.params as { title: string; content: string };\n      const result = await this.engines.growth.publishBlog(params);\n      return { success: result.success, type: action.type, url: result.url };\n    });\n\n    // General content handler\n    this.handlers.set(\"content\", async (action) => {\n      const subType = action.params?.subType as string;\n      switch (subType) {\n        case \"tweet\":\n          return this.handlers.get(\"generate_tweet\")!(action);\n        case \"blog\":\n          return this.handlers.get(\"generate_blog\")!(action);\n        default:\n          return { scheduled: true, type: action.type, subType };\n      }\n    });\n\n    // ============================================================\n    // TRADING HANDLERS (Money Engine)\n    // ============================================================\n\n    // DCA buy\n    this.handlers.set(\"dca_buy\", async (action) => {\n      if (!this.engines?.money?.executeDCA) {\n        return { submitted: true, type: action.type, message: \"Money engine not connected\" };\n      }\n      const params = action.params as { asset: string; amount: number };\n      const result = await this.engines.money.executeDCA({\n        asset: params.asset ?? \"SOL\",\n        amount: params.amount ?? 10,\n      });\n      return { success: result.success, type: action.type, txHash: result.txHash };\n    });\n\n    // Get balance\n    this.handlers.set(\"get_balance\", async (action) => {\n      if (!this.engines?.money?.getBalance) {\n        return { submitted: true, type: action.type, message: \"Money engine not connected\" };\n      }\n      const result = await this.engines.money.getBalance();\n      return { success: true, type: action.type, balances: result };\n    });\n\n    // Transfer (requires higher approval)\n    this.handlers.set(\"transfer\", async (action) => {\n      if (!this.engines?.money?.transfer) {\n        return { submitted: true, type: action.type, message: \"Money engine not connected\" };\n      }\n      const params = action.params as { to: string; amount: number; token: string };\n      const result = await this.engines.money.transfer(params);\n      return { success: result.success, type: action.type, txHash: result.txHash };\n    });\n\n    // General trading handler\n    this.handlers.set(\"trading\", async (action) => {\n      const subType = action.params?.subType as string;\n      switch (subType) {\n        case \"dca\":\n          return this.handlers.get(\"dca_buy\")!(action);\n        case \"balance\":\n          return this.handlers.get(\"get_balance\")!(action);\n        case \"transfer\":\n          return this.handlers.get(\"transfer\")!(action);\n        default:\n          return { submitted: true, type: action.type, subType };\n      }\n    });\n\n    // ============================================================\n    // BUILD HANDLERS (Product Engine)\n    // ============================================================\n\n    // Run discovery\n    this.handlers.set(\"run_discovery\", async (action) => {\n      if (!this.engines?.product?.runDiscovery) {\n        return { queued: true, type: action.type, message: \"Product engine not connected\" };\n      }\n      const result = await this.engines.product.runDiscovery();\n      return { success: true, type: action.type, count: result.count };\n    });\n\n    // Build from opportunity\n    this.handlers.set(\"build_opportunity\", async (action) => {\n      if (!this.engines?.product?.buildFromOpportunity) {\n        return { queued: true, type: action.type, message: \"Product engine not connected\" };\n      }\n      const params = action.params as { opportunityId: string };\n      const result = await this.engines.product.buildFromOpportunity(params.opportunityId);\n      return { success: true, type: action.type, buildId: result.buildId, status: result.status };\n    });\n\n    // Get backlog\n    this.handlers.set(\"get_backlog\", async (action) => {\n      if (!this.engines?.product?.getBacklog) {\n        return { queued: true, type: action.type, message: \"Product engine not connected\" };\n      }\n      const result = await this.engines.product.getBacklog();\n      return { success: true, type: action.type, count: result.count };\n    });\n\n    // General build handler\n    this.handlers.set(\"build\", async (action) => {\n      const subType = action.params?.subType as string;\n      switch (subType) {\n        case \"discovery\":\n          return this.handlers.get(\"run_discovery\")!(action);\n        case \"opportunity\":\n          return this.handlers.get(\"build_opportunity\")!(action);\n        case \"backlog\":\n          return this.handlers.get(\"get_backlog\")!(action);\n        default:\n          return { queued: true, type: action.type, subType };\n      }\n    });\n\n    // ============================================================\n    // STATUS & INFO HANDLERS\n    // ============================================================\n\n    // Status check (always safe)\n    this.handlers.set(\"status_check\", async (action) => {\n      return {\n        success: true,\n        type: action.type,\n        timestamp: Date.now(),\n        engines: {\n          money: !!this.engines?.money,\n          growth: !!this.engines?.growth,\n          product: !!this.engines?.product,\n        },\n      };\n    });\n\n    // Health check\n    this.handlers.set(\"health_check\", async (action) => {\n      const healthResults: Record<string, boolean> = {};\n\n      if (this.engines?.money?.getBalance) {\n        try {\n          await this.engines.money.getBalance();\n          healthResults.money = true;\n        } catch {\n          healthResults.money = false;\n        }\n      }\n\n      if (this.engines?.product?.getBacklog) {\n        try {\n          await this.engines.product.getBacklog();\n          healthResults.product = true;\n        } catch {\n          healthResults.product = false;\n        }\n      }\n\n      return {\n        success: true,\n        type: action.type,\n        health: healthResults,\n        timestamp: Date.now(),\n      };\n    });\n\n    // Notification (safe, just sends alerts)\n    this.handlers.set(\"notification\", async (action) => {\n      const params = action.params as { channel: string; message: string };\n      this.logger.info(`[NOTIFICATION] ${params.channel}: ${params.message}`);\n      return { sent: true, type: action.type, channel: params.channel };\n    });\n  }\n}\n","/**\n * Rollback Manager\n *\n * Creates checkpoints before action execution\n * Enables undo/rollback for reversible actions\n */\n\nimport type { Action, Decision, RollbackCheckpoint } from \"../core/types.js\";\nimport { Logger } from \"../utils/logger.js\";\n\nexport type RollbackHandler = (checkpoint: RollbackCheckpoint) => Promise<void>;\n\nexport interface RollbackManagerConfig {\n  /** Maximum checkpoints to keep in memory */\n  maxCheckpoints?: number;\n  /** Checkpoint TTL in milliseconds (default 24h) */\n  checkpointTtl?: number;\n}\n\nexport class RollbackManager {\n  private logger: Logger;\n  private checkpoints: Map<string, RollbackCheckpoint>;\n  private handlers: Map<string, RollbackHandler>;\n  private maxCheckpoints: number;\n  private checkpointTtl: number;\n\n  constructor(config: RollbackManagerConfig = {}) {\n    this.logger = new Logger(\"RollbackManager\");\n    this.checkpoints = new Map();\n    this.handlers = new Map();\n    this.maxCheckpoints = config.maxCheckpoints ?? 100;\n    this.checkpointTtl = config.checkpointTtl ?? 24 * 60 * 60 * 1000; // 24 hours\n  }\n\n  /**\n   * Create a checkpoint before executing an action\n   */\n  async createCheckpoint(decision: Decision): Promise<RollbackCheckpoint> {\n    const action = decision.action;\n\n    // Only create checkpoint for reversible actions\n    if (!action.metadata.reversible) {\n      this.logger.warn(`Action ${action.type} is not reversible, no checkpoint created`);\n      throw new Error(\"Cannot create checkpoint for irreversible action\");\n    }\n\n    // Clean up old checkpoints\n    this.cleanupExpired();\n\n    // Enforce max checkpoints limit\n    if (this.checkpoints.size >= this.maxCheckpoints) {\n      this.removeOldest();\n    }\n\n    const checkpoint: RollbackCheckpoint = {\n      id: `ckpt_${Date.now()}_${action.id}`,\n      actionId: action.id,\n      decisionId: decision.id,\n      state: await this.captureState(action),\n      createdAt: Date.now(),\n    };\n\n    this.checkpoints.set(checkpoint.id, checkpoint);\n    this.logger.info(`Checkpoint created: ${checkpoint.id}`, {\n      actionId: action.id,\n      actionType: action.type,\n    });\n\n    return checkpoint;\n  }\n\n  /**\n   * Restore state from a checkpoint (rollback)\n   */\n  async rollback(checkpointId: string): Promise<void> {\n    const checkpoint = this.checkpoints.get(checkpointId);\n\n    if (!checkpoint) {\n      throw new Error(`Checkpoint not found: ${checkpointId}`);\n    }\n\n    this.logger.info(`Rolling back checkpoint: ${checkpointId}`);\n\n    // Find and execute rollback handler\n    const handler = this.findHandler(checkpoint);\n    if (handler) {\n      await handler(checkpoint);\n    } else {\n      // Generic rollback (log only)\n      this.logger.warn(`No rollback handler found, logging state only`, {\n        checkpointId,\n        state: checkpoint.state,\n      });\n    }\n\n    // Remove checkpoint after rollback\n    this.checkpoints.delete(checkpointId);\n\n    this.logger.info(`Rollback complete: ${checkpointId}`);\n  }\n\n  /**\n   * Rollback by action ID\n   */\n  async rollbackByActionId(actionId: string): Promise<void> {\n    const checkpoint = this.findByActionId(actionId);\n\n    if (!checkpoint) {\n      throw new Error(`No checkpoint found for action: ${actionId}`);\n    }\n\n    await this.rollback(checkpoint.id);\n  }\n\n  /**\n   * Register a rollback handler for an action type\n   */\n  registerHandler(actionType: string, handler: RollbackHandler): void {\n    this.handlers.set(actionType, handler);\n    this.logger.info(`Rollback handler registered for: ${actionType}`);\n  }\n\n  /**\n   * Check if rollback is available for an action\n   */\n  canRollback(actionId: string): boolean {\n    const checkpoint = this.findByActionId(actionId);\n    if (!checkpoint) return false;\n\n    // Check if checkpoint is still valid (not expired)\n    const age = Date.now() - checkpoint.createdAt;\n    return age < this.checkpointTtl;\n  }\n\n  /**\n   * Get checkpoint for an action\n   */\n  getCheckpoint(checkpointId: string): RollbackCheckpoint | undefined {\n    return this.checkpoints.get(checkpointId);\n  }\n\n  /**\n   * Get checkpoint by action ID\n   */\n  findByActionId(actionId: string): RollbackCheckpoint | undefined {\n    for (const checkpoint of this.checkpoints.values()) {\n      if (checkpoint.actionId === actionId) {\n        return checkpoint;\n      }\n    }\n    return undefined;\n  }\n\n  /**\n   * Get all active checkpoints\n   */\n  getActiveCheckpoints(): RollbackCheckpoint[] {\n    this.cleanupExpired();\n    return Array.from(this.checkpoints.values());\n  }\n\n  /**\n   * Clear all checkpoints\n   */\n  clear(): void {\n    this.checkpoints.clear();\n    this.logger.info(\"All checkpoints cleared\");\n  }\n\n  // Private methods\n\n  /**\n   * Capture state before action execution\n   */\n  private async captureState(action: Action): Promise<Record<string, unknown>> {\n    // Generic state capture - actual implementation would depend on action type\n    return {\n      timestamp: Date.now(),\n      actionType: action.type,\n      category: action.category,\n      params: { ...action.params },\n      // Additional state would be captured by registered handlers\n    };\n  }\n\n  /**\n   * Find appropriate rollback handler for a checkpoint\n   */\n  private findHandler(checkpoint: RollbackCheckpoint): RollbackHandler | undefined {\n    const actionType = checkpoint.state.actionType as string;\n\n    // Direct match\n    if (this.handlers.has(actionType)) {\n      return this.handlers.get(actionType);\n    }\n\n    // Pattern match\n    for (const [type, handler] of this.handlers) {\n      if (actionType.includes(type)) {\n        return handler;\n      }\n    }\n\n    return undefined;\n  }\n\n  /**\n   * Remove expired checkpoints\n   */\n  private cleanupExpired(): void {\n    const now = Date.now();\n    const expired: string[] = [];\n\n    for (const [id, checkpoint] of this.checkpoints) {\n      if (now - checkpoint.createdAt > this.checkpointTtl) {\n        expired.push(id);\n      }\n    }\n\n    for (const id of expired) {\n      this.checkpoints.delete(id);\n    }\n\n    if (expired.length > 0) {\n      this.logger.debug(`Cleaned up ${expired.length} expired checkpoints`);\n    }\n  }\n\n  /**\n   * Remove oldest checkpoint\n   */\n  private removeOldest(): void {\n    let oldest: RollbackCheckpoint | null = null;\n\n    for (const checkpoint of this.checkpoints.values()) {\n      if (!oldest || checkpoint.createdAt < oldest.createdAt) {\n        oldest = checkpoint;\n      }\n    }\n\n    if (oldest) {\n      this.checkpoints.delete(oldest.id);\n      this.logger.debug(`Removed oldest checkpoint: ${oldest.id}`);\n    }\n  }\n}\n"],"mappings":";;;;;;;;;;AASA,SAAS,oBAAoB;;;ACoCtB,IAAM,cAAN,MAAkB;AAAA,EACf;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAA4B,CAAC,GAAG;AAC1C,SAAK,SAAS,IAAI,OAAO,aAAa;AACtC,SAAK,WAAW,oBAAI,IAAI;AACxB,SAAK,YAAY,oBAAI,IAAI;AAAA,MACvB,GAAG;AAAA,MACH,GAAI,OAAO,uBAAuB,CAAC;AAAA,IACrC,CAAC;AACD,SAAK,iBAAiB,IAAI;AAAA,MACxB,OAAO,kBAAkB,CAAC,GAAG,sBAAsB;AAAA,IACrD;AACA,SAAK,UAAU,OAAO;AAGtB,SAAK,wBAAwB;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,YAAoB,SAA8B;AAChE,SAAK,SAAS,IAAI,YAAY,OAAO;AACrC,SAAK,OAAO,KAAK,2BAA2B,UAAU,EAAE;AAAA,EAC1D;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,SAA6C;AAC1D,SAAK,UAAU,EAAE,GAAG,KAAK,SAAS,GAAG,QAAQ;AAC7C,SAAK,OAAO,KAAK,qBAAqB;AAAA,MACpC,OAAO,CAAC,CAAC,SAAS;AAAA,MAClB,QAAQ,CAAC,CAAC,SAAS;AAAA,MACnB,SAAS,CAAC,CAAC,SAAS;AAAA,IACtB,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,YAA6B;AAElC,QAAI,KAAK,UAAU,IAAI,UAAU,EAAG,QAAO;AAG3C,eAAW,QAAQ,KAAK,WAAW;AACjC,UAAI,WAAW,SAAS,IAAI,EAAG,QAAO;AAAA,IACxC;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,YAA6B;AAEvC,QAAI,KAAK,eAAe,IAAI,UAAU,EAAG,QAAO;AAGhD,eAAW,aAAa,KAAK,gBAAgB;AAC3C,UAAI,WAAW,SAAS,SAAS,EAAG,QAAO;AAAA,IAC7C;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,WAAW,YAA+C;AAExD,QAAI,KAAK,SAAS,IAAI,UAAU,GAAG;AACjC,aAAO,KAAK,SAAS,IAAI,UAAU;AAAA,IACrC;AAGA,eAAW,CAAC,MAAM,OAAO,KAAK,KAAK,UAAU;AAC3C,UAAI,WAAW,SAAS,IAAI,KAAK,KAAK,SAAS,UAAU,GAAG;AAC1D,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,QAAkC;AAC9C,UAAM,UAAU,KAAK,WAAW,OAAO,IAAI;AAE3C,QAAI,CAAC,SAAS;AACZ,YAAM,IAAI,MAAM,0CAA0C,OAAO,IAAI,EAAE;AAAA,IACzE;AAEA,SAAK,OAAO,KAAK,cAAc,OAAO,IAAI,IAAI,EAAE,UAAU,OAAO,GAAG,CAAC;AACrE,WAAO,QAAQ,MAAM;AAAA,EACvB;AAAA;AAAA;AAAA;AAAA,EAKA,eAAyB;AACvB,WAAO,MAAM,KAAK,KAAK,SAAS;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKA,oBAA8B;AAC5B,WAAO,MAAM,KAAK,KAAK,cAAc;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,YAA0B;AACpC,SAAK,UAAU,IAAI,UAAU;AAC7B,SAAK,eAAe,OAAO,UAAU;AAAA,EACvC;AAAA;AAAA;AAAA;AAAA,EAKA,iBAAiB,YAA0B;AACzC,SAAK,eAAe,IAAI,UAAU;AAClC,SAAK,UAAU,OAAO,UAAU;AAAA,EAClC;AAAA;AAAA;AAAA;AAAA,EAKQ,0BAAgC;AAMtC,SAAK,SAAS,IAAI,YAAY,OAAO,WAAW;AAC9C,WAAK,OAAO,KAAK,4BAA4B,OAAO,IAAI,IAAI,OAAO,MAAM;AACzE,aAAO,EAAE,QAAQ,MAAM,QAAQ,OAAO,KAAK;AAAA,IAC7C,CAAC;AAGD,SAAK,SAAS,IAAI,eAAe,OAAO,WAAW;AACjD,aAAO,EAAE,aAAa,MAAM,UAAU,OAAO,GAAG;AAAA,IAClD,CAAC;AAOD,SAAK,SAAS,IAAI,kBAAkB,OAAO,WAAW;AACpD,UAAI,CAAC,KAAK,SAAS,QAAQ,eAAe;AACxC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,8BAA8B;AAAA,MACtF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,OAAO,cAAc,EAAE,OAAO,QAAQ,MAAM,CAAC;AAC/E,aAAO,EAAE,SAAS,MAAM,MAAM,OAAO,MAAM,SAAS,OAAO,QAAQ;AAAA,IACrE,CAAC;AAGD,SAAK,SAAS,IAAI,cAAc,OAAO,WAAW;AAChD,UAAI,CAAC,KAAK,SAAS,QAAQ,WAAW;AACpC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,8BAA8B;AAAA,MACtF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,OAAO,UAAU,OAAO,OAAO;AACjE,aAAO,EAAE,SAAS,OAAO,SAAS,MAAM,OAAO,MAAM,SAAS,OAAO,QAAQ;AAAA,IAC/E,CAAC;AAGD,SAAK,SAAS,IAAI,iBAAiB,OAAO,WAAW;AACnD,UAAI,CAAC,KAAK,SAAS,QAAQ,cAAc;AACvC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,8BAA8B;AAAA,MACtF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,OAAO,aAAa,EAAE,OAAO,OAAO,MAAM,CAAC;AAC7E,aAAO,EAAE,SAAS,MAAM,MAAM,OAAO,MAAM,OAAO,OAAO,OAAO,eAAe,OAAO,QAAQ,OAAO;AAAA,IACvG,CAAC;AAGD,SAAK,SAAS,IAAI,gBAAgB,OAAO,WAAW;AAClD,UAAI,CAAC,KAAK,SAAS,QAAQ,aAAa;AACtC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,8BAA8B;AAAA,MACtF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,OAAO,YAAY,MAAM;AAC3D,aAAO,EAAE,SAAS,OAAO,SAAS,MAAM,OAAO,MAAM,KAAK,OAAO,IAAI;AAAA,IACvE,CAAC;AAGD,SAAK,SAAS,IAAI,WAAW,OAAO,WAAW;AAC7C,YAAM,UAAU,OAAO,QAAQ;AAC/B,cAAQ,SAAS;AAAA,QACf,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,gBAAgB,EAAG,MAAM;AAAA,QACpD,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,eAAe,EAAG,MAAM;AAAA,QACnD;AACE,iBAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,QAAQ;AAAA,MACzD;AAAA,IACF,CAAC;AAOD,SAAK,SAAS,IAAI,WAAW,OAAO,WAAW;AAC7C,UAAI,CAAC,KAAK,SAAS,OAAO,YAAY;AACpC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,6BAA6B;AAAA,MACrF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,MAAM,WAAW;AAAA,QACjD,OAAO,OAAO,SAAS;AAAA,QACvB,QAAQ,OAAO,UAAU;AAAA,MAC3B,CAAC;AACD,aAAO,EAAE,SAAS,OAAO,SAAS,MAAM,OAAO,MAAM,QAAQ,OAAO,OAAO;AAAA,IAC7E,CAAC;AAGD,SAAK,SAAS,IAAI,eAAe,OAAO,WAAW;AACjD,UAAI,CAAC,KAAK,SAAS,OAAO,YAAY;AACpC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,6BAA6B;AAAA,MACrF;AACA,YAAM,SAAS,MAAM,KAAK,QAAQ,MAAM,WAAW;AACnD,aAAO,EAAE,SAAS,MAAM,MAAM,OAAO,MAAM,UAAU,OAAO;AAAA,IAC9D,CAAC;AAGD,SAAK,SAAS,IAAI,YAAY,OAAO,WAAW;AAC9C,UAAI,CAAC,KAAK,SAAS,OAAO,UAAU;AAClC,eAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,SAAS,6BAA6B;AAAA,MACrF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,MAAM,SAAS,MAAM;AACvD,aAAO,EAAE,SAAS,OAAO,SAAS,MAAM,OAAO,MAAM,QAAQ,OAAO,OAAO;AAAA,IAC7E,CAAC;AAGD,SAAK,SAAS,IAAI,WAAW,OAAO,WAAW;AAC7C,YAAM,UAAU,OAAO,QAAQ;AAC/B,cAAQ,SAAS;AAAA,QACf,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,SAAS,EAAG,MAAM;AAAA,QAC7C,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,aAAa,EAAG,MAAM;AAAA,QACjD,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,UAAU,EAAG,MAAM;AAAA,QAC9C;AACE,iBAAO,EAAE,WAAW,MAAM,MAAM,OAAO,MAAM,QAAQ;AAAA,MACzD;AAAA,IACF,CAAC;AAOD,SAAK,SAAS,IAAI,iBAAiB,OAAO,WAAW;AACnD,UAAI,CAAC,KAAK,SAAS,SAAS,cAAc;AACxC,eAAO,EAAE,QAAQ,MAAM,MAAM,OAAO,MAAM,SAAS,+BAA+B;AAAA,MACpF;AACA,YAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,aAAa;AACvD,aAAO,EAAE,SAAS,MAAM,MAAM,OAAO,MAAM,OAAO,OAAO,MAAM;AAAA,IACjE,CAAC;AAGD,SAAK,SAAS,IAAI,qBAAqB,OAAO,WAAW;AACvD,UAAI,CAAC,KAAK,SAAS,SAAS,sBAAsB;AAChD,eAAO,EAAE,QAAQ,MAAM,MAAM,OAAO,MAAM,SAAS,+BAA+B;AAAA,MACpF;AACA,YAAM,SAAS,OAAO;AACtB,YAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,qBAAqB,OAAO,aAAa;AACnF,aAAO,EAAE,SAAS,MAAM,MAAM,OAAO,MAAM,SAAS,OAAO,SAAS,QAAQ,OAAO,OAAO;AAAA,IAC5F,CAAC;AAGD,SAAK,SAAS,IAAI,eAAe,OAAO,WAAW;AACjD,UAAI,CAAC,KAAK,SAAS,SAAS,YAAY;AACtC,eAAO,EAAE,QAAQ,MAAM,MAAM,OAAO,MAAM,SAAS,+BAA+B;AAAA,MACpF;AACA,YAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ,WAAW;AACrD,aAAO,EAAE,SAAS,MAAM,MAAM,OAAO,MAAM,OAAO,OAAO,MAAM;AAAA,IACjE,CAAC;AAGD,SAAK,SAAS,IAAI,SAAS,OAAO,WAAW;AAC3C,YAAM,UAAU,OAAO,QAAQ;AAC/B,cAAQ,SAAS;AAAA,QACf,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,eAAe,EAAG,MAAM;AAAA,QACnD,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,mBAAmB,EAAG,MAAM;AAAA,QACvD,KAAK;AACH,iBAAO,KAAK,SAAS,IAAI,aAAa,EAAG,MAAM;AAAA,QACjD;AACE,iBAAO,EAAE,QAAQ,MAAM,MAAM,OAAO,MAAM,QAAQ;AAAA,MACtD;AAAA,IACF,CAAC;AAOD,SAAK,SAAS,IAAI,gBAAgB,OAAO,WAAW;AAClD,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM,OAAO;AAAA,QACb,WAAW,KAAK,IAAI;AAAA,QACpB,SAAS;AAAA,UACP,OAAO,CAAC,CAAC,KAAK,SAAS;AAAA,UACvB,QAAQ,CAAC,CAAC,KAAK,SAAS;AAAA,UACxB,SAAS,CAAC,CAAC,KAAK,SAAS;AAAA,QAC3B;AAAA,MACF;AAAA,IACF,CAAC;AAGD,SAAK,SAAS,IAAI,gBAAgB,OAAO,WAAW;AAClD,YAAM,gBAAyC,CAAC;AAEhD,UAAI,KAAK,SAAS,OAAO,YAAY;AACnC,YAAI;AACF,gBAAM,KAAK,QAAQ,MAAM,WAAW;AACpC,wBAAc,QAAQ;AAAA,QACxB,QAAQ;AACN,wBAAc,QAAQ;AAAA,QACxB;AAAA,MACF;AAEA,UAAI,KAAK,SAAS,SAAS,YAAY;AACrC,YAAI;AACF,gBAAM,KAAK,QAAQ,QAAQ,WAAW;AACtC,wBAAc,UAAU;AAAA,QAC1B,QAAQ;AACN,wBAAc,UAAU;AAAA,QAC1B;AAAA,MACF;AAEA,aAAO;AAAA,QACL,SAAS;AAAA,QACT,MAAM,OAAO;AAAA,QACb,QAAQ;AAAA,QACR,WAAW,KAAK,IAAI;AAAA,MACtB;AAAA,IACF,CAAC;AAGD,SAAK,SAAS,IAAI,gBAAgB,OAAO,WAAW;AAClD,YAAM,SAAS,OAAO;AACtB,WAAK,OAAO,KAAK,kBAAkB,OAAO,OAAO,KAAK,OAAO,OAAO,EAAE;AACtE,aAAO,EAAE,MAAM,MAAM,MAAM,OAAO,MAAM,SAAS,OAAO,QAAQ;AAAA,IAClE,CAAC;AAAA,EACH;AACF;;;ACvYO,IAAM,kBAAN,MAAsB;AAAA,EACnB;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAER,YAAY,SAAgC,CAAC,GAAG;AAC9C,SAAK,SAAS,IAAI,OAAO,iBAAiB;AAC1C,SAAK,cAAc,oBAAI,IAAI;AAC3B,SAAK,WAAW,oBAAI,IAAI;AACxB,SAAK,iBAAiB,OAAO,kBAAkB;AAC/C,SAAK,gBAAgB,OAAO,iBAAiB,KAAK,KAAK,KAAK;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,iBAAiB,UAAiD;AACtE,UAAM,SAAS,SAAS;AAGxB,QAAI,CAAC,OAAO,SAAS,YAAY;AAC/B,WAAK,OAAO,KAAK,UAAU,OAAO,IAAI,2CAA2C;AACjF,YAAM,IAAI,MAAM,kDAAkD;AAAA,IACpE;AAGA,SAAK,eAAe;AAGpB,QAAI,KAAK,YAAY,QAAQ,KAAK,gBAAgB;AAChD,WAAK,aAAa;AAAA,IACpB;AAEA,UAAM,aAAiC;AAAA,MACrC,IAAI,QAAQ,KAAK,IAAI,CAAC,IAAI,OAAO,EAAE;AAAA,MACnC,UAAU,OAAO;AAAA,MACjB,YAAY,SAAS;AAAA,MACrB,OAAO,MAAM,KAAK,aAAa,MAAM;AAAA,MACrC,WAAW,KAAK,IAAI;AAAA,IACtB;AAEA,SAAK,YAAY,IAAI,WAAW,IAAI,UAAU;AAC9C,SAAK,OAAO,KAAK,uBAAuB,WAAW,EAAE,IAAI;AAAA,MACvD,UAAU,OAAO;AAAA,MACjB,YAAY,OAAO;AAAA,IACrB,CAAC;AAED,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,cAAqC;AAClD,UAAM,aAAa,KAAK,YAAY,IAAI,YAAY;AAEpD,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,yBAAyB,YAAY,EAAE;AAAA,IACzD;AAEA,SAAK,OAAO,KAAK,4BAA4B,YAAY,EAAE;AAG3D,UAAM,UAAU,KAAK,YAAY,UAAU;AAC3C,QAAI,SAAS;AACX,YAAM,QAAQ,UAAU;AAAA,IAC1B,OAAO;AAEL,WAAK,OAAO,KAAK,iDAAiD;AAAA,QAChE;AAAA,QACA,OAAO,WAAW;AAAA,MACpB,CAAC;AAAA,IACH;AAGA,SAAK,YAAY,OAAO,YAAY;AAEpC,SAAK,OAAO,KAAK,sBAAsB,YAAY,EAAE;AAAA,EACvD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,mBAAmB,UAAiC;AACxD,UAAM,aAAa,KAAK,eAAe,QAAQ;AAE/C,QAAI,CAAC,YAAY;AACf,YAAM,IAAI,MAAM,mCAAmC,QAAQ,EAAE;AAAA,IAC/D;AAEA,UAAM,KAAK,SAAS,WAAW,EAAE;AAAA,EACnC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,YAAoB,SAAgC;AAClE,SAAK,SAAS,IAAI,YAAY,OAAO;AACrC,SAAK,OAAO,KAAK,oCAAoC,UAAU,EAAE;AAAA,EACnE;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,UAA2B;AACrC,UAAM,aAAa,KAAK,eAAe,QAAQ;AAC/C,QAAI,CAAC,WAAY,QAAO;AAGxB,UAAM,MAAM,KAAK,IAAI,IAAI,WAAW;AACpC,WAAO,MAAM,KAAK;AAAA,EACpB;AAAA;AAAA;AAAA;AAAA,EAKA,cAAc,cAAsD;AAClE,WAAO,KAAK,YAAY,IAAI,YAAY;AAAA,EAC1C;AAAA;AAAA;AAAA;AAAA,EAKA,eAAe,UAAkD;AAC/D,eAAW,cAAc,KAAK,YAAY,OAAO,GAAG;AAClD,UAAI,WAAW,aAAa,UAAU;AACpC,eAAO;AAAA,MACT;AAAA,IACF;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,uBAA6C;AAC3C,SAAK,eAAe;AACpB,WAAO,MAAM,KAAK,KAAK,YAAY,OAAO,CAAC;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,QAAc;AACZ,SAAK,YAAY,MAAM;AACvB,SAAK,OAAO,KAAK,yBAAyB;AAAA,EAC5C;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,MAAc,aAAa,QAAkD;AAE3E,WAAO;AAAA,MACL,WAAW,KAAK,IAAI;AAAA,MACpB,YAAY,OAAO;AAAA,MACnB,UAAU,OAAO;AAAA,MACjB,QAAQ,EAAE,GAAG,OAAO,OAAO;AAAA;AAAA,IAE7B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,YAAY,YAA6D;AAC/E,UAAM,aAAa,WAAW,MAAM;AAGpC,QAAI,KAAK,SAAS,IAAI,UAAU,GAAG;AACjC,aAAO,KAAK,SAAS,IAAI,UAAU;AAAA,IACrC;AAGA,eAAW,CAAC,MAAM,OAAO,KAAK,KAAK,UAAU;AAC3C,UAAI,WAAW,SAAS,IAAI,GAAG;AAC7B,eAAO;AAAA,MACT;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAuB;AAC7B,UAAM,MAAM,KAAK,IAAI;AACrB,UAAM,UAAoB,CAAC;AAE3B,eAAW,CAAC,IAAI,UAAU,KAAK,KAAK,aAAa;AAC/C,UAAI,MAAM,WAAW,YAAY,KAAK,eAAe;AACnD,gBAAQ,KAAK,EAAE;AAAA,MACjB;AAAA,IACF;AAEA,eAAW,MAAM,SAAS;AACxB,WAAK,YAAY,OAAO,EAAE;AAAA,IAC5B;AAEA,QAAI,QAAQ,SAAS,GAAG;AACtB,WAAK,OAAO,MAAM,cAAc,QAAQ,MAAM,sBAAsB;AAAA,IACtE;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAqB;AAC3B,QAAI,SAAoC;AAExC,eAAW,cAAc,KAAK,YAAY,OAAO,GAAG;AAClD,UAAI,CAAC,UAAU,WAAW,YAAY,OAAO,WAAW;AACtD,iBAAS;AAAA,MACX;AAAA,IACF;AAEA,QAAI,QAAQ;AACV,WAAK,YAAY,OAAO,OAAO,EAAE;AACjC,WAAK,OAAO,MAAM,8BAA8B,OAAO,EAAE,EAAE;AAAA,IAC7D;AAAA,EACF;AACF;;;AFpNO,IAAM,eAAN,cAA2B,aAAiC;AAAA,EACzD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA,EAEA;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA,EAER,YAAY,SAA6B,CAAC,GAAG;AAC3C,UAAM;AACN,SAAK,SAAS,IAAI,OAAO,cAAc;AACvC,SAAK,cAAc,IAAI,YAAY;AACnC,SAAK,kBAAkB,IAAI,gBAAgB;AAE3C,SAAK,SAAS;AAAA,MACZ,eAAe,OAAO,iBAAiB;AAAA,MACvC,wBACE,OAAO,0BAA0B,YAAY;AAAA,MAC/C,cAAc,OAAO,gBAAgB;AAAA,IACvC;AAEA,SAAK,YAAY,oBAAI,IAAI;AACzB,SAAK,iBAAiB;AACtB,SAAK,oBAAoB;AACzB,SAAK,gBAAgB,oBAAI,IAAI;AAAA,EAC/B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,UAA8C;AAC1D,UAAM,SAAS,SAAS;AAGxB,QAAI,SAAS,YAAY,gBAAgB;AACvC,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,CAAC,KAAK,eAAe,GAAG;AAC1B,WAAK,KAAK,0BAA0B,MAAM;AAC1C,aAAO,KAAK,mBAAmB,UAAU,qBAAqB;AAAA,IAChE;AAGA,QAAI,KAAK,UAAU,QAAQ,KAAK,OAAO,eAAe;AACpD,aAAO,KAAK;AAAA,QACV;AAAA,QACA;AAAA,MACF;AAAA,IACF;AAGA,QAAI,KAAK,aAAa,OAAO,IAAI,GAAG;AAClC,aAAO,KAAK;AAAA,QACV;AAAA,QACA,eAAe,OAAO,IAAI;AAAA,MAC5B;AAAA,IACF;AAGA,QAAI,KAAK,UAAU,IAAI,OAAO,EAAE,GAAG;AACjC,aAAO,KAAK,mBAAmB,UAAU,0BAA0B;AAAA,IACrE;AAGA,SAAK,UAAU,IAAI,OAAO,EAAE;AAC5B,SAAK,KAAK,qBAAqB,QAAQ;AACvC,UAAM,YAAY,KAAK,IAAI;AAE3B,SAAK,OAAO,KAAK,cAAc,OAAO,IAAI,IAAI;AAAA,MAC5C,UAAU,OAAO;AAAA,MACjB,YAAY,SAAS;AAAA,IACvB,CAAC;AAED,QAAI;AAEF,UAAI,OAAO,SAAS,YAAY;AAC9B,cAAM,KAAK,gBAAgB,iBAAiB,QAAQ;AAAA,MACtD;AAGA,YAAM,SAAS,MAAM,KAAK,YAAY,QAAQ,MAAM;AAGpD,YAAM,SAA0B;AAAA,QAC9B,UAAU,OAAO;AAAA,QACjB,YAAY,SAAS;AAAA,QACrB,SAAS;AAAA,QACT;AAAA,QACA,YAAY,KAAK,IAAI;AAAA,QACrB,UAAU,KAAK,IAAI,IAAI;AAAA,QACvB,YAAY;AAAA,MACd;AAEA,WAAK;AACL,WAAK,oBAAoB,KAAK,IAAI;AAElC,WAAK,OAAO,KAAK,yBAAyB,OAAO,IAAI,IAAI;AAAA,QACvD,UAAU,OAAO;AAAA,QACjB,UAAU,OAAO;AAAA,MACnB,CAAC;AAED,WAAK,KAAK,uBAAuB,MAAM;AACvC,aAAO;AAAA,IAET,SAAS,OAAO;AACd,YAAM,eAAe,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAE1E,WAAK,OAAO,MAAM,qBAAqB,OAAO,IAAI,IAAI;AAAA,QACpD,UAAU,OAAO;AAAA,QACjB,OAAO;AAAA,MACT,CAAC;AAGD,WAAK,cAAc,IAAI,OAAO,MAAM,KAAK,IAAI,CAAC;AAG9C,UAAI,aAAa;AACjB,UAAI,KAAK,OAAO,gBAAgB,OAAO,SAAS,YAAY;AAC1D,YAAI;AACF,gBAAM,KAAK,gBAAgB,mBAAmB,OAAO,EAAE;AACvD,uBAAa;AACb,eAAK,KAAK,yBAAyB,OAAO,EAAE;AAAA,QAC9C,SAAS,eAAe;AACtB,eAAK,OAAO,MAAM,uBAAuB,OAAO,EAAE,IAAI;AAAA,YACpD,OAAO,yBAAyB,QAAQ,cAAc,UAAU,OAAO,aAAa;AAAA,UACtF,CAAC;AAAA,QACH;AAAA,MACF;AAEA,YAAM,SAA0B;AAAA,QAC9B,UAAU,OAAO;AAAA,QACjB,YAAY,SAAS;AAAA,QACrB,SAAS;AAAA,QACT,OAAO;AAAA,QACP,YAAY,KAAK,IAAI;AAAA,QACrB,UAAU,KAAK,IAAI,IAAI;AAAA,QACvB;AAAA,MACF;AAEA,WAAK,KAAK,oBAAoB,MAAM;AACpC,aAAO;AAAA,IAET,UAAE;AACA,WAAK,UAAU,OAAO,OAAO,EAAE;AAAA,IACjC;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aACJ,WACoE;AACpE,UAAM,UAA6B,CAAC;AACpC,UAAM,SAA4B,CAAC;AAEnC,eAAW,YAAY,WAAW;AAChC,YAAM,SAAS,MAAM,KAAK,QAAQ,QAAQ;AAC1C,UAAI,OAAO,SAAS;AAClB,gBAAQ,KAAK,MAAM;AAAA,MACrB,OAAO;AACL,eAAO,KAAK,MAAM;AAAA,MACpB;AAAA,IACF;AAEA,WAAO,EAAE,SAAS,OAAO;AAAA,EAC3B;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,YAAoB,SAA8B;AAChE,SAAK,YAAY,gBAAgB,YAAY,OAAO;AAAA,EACtD;AAAA;AAAA;AAAA;AAAA,EAKA,WAIE;AACA,WAAO;AAAA,MACL,iBAAiB,KAAK;AAAA,MACtB,oBAAoB,KAAK,UAAU;AAAA,MACnC,kBAAkB,MAAM,KAAK,KAAK,cAAc,QAAQ,CAAC,EAAE;AAAA,QACzD,CAAC,CAAC,EAAE,IAAI,MAAM,KAAK,IAAI,IAAI,OAAO,KAAK,OAAO;AAAA,MAChD,EAAE;AAAA,IACJ;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,UAA2B;AACrC,WAAO,KAAK,gBAAgB,YAAY,QAAQ;AAAA,EAClD;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,UAAiC;AAC9C,UAAM,KAAK,gBAAgB,mBAAmB,QAAQ;AACtD,SAAK,KAAK,yBAAyB,QAAQ;AAAA,EAC7C;AAAA;AAAA;AAAA;AAAA,EAKA,iBAA8B;AAC5B,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA,EAKA,qBAAsC;AACpC,WAAO,KAAK;AAAA,EACd;AAAA;AAAA,EAIQ,iBAA0B;AAEhC,UAAM,cAAc,YAAY;AAEhC,UAAM,kBAAkB,KAAK,IAAI,IAAI,KAAK;AAC1C,UAAM,gBAAiB,KAAK,KAAK,MAAQ;AAEzC,WAAO,mBAAmB;AAAA,EAC5B;AAAA,EAEQ,aAAa,YAA6B;AAChD,UAAM,cAAc,KAAK,cAAc,IAAI,UAAU;AACrD,QAAI,CAAC,YAAa,QAAO;AAEzB,WAAO,KAAK,IAAI,IAAI,cAAc,KAAK,OAAO;AAAA,EAChD;AAAA,EAEQ,mBAAmB,UAAoB,OAAgC;AAC7E,WAAO;AAAA,MACL,UAAU,SAAS;AAAA,MACnB,YAAY,SAAS;AAAA,MACrB,SAAS;AAAA,MACT;AAAA,MACA,YAAY,KAAK,IAAI;AAAA,MACrB,UAAU;AAAA,MACV,YAAY;AAAA,IACd;AAAA,EACF;AACF;","names":[]}