{"version":3,"sources":["../src/queue/pipeline-queue.ts","../src/queue/workers.ts"],"sourcesContent":["/**\n * Pipeline Job Queue\n *\n * Background job processing for pipeline executions using Bull queue.\n * Supports retries, priority, rate limiting, and progress tracking.\n */\n\nimport { EventEmitter } from \"eventemitter3\";\n\n// =========================================================================\n// TYPES\n// =========================================================================\n\nexport interface PipelineJob {\n  id: string;\n  pipelineId: string;\n  pipelineName: string;\n  inputs: Record<string, unknown>;\n  steps: PipelineStep[];\n  userId?: string;\n  webhookUrl?: string;\n  priority?: JobPriority;\n  metadata?: Record<string, unknown>;\n}\n\nexport interface PipelineStep {\n  id: string;\n  tool: string;\n  inputs?: Record<string, unknown>;\n  dependsOn?: string[];\n}\n\nexport type JobPriority = \"critical\" | \"high\" | \"normal\" | \"low\";\nexport type JobStatus = \"waiting\" | \"active\" | \"completed\" | \"failed\" | \"delayed\" | \"paused\";\n\nexport interface JobProgress {\n  jobId: string;\n  executionId: string;\n  status: JobStatus;\n  progress: number;\n  currentStep?: string;\n  completedSteps: string[];\n  failedSteps: string[];\n  startedAt?: number;\n  completedAt?: number;\n  error?: string;\n  result?: unknown;\n}\n\nexport interface QueueConfig {\n  /** Redis connection URL */\n  redisUrl?: string;\n  /** Queue name (default: 'gicm-pipelines') */\n  queueName?: string;\n  /** Max concurrent jobs (default: 5) */\n  concurrency?: number;\n  /** Default job timeout in ms (default: 300000 = 5 min) */\n  defaultTimeout?: number;\n  /** Max retry attempts (default: 3) */\n  maxRetries?: number;\n  /** Enable rate limiting */\n  rateLimit?: {\n    max: number;\n    duration: number; // ms\n  };\n}\n\nexport interface QueueEvents {\n  \"job:added\": (job: PipelineJob) => void;\n  \"job:started\": (jobId: string, executionId: string) => void;\n  \"job:progress\": (progress: JobProgress) => void;\n  \"job:completed\": (jobId: string, result: unknown) => void;\n  \"job:failed\": (jobId: string, error: Error) => void;\n  \"job:retrying\": (jobId: string, attempt: number) => void;\n  \"queue:ready\": () => void;\n  \"queue:error\": (error: Error) => void;\n  \"queue:paused\": () => void;\n  \"queue:resumed\": () => void;\n}\n\n// Priority weights for queue ordering\nconst PRIORITY_WEIGHTS: Record<JobPriority, number> = {\n  critical: 1,\n  high: 5,\n  normal: 10,\n  low: 20,\n};\n\n// =========================================================================\n// PIPELINE QUEUE (IN-MEMORY FALLBACK)\n// =========================================================================\n\n/**\n * In-memory queue implementation for development/testing.\n * For production, use BullPipelineQueue with Redis.\n */\nexport class PipelineQueue extends EventEmitter<QueueEvents> {\n  private jobs: Map<string, PipelineJob> = new Map();\n  private progress: Map<string, JobProgress> = new Map();\n  private queue: string[] = [];\n  private processing: Set<string> = new Set();\n  private config: Required<QueueConfig>;\n  private isRunning = false;\n  private isPaused = false;\n  private jobCounter = 0;\n\n  constructor(config: QueueConfig = {}) {\n    super();\n    this.config = {\n      redisUrl: config.redisUrl || \"\",\n      queueName: config.queueName || \"gicm-pipelines\",\n      concurrency: config.concurrency || 5,\n      defaultTimeout: config.defaultTimeout || 300000,\n      maxRetries: config.maxRetries || 3,\n      rateLimit: config.rateLimit || { max: 100, duration: 60000 },\n    };\n  }\n\n  /**\n   * Initialize the queue\n   */\n  async initialize(): Promise<void> {\n    this.isRunning = true;\n    this.emit(\"queue:ready\");\n    console.log(`[Queue] Initialized in-memory queue: ${this.config.queueName}`);\n  }\n\n  /**\n   * Add a job to the queue\n   */\n  async addJob(job: Omit<PipelineJob, \"id\">): Promise<string> {\n    const jobId = `job_${Date.now()}_${++this.jobCounter}`;\n    const fullJob: PipelineJob = {\n      ...job,\n      id: jobId,\n      priority: job.priority || \"normal\",\n    };\n\n    this.jobs.set(jobId, fullJob);\n\n    // Insert into queue based on priority\n    this.insertByPriority(jobId, fullJob.priority!);\n\n    // Initialize progress\n    this.progress.set(jobId, {\n      jobId,\n      executionId: \"\",\n      status: \"waiting\",\n      progress: 0,\n      completedSteps: [],\n      failedSteps: [],\n    });\n\n    this.emit(\"job:added\", fullJob);\n\n    // Try to process next job\n    this.processNext();\n\n    return jobId;\n  }\n\n  /**\n   * Add multiple jobs at once\n   */\n  async addBulk(jobs: Array<Omit<PipelineJob, \"id\">>): Promise<string[]> {\n    const jobIds: string[] = [];\n    for (const job of jobs) {\n      const id = await this.addJob(job);\n      jobIds.push(id);\n    }\n    return jobIds;\n  }\n\n  /**\n   * Get job by ID\n   */\n  getJob(jobId: string): PipelineJob | undefined {\n    return this.jobs.get(jobId);\n  }\n\n  /**\n   * Get job progress\n   */\n  getProgress(jobId: string): JobProgress | undefined {\n    return this.progress.get(jobId);\n  }\n\n  /**\n   * Get all jobs with a specific status\n   */\n  getJobsByStatus(status: JobStatus): PipelineJob[] {\n    return Array.from(this.jobs.values()).filter((job) => {\n      const progress = this.progress.get(job.id);\n      return progress?.status === status;\n    });\n  }\n\n  /**\n   * Get queue statistics\n   */\n  getStats(): {\n    waiting: number;\n    active: number;\n    completed: number;\n    failed: number;\n    delayed: number;\n    total: number;\n  } {\n    let waiting = 0,\n      active = 0,\n      completed = 0,\n      failed = 0,\n      delayed = 0;\n\n    for (const progress of this.progress.values()) {\n      switch (progress.status) {\n        case \"waiting\":\n          waiting++;\n          break;\n        case \"active\":\n          active++;\n          break;\n        case \"completed\":\n          completed++;\n          break;\n        case \"failed\":\n          failed++;\n          break;\n        case \"delayed\":\n          delayed++;\n          break;\n      }\n    }\n\n    return {\n      waiting,\n      active,\n      completed,\n      failed,\n      delayed,\n      total: this.jobs.size,\n    };\n  }\n\n  /**\n   * Pause the queue\n   */\n  async pause(): Promise<void> {\n    this.isPaused = true;\n    this.emit(\"queue:paused\");\n  }\n\n  /**\n   * Resume the queue\n   */\n  async resume(): Promise<void> {\n    this.isPaused = false;\n    this.emit(\"queue:resumed\");\n    this.processNext();\n  }\n\n  /**\n   * Remove a job from the queue\n   */\n  async removeJob(jobId: string): Promise<boolean> {\n    const index = this.queue.indexOf(jobId);\n    if (index > -1) {\n      this.queue.splice(index, 1);\n    }\n    this.jobs.delete(jobId);\n    this.progress.delete(jobId);\n    return true;\n  }\n\n  /**\n   * Retry a failed job\n   */\n  async retryJob(jobId: string): Promise<boolean> {\n    const progress = this.progress.get(jobId);\n    if (!progress || progress.status !== \"failed\") {\n      return false;\n    }\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      return false;\n    }\n\n    // Reset progress\n    this.progress.set(jobId, {\n      jobId,\n      executionId: \"\",\n      status: \"waiting\",\n      progress: 0,\n      completedSteps: [],\n      failedSteps: [],\n    });\n\n    // Re-add to queue\n    this.insertByPriority(jobId, job.priority!);\n    this.processNext();\n\n    return true;\n  }\n\n  /**\n   * Clean completed/failed jobs older than specified time\n   */\n  async clean(olderThanMs: number = 86400000): Promise<number> {\n    const cutoff = Date.now() - olderThanMs;\n    let removed = 0;\n\n    for (const [jobId, progress] of this.progress.entries()) {\n      if (\n        (progress.status === \"completed\" || progress.status === \"failed\") &&\n        progress.completedAt &&\n        progress.completedAt < cutoff\n      ) {\n        this.jobs.delete(jobId);\n        this.progress.delete(jobId);\n        removed++;\n      }\n    }\n\n    return removed;\n  }\n\n  /**\n   * Close the queue\n   */\n  async close(): Promise<void> {\n    this.isRunning = false;\n    console.log(`[Queue] Closed queue: ${this.config.queueName}`);\n  }\n\n  /**\n   * Register a job processor\n   */\n  process(\n    processor: (job: PipelineJob, updateProgress: (p: Partial<JobProgress>) => void) => Promise<unknown>\n  ): void {\n    this.processor = processor;\n    this.processNext();\n  }\n\n  // =========================================================================\n  // PRIVATE METHODS\n  // =========================================================================\n\n  private processor:\n    | ((job: PipelineJob, updateProgress: (p: Partial<JobProgress>) => void) => Promise<unknown>)\n    | null = null;\n\n  private insertByPriority(jobId: string, priority: JobPriority): void {\n    const weight = PRIORITY_WEIGHTS[priority];\n\n    // Find insertion point based on priority\n    let insertIndex = this.queue.length;\n    for (let i = 0; i < this.queue.length; i++) {\n      const existingJob = this.jobs.get(this.queue[i]);\n      if (existingJob && PRIORITY_WEIGHTS[existingJob.priority || \"normal\"] > weight) {\n        insertIndex = i;\n        break;\n      }\n    }\n\n    this.queue.splice(insertIndex, 0, jobId);\n  }\n\n  private async processNext(): Promise<void> {\n    if (!this.isRunning || this.isPaused || !this.processor) {\n      return;\n    }\n\n    // Check concurrency limit\n    if (this.processing.size >= this.config.concurrency) {\n      return;\n    }\n\n    // Get next job from queue\n    const jobId = this.queue.shift();\n    if (!jobId) {\n      return;\n    }\n\n    const job = this.jobs.get(jobId);\n    if (!job) {\n      this.processNext();\n      return;\n    }\n\n    // Mark as processing\n    this.processing.add(jobId);\n    const executionId = `exec_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n\n    const progress = this.progress.get(jobId)!;\n    progress.status = \"active\";\n    progress.executionId = executionId;\n    progress.startedAt = Date.now();\n\n    this.emit(\"job:started\", jobId, executionId);\n\n    // Update progress callback\n    const updateProgress = (update: Partial<JobProgress>) => {\n      const current = this.progress.get(jobId);\n      if (current) {\n        Object.assign(current, update);\n        this.emit(\"job:progress\", current);\n      }\n    };\n\n    try {\n      // Execute with timeout\n      const result = await Promise.race([\n        this.processor(job, updateProgress),\n        new Promise((_, reject) =>\n          setTimeout(() => reject(new Error(\"Job timeout\")), this.config.defaultTimeout)\n        ),\n      ]);\n\n      // Mark as completed\n      progress.status = \"completed\";\n      progress.progress = 100;\n      progress.completedAt = Date.now();\n      progress.result = result;\n\n      this.emit(\"job:completed\", jobId, result);\n    } catch (error) {\n      // Mark as failed\n      progress.status = \"failed\";\n      progress.completedAt = Date.now();\n      progress.error = error instanceof Error ? error.message : String(error);\n\n      this.emit(\"job:failed\", jobId, error instanceof Error ? error : new Error(String(error)));\n    } finally {\n      this.processing.delete(jobId);\n      // Process next job\n      this.processNext();\n    }\n  }\n}\n\n// =========================================================================\n// BULL QUEUE (REDIS-BACKED)\n// =========================================================================\n\n/**\n * Redis-backed queue using Bull.\n * Requires `bullmq` package to be installed.\n */\nexport class BullPipelineQueue extends EventEmitter<QueueEvents> {\n  private config: Required<QueueConfig>;\n  private queue: unknown | null = null;\n  private worker: unknown | null = null;\n\n  constructor(config: QueueConfig = {}) {\n    super();\n    this.config = {\n      redisUrl: config.redisUrl || process.env.REDIS_URL || \"redis://localhost:6379\",\n      queueName: config.queueName || \"gicm-pipelines\",\n      concurrency: config.concurrency || 5,\n      defaultTimeout: config.defaultTimeout || 300000,\n      maxRetries: config.maxRetries || 3,\n      rateLimit: config.rateLimit || { max: 100, duration: 60000 },\n    };\n  }\n\n  /**\n   * Initialize Bull queue with Redis\n   */\n  async initialize(): Promise<void> {\n    try {\n      // Dynamic import to avoid requiring bullmq if not using Redis\n      const { Queue, Worker } = await import(\"bullmq\");\n\n      const connection = {\n        url: this.config.redisUrl,\n      };\n\n      this.queue = new Queue(this.config.queueName, {\n        connection,\n        defaultJobOptions: {\n          attempts: this.config.maxRetries,\n          backoff: {\n            type: \"exponential\",\n            delay: 1000,\n          },\n          removeOnComplete: {\n            count: 100,\n          },\n          removeOnFail: {\n            count: 50,\n          },\n        },\n      });\n\n      this.emit(\"queue:ready\");\n      console.log(`[Queue] Initialized Bull queue: ${this.config.queueName}`);\n    } catch (error) {\n      console.warn(\"[Queue] bullmq not available, falling back to in-memory queue\");\n      this.emit(\"queue:error\", error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n\n  /**\n   * Add a job to the Bull queue\n   */\n  async addJob(job: Omit<PipelineJob, \"id\">): Promise<string> {\n    if (!this.queue) {\n      throw new Error(\"Queue not initialized\");\n    }\n\n    const bullQueue = this.queue as { add: (name: string, data: unknown, opts: unknown) => Promise<{ id: string }> };\n    const result = await bullQueue.add(\"pipeline\", job, {\n      priority: PRIORITY_WEIGHTS[job.priority || \"normal\"],\n      jobId: `job_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`,\n    });\n\n    return result.id;\n  }\n\n  /**\n   * Register a processor for Bull queue\n   */\n  process(\n    processor: (job: PipelineJob, updateProgress: (p: Partial<JobProgress>) => void) => Promise<unknown>\n  ): void {\n    if (!this.queue) {\n      throw new Error(\"Queue not initialized\");\n    }\n\n    // This would typically be done in the initialize method\n    // with proper Bull Worker setup\n    console.log(\"[Queue] Bull processor registered\");\n  }\n\n  // Additional methods would mirror PipelineQueue but use Bull APIs\n  async pause(): Promise<void> {\n    const q = this.queue as { pause: () => Promise<void> } | null;\n    if (q) await q.pause();\n    this.emit(\"queue:paused\");\n  }\n\n  async resume(): Promise<void> {\n    const q = this.queue as { resume: () => Promise<void> } | null;\n    if (q) await q.resume();\n    this.emit(\"queue:resumed\");\n  }\n\n  async close(): Promise<void> {\n    const q = this.queue as { close: () => Promise<void> } | null;\n    const w = this.worker as { close: () => Promise<void> } | null;\n    if (w) await w.close();\n    if (q) await q.close();\n  }\n\n  getStats(): {\n    waiting: number;\n    active: number;\n    completed: number;\n    failed: number;\n    delayed: number;\n    total: number;\n  } {\n    return { waiting: 0, active: 0, completed: 0, failed: 0, delayed: 0, total: 0 };\n  }\n}\n\n// =========================================================================\n// FACTORY\n// =========================================================================\n\n/**\n * Create a pipeline queue instance\n * Uses Bull with Redis if available, falls back to in-memory\n */\nexport async function createPipelineQueue(config: QueueConfig = {}): Promise<PipelineQueue | BullPipelineQueue> {\n  // Try Bull with Redis first if URL provided\n  if (config.redisUrl || process.env.REDIS_URL) {\n    try {\n      const bullQueue = new BullPipelineQueue(config);\n      await bullQueue.initialize();\n      return bullQueue;\n    } catch {\n      console.log(\"[Queue] Falling back to in-memory queue\");\n    }\n  }\n\n  // Use in-memory queue\n  const memoryQueue = new PipelineQueue(config);\n  await memoryQueue.initialize();\n  return memoryQueue;\n}\n\n// =========================================================================\n// SINGLETON\n// =========================================================================\n\nlet queueInstance: PipelineQueue | BullPipelineQueue | null = null;\n\n/**\n * Get or create queue singleton\n */\nexport async function getPipelineQueue(config?: QueueConfig): Promise<PipelineQueue | BullPipelineQueue> {\n  if (!queueInstance) {\n    queueInstance = await createPipelineQueue(config);\n  }\n  return queueInstance;\n}\n","/**\n * Pipeline Queue Workers\n *\n * Background workers that process pipeline execution jobs.\n * Integrates with AnalyticsManager for cost/token tracking.\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport type { PipelineJob, PipelineStep, JobProgress, PipelineQueue, BullPipelineQueue } from \"./pipeline-queue.js\";\nimport type { AnalyticsManager } from \"../analytics.js\";\n\n// =========================================================================\n// TYPES\n// =========================================================================\n\nexport interface WorkerConfig {\n  /** Analytics manager for tracking */\n  analytics?: AnalyticsManager;\n  /** Tool execution function */\n  toolExecutor?: ToolExecutor;\n  /** Max step duration in ms (default: 60000) */\n  stepTimeout?: number;\n  /** Enable parallel step execution (default: true) */\n  parallelSteps?: boolean;\n}\n\nexport type ToolExecutor = (\n  tool: string,\n  inputs: Record<string, unknown>,\n  context: ExecutionContext\n) => Promise<ToolResult>;\n\nexport interface ToolResult {\n  success: boolean;\n  output: unknown;\n  error?: string;\n  tokens?: {\n    input: number;\n    output: number;\n  };\n  duration?: number;\n}\n\nexport interface ExecutionContext {\n  jobId: string;\n  executionId: string;\n  pipelineId: string;\n  stepResults: Map<string, ToolResult>;\n  metadata: Record<string, unknown>;\n}\n\nexport interface WorkerEvents {\n  \"step:started\": (jobId: string, stepId: string, tool: string) => void;\n  \"step:completed\": (jobId: string, stepId: string, result: ToolResult) => void;\n  \"step:failed\": (jobId: string, stepId: string, error: Error) => void;\n  \"pipeline:started\": (jobId: string, executionId: string) => void;\n  \"pipeline:completed\": (jobId: string, result: PipelineResult) => void;\n  \"pipeline:failed\": (jobId: string, error: Error) => void;\n}\n\nexport interface PipelineResult {\n  executionId: string;\n  pipelineId: string;\n  status: \"completed\" | \"failed\" | \"partial\";\n  stepResults: Record<string, ToolResult>;\n  totalDuration: number;\n  totalTokens: { input: number; output: number; total: number };\n  completedSteps: string[];\n  failedSteps: string[];\n}\n\n// =========================================================================\n// DEFAULT TOOL EXECUTOR (SIMULATION)\n// =========================================================================\n\n/**\n * Default tool executor that simulates tool execution.\n * Replace with real tool implementations in production.\n */\nconst defaultToolExecutor: ToolExecutor = async (tool, inputs, context) => {\n  // Simulate processing time\n  const duration = 500 + Math.random() * 2000;\n  await new Promise((resolve) => setTimeout(resolve, duration));\n\n  // Simulate token usage\n  const tokens = {\n    input: Math.floor(300 + Math.random() * 700),\n    output: Math.floor(100 + Math.random() * 400),\n  };\n\n  // Simulate occasional failures (5% chance)\n  if (Math.random() < 0.05) {\n    return {\n      success: false,\n      output: null,\n      error: `Simulated failure for tool: ${tool}`,\n      tokens,\n      duration,\n    };\n  }\n\n  // Generate mock output based on tool type\n  let output: unknown;\n  switch (tool) {\n    case \"hunter_discover\":\n      output = {\n        opportunities: [\n          { name: \"Token A\", score: 85, source: \"twitter\" },\n          { name: \"Token B\", score: 72, source: \"github\" },\n        ],\n      };\n      break;\n    case \"hunter_score\":\n      output = {\n        scored: (inputs.opportunities as unknown[])?.map((o, i) => ({\n          ...o,\n          finalScore: 80 - i * 5,\n        })),\n      };\n      break;\n    case \"growth_generate_blog\":\n      output = {\n        title: inputs.topic || \"Generated Blog Post\",\n        content: \"Lorem ipsum dolor sit amet...\",\n        wordCount: 1500,\n      };\n      break;\n    case \"growth_keyword_research\":\n      output = {\n        keywords: [\"crypto\", \"blockchain\", \"defi\", \"web3\"],\n        volumes: [10000, 8000, 5000, 3000],\n      };\n      break;\n    case \"money_dca_trade\":\n      output = {\n        executed: true,\n        amount: inputs.amount,\n        asset: inputs.asset,\n        txId: `tx_${Date.now()}`,\n      };\n      break;\n    case \"money_treasury_status\":\n      output = {\n        balance: { SOL: 100, USDC: 5000 },\n        allocations: { trading: 40, growth: 30, reserve: 30 },\n      };\n      break;\n    case \"autonomy_classify_risk\":\n      output = {\n        riskScore: 35,\n        level: \"low\",\n        factors: { financial: 20, reversibility: 5, visibility: 10 },\n      };\n      break;\n    default:\n      output = {\n        tool,\n        inputs,\n        executedAt: new Date().toISOString(),\n      };\n  }\n\n  return {\n    success: true,\n    output,\n    tokens,\n    duration,\n  };\n};\n\n// =========================================================================\n// PIPELINE WORKER\n// =========================================================================\n\nexport class PipelineWorker extends EventEmitter<WorkerEvents> {\n  private config: Required<WorkerConfig>;\n  private isRunning = false;\n\n  constructor(config: WorkerConfig = {}) {\n    super();\n    this.config = {\n      analytics: config.analytics || undefined!,\n      toolExecutor: config.toolExecutor || defaultToolExecutor,\n      stepTimeout: config.stepTimeout || 60000,\n      parallelSteps: config.parallelSteps !== false,\n    };\n  }\n\n  /**\n   * Register this worker with a queue\n   */\n  register(queue: PipelineQueue | BullPipelineQueue): void {\n    queue.process(async (job, updateProgress) => {\n      return this.processJob(job, updateProgress);\n    });\n    this.isRunning = true;\n    console.log(\"[Worker] Registered with queue\");\n  }\n\n  /**\n   * Process a pipeline job\n   */\n  async processJob(\n    job: PipelineJob,\n    updateProgress: (p: Partial<JobProgress>) => void\n  ): Promise<PipelineResult> {\n    const executionId = `exec_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n    const startTime = Date.now();\n\n    // Create execution context\n    const context: ExecutionContext = {\n      jobId: job.id,\n      executionId,\n      pipelineId: job.pipelineId,\n      stepResults: new Map(),\n      metadata: job.metadata || {},\n    };\n\n    // Start analytics tracking\n    if (this.config.analytics) {\n      this.config.analytics.startExecution(job.pipelineId, job.pipelineName, job.steps.length);\n    }\n\n    this.emit(\"pipeline:started\", job.id, executionId);\n\n    const completedSteps: string[] = [];\n    const failedSteps: string[] = [];\n    const stepResults: Record<string, ToolResult> = {};\n    let totalTokens = { input: 0, output: 0, total: 0 };\n\n    try {\n      // Build dependency graph\n      const stepMap = new Map(job.steps.map((s) => [s.id, s]));\n      const completed = new Set<string>();\n      const pending = new Set(job.steps.map((s) => s.id));\n\n      while (pending.size > 0) {\n        // Find steps that can run (all dependencies satisfied)\n        const ready: PipelineStep[] = [];\n        for (const stepId of pending) {\n          const step = stepMap.get(stepId)!;\n          const deps = step.dependsOn || [];\n          if (deps.every((d) => completed.has(d))) {\n            ready.push(step);\n          }\n        }\n\n        if (ready.length === 0 && pending.size > 0) {\n          throw new Error(\"Circular dependency detected or missing dependency\");\n        }\n\n        // Execute ready steps\n        const stepPromises = ready.map(async (step) => {\n          // Resolve inputs from previous steps\n          const resolvedInputs = this.resolveInputs(step.inputs || {}, context);\n\n          this.emit(\"step:started\", job.id, step.id, step.tool);\n\n          // Record step start in analytics\n          if (this.config.analytics) {\n            this.config.analytics.recordStep(executionId, step.id, step.tool, \"running\");\n          }\n\n          try {\n            // Execute tool with timeout\n            const result = await Promise.race([\n              this.config.toolExecutor(step.tool, resolvedInputs, context),\n              new Promise<ToolResult>((_, reject) =>\n                setTimeout(() => reject(new Error(\"Step timeout\")), this.config.stepTimeout)\n              ),\n            ]);\n\n            // Store result\n            context.stepResults.set(step.id, result);\n            stepResults[step.id] = result;\n\n            if (result.success) {\n              completedSteps.push(step.id);\n              completed.add(step.id);\n\n              // Track tokens\n              if (result.tokens) {\n                totalTokens.input += result.tokens.input;\n                totalTokens.output += result.tokens.output;\n                totalTokens.total += result.tokens.input + result.tokens.output;\n              }\n\n              // Record step completion in analytics\n              if (this.config.analytics) {\n                this.config.analytics.recordStep(\n                  executionId,\n                  step.id,\n                  step.tool,\n                  \"completed\",\n                  result.tokens\n                );\n              }\n\n              this.emit(\"step:completed\", job.id, step.id, result);\n            } else {\n              failedSteps.push(step.id);\n              completed.add(step.id); // Mark as done (failed)\n\n              // Record step failure in analytics\n              if (this.config.analytics) {\n                this.config.analytics.recordStep(\n                  executionId,\n                  step.id,\n                  step.tool,\n                  \"failed\",\n                  result.tokens,\n                  result.error\n                );\n              }\n\n              this.emit(\"step:failed\", job.id, step.id, new Error(result.error || \"Unknown error\"));\n            }\n\n            return { step, result };\n          } catch (error) {\n            const errorResult: ToolResult = {\n              success: false,\n              output: null,\n              error: error instanceof Error ? error.message : String(error),\n            };\n\n            context.stepResults.set(step.id, errorResult);\n            stepResults[step.id] = errorResult;\n            failedSteps.push(step.id);\n            completed.add(step.id);\n\n            // Record step failure in analytics\n            if (this.config.analytics) {\n              this.config.analytics.recordStep(\n                executionId,\n                step.id,\n                step.tool,\n                \"failed\",\n                undefined,\n                errorResult.error\n              );\n            }\n\n            this.emit(\"step:failed\", job.id, step.id, error instanceof Error ? error : new Error(String(error)));\n\n            return { step, result: errorResult };\n          } finally {\n            pending.delete(step.id);\n          }\n        });\n\n        // Execute in parallel or sequentially based on config\n        if (this.config.parallelSteps) {\n          await Promise.all(stepPromises);\n        } else {\n          for (const promise of stepPromises) {\n            await promise;\n          }\n        }\n\n        // Update progress\n        const progress = Math.round((completed.size / job.steps.length) * 100);\n        updateProgress({\n          progress,\n          completedSteps: [...completedSteps],\n          failedSteps: [...failedSteps],\n        });\n      }\n\n      // Determine final status\n      const status: PipelineResult[\"status\"] =\n        failedSteps.length === 0\n          ? \"completed\"\n          : completedSteps.length > 0\n          ? \"partial\"\n          : \"failed\";\n\n      const result: PipelineResult = {\n        executionId,\n        pipelineId: job.pipelineId,\n        status,\n        stepResults,\n        totalDuration: Date.now() - startTime,\n        totalTokens,\n        completedSteps,\n        failedSteps,\n      };\n\n      // Complete analytics tracking\n      if (this.config.analytics) {\n        this.config.analytics.completeExecution(\n          executionId,\n          status === \"completed\" ? \"completed\" : \"failed\",\n          failedSteps.length > 0 ? `Failed steps: ${failedSteps.join(\", \")}` : undefined\n        );\n      }\n\n      this.emit(\"pipeline:completed\", job.id, result);\n      return result;\n    } catch (error) {\n      // Complete analytics tracking with error\n      if (this.config.analytics) {\n        this.config.analytics.completeExecution(\n          executionId,\n          \"failed\",\n          error instanceof Error ? error.message : String(error)\n        );\n      }\n\n      this.emit(\"pipeline:failed\", job.id, error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n\n  /**\n   * Resolve step inputs from previous step outputs\n   */\n  private resolveInputs(\n    inputs: Record<string, unknown>,\n    context: ExecutionContext\n  ): Record<string, unknown> {\n    const resolved: Record<string, unknown> = {};\n\n    for (const [key, value] of Object.entries(inputs)) {\n      if (typeof value === \"string\" && value.startsWith(\"$\")) {\n        // Reference to previous step output: $stepId.path.to.value\n        const [stepId, ...path] = value.slice(1).split(\".\");\n        const stepResult = context.stepResults.get(stepId);\n\n        if (stepResult?.success && stepResult.output) {\n          let val: unknown = stepResult.output;\n          for (const p of path) {\n            if (val && typeof val === \"object\" && p in val) {\n              val = (val as Record<string, unknown>)[p];\n            } else {\n              val = undefined;\n              break;\n            }\n          }\n          resolved[key] = val;\n        } else {\n          resolved[key] = undefined;\n        }\n      } else {\n        resolved[key] = value;\n      }\n    }\n\n    return resolved;\n  }\n}\n\n// =========================================================================\n// AGENT EXECUTOR INTEGRATION\n// =========================================================================\n\n/**\n * Create a tool executor backed by the AgentExecutor\n * This bridges the worker to real gICM agents\n */\nexport function createAgentToolExecutor(): ToolExecutor {\n  // Lazy import to avoid circular dependencies\n  return async (tool, inputs, context) => {\n    const { getAgentExecutor } = await import(\"../execution/agent-executor.js\");\n    const executor = getAgentExecutor();\n\n    const result = await executor.execute(tool, inputs, {\n      executionId: context.executionId,\n      stepId: tool, // Use tool as step ID for single execution\n      pipelineId: context.pipelineId,\n      inputs,\n      previousResults: Object.fromEntries(context.stepResults),\n    });\n\n    return {\n      success: result.success,\n      output: result.data,\n      error: result.error,\n      tokens: result.tokensUsed\n        ? { input: Math.floor(result.tokensUsed * 0.7), output: Math.floor(result.tokensUsed * 0.3) }\n        : undefined,\n      duration: result.duration,\n    };\n  };\n}\n\n// =========================================================================\n// FACTORY\n// =========================================================================\n\n/**\n * Create and register a pipeline worker\n */\nexport function createPipelineWorker(\n  queue: PipelineQueue | BullPipelineQueue,\n  config: WorkerConfig = {}\n): PipelineWorker {\n  const worker = new PipelineWorker(config);\n  worker.register(queue);\n  return worker;\n}\n\n/**\n * Create a worker with real agent execution\n */\nexport function createAgentWorker(\n  queue: PipelineQueue | BullPipelineQueue,\n  config: Omit<WorkerConfig, \"toolExecutor\"> = {}\n): PipelineWorker {\n  const worker = new PipelineWorker({\n    ...config,\n    toolExecutor: createAgentToolExecutor(),\n  });\n  worker.register(queue);\n  return worker;\n}\n"],"mappings":";AAOA,SAAS,oBAAoB;AA0E7B,IAAM,mBAAgD;AAAA,EACpD,UAAU;AAAA,EACV,MAAM;AAAA,EACN,QAAQ;AAAA,EACR,KAAK;AACP;AAUO,IAAM,gBAAN,cAA4B,aAA0B;AAAA,EACnD,OAAiC,oBAAI,IAAI;AAAA,EACzC,WAAqC,oBAAI,IAAI;AAAA,EAC7C,QAAkB,CAAC;AAAA,EACnB,aAA0B,oBAAI,IAAI;AAAA,EAClC;AAAA,EACA,YAAY;AAAA,EACZ,WAAW;AAAA,EACX,aAAa;AAAA,EAErB,YAAY,SAAsB,CAAC,GAAG;AACpC,UAAM;AACN,SAAK,SAAS;AAAA,MACZ,UAAU,OAAO,YAAY;AAAA,MAC7B,WAAW,OAAO,aAAa;AAAA,MAC/B,aAAa,OAAO,eAAe;AAAA,MACnC,gBAAgB,OAAO,kBAAkB;AAAA,MACzC,YAAY,OAAO,cAAc;AAAA,MACjC,WAAW,OAAO,aAAa,EAAE,KAAK,KAAK,UAAU,IAAM;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAA4B;AAChC,SAAK,YAAY;AACjB,SAAK,KAAK,aAAa;AACvB,YAAQ,IAAI,wCAAwC,KAAK,OAAO,SAAS,EAAE;AAAA,EAC7E;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,KAA+C;AAC1D,UAAM,QAAQ,OAAO,KAAK,IAAI,CAAC,IAAI,EAAE,KAAK,UAAU;AACpD,UAAM,UAAuB;AAAA,MAC3B,GAAG;AAAA,MACH,IAAI;AAAA,MACJ,UAAU,IAAI,YAAY;AAAA,IAC5B;AAEA,SAAK,KAAK,IAAI,OAAO,OAAO;AAG5B,SAAK,iBAAiB,OAAO,QAAQ,QAAS;AAG9C,SAAK,SAAS,IAAI,OAAO;AAAA,MACvB;AAAA,MACA,aAAa;AAAA,MACb,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,gBAAgB,CAAC;AAAA,MACjB,aAAa,CAAC;AAAA,IAChB,CAAC;AAED,SAAK,KAAK,aAAa,OAAO;AAG9B,SAAK,YAAY;AAEjB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAQ,MAAyD;AACrE,UAAM,SAAmB,CAAC;AAC1B,eAAW,OAAO,MAAM;AACtB,YAAM,KAAK,MAAM,KAAK,OAAO,GAAG;AAChC,aAAO,KAAK,EAAE;AAAA,IAChB;AACA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,OAAO,OAAwC;AAC7C,WAAO,KAAK,KAAK,IAAI,KAAK;AAAA,EAC5B;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,OAAwC;AAClD,WAAO,KAAK,SAAS,IAAI,KAAK;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA,EAKA,gBAAgB,QAAkC;AAChD,WAAO,MAAM,KAAK,KAAK,KAAK,OAAO,CAAC,EAAE,OAAO,CAAC,QAAQ;AACpD,YAAM,WAAW,KAAK,SAAS,IAAI,IAAI,EAAE;AACzC,aAAO,UAAU,WAAW;AAAA,IAC9B,CAAC;AAAA,EACH;AAAA;AAAA;AAAA;AAAA,EAKA,WAOE;AACA,QAAI,UAAU,GACZ,SAAS,GACT,YAAY,GACZ,SAAS,GACT,UAAU;AAEZ,eAAW,YAAY,KAAK,SAAS,OAAO,GAAG;AAC7C,cAAQ,SAAS,QAAQ;AAAA,QACvB,KAAK;AACH;AACA;AAAA,QACF,KAAK;AACH;AACA;AAAA,QACF,KAAK;AACH;AACA;AAAA,QACF,KAAK;AACH;AACA;AAAA,QACF,KAAK;AACH;AACA;AAAA,MACJ;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA;AAAA,MACA,OAAO,KAAK,KAAK;AAAA,IACnB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAuB;AAC3B,SAAK,WAAW;AAChB,SAAK,KAAK,cAAc;AAAA,EAC1B;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAwB;AAC5B,SAAK,WAAW;AAChB,SAAK,KAAK,eAAe;AACzB,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,UAAU,OAAiC;AAC/C,UAAM,QAAQ,KAAK,MAAM,QAAQ,KAAK;AACtC,QAAI,QAAQ,IAAI;AACd,WAAK,MAAM,OAAO,OAAO,CAAC;AAAA,IAC5B;AACA,SAAK,KAAK,OAAO,KAAK;AACtB,SAAK,SAAS,OAAO,KAAK;AAC1B,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,SAAS,OAAiC;AAC9C,UAAM,WAAW,KAAK,SAAS,IAAI,KAAK;AACxC,QAAI,CAAC,YAAY,SAAS,WAAW,UAAU;AAC7C,aAAO;AAAA,IACT;AAEA,UAAM,MAAM,KAAK,KAAK,IAAI,KAAK;AAC/B,QAAI,CAAC,KAAK;AACR,aAAO;AAAA,IACT;AAGA,SAAK,SAAS,IAAI,OAAO;AAAA,MACvB;AAAA,MACA,aAAa;AAAA,MACb,QAAQ;AAAA,MACR,UAAU;AAAA,MACV,gBAAgB,CAAC;AAAA,MACjB,aAAa,CAAC;AAAA,IAChB,CAAC;AAGD,SAAK,iBAAiB,OAAO,IAAI,QAAS;AAC1C,SAAK,YAAY;AAEjB,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,MAAM,cAAsB,OAA2B;AAC3D,UAAM,SAAS,KAAK,IAAI,IAAI;AAC5B,QAAI,UAAU;AAEd,eAAW,CAAC,OAAO,QAAQ,KAAK,KAAK,SAAS,QAAQ,GAAG;AACvD,WACG,SAAS,WAAW,eAAe,SAAS,WAAW,aACxD,SAAS,eACT,SAAS,cAAc,QACvB;AACA,aAAK,KAAK,OAAO,KAAK;AACtB,aAAK,SAAS,OAAO,KAAK;AAC1B;AAAA,MACF;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,QAAuB;AAC3B,SAAK,YAAY;AACjB,YAAQ,IAAI,yBAAyB,KAAK,OAAO,SAAS,EAAE;AAAA,EAC9D;AAAA;AAAA;AAAA;AAAA,EAKA,QACE,WACM;AACN,SAAK,YAAY;AACjB,SAAK,YAAY;AAAA,EACnB;AAAA;AAAA;AAAA;AAAA,EAMQ,YAEG;AAAA,EAEH,iBAAiB,OAAe,UAA6B;AACnE,UAAM,SAAS,iBAAiB,QAAQ;AAGxC,QAAI,cAAc,KAAK,MAAM;AAC7B,aAAS,IAAI,GAAG,IAAI,KAAK,MAAM,QAAQ,KAAK;AAC1C,YAAM,cAAc,KAAK,KAAK,IAAI,KAAK,MAAM,CAAC,CAAC;AAC/C,UAAI,eAAe,iBAAiB,YAAY,YAAY,QAAQ,IAAI,QAAQ;AAC9E,sBAAc;AACd;AAAA,MACF;AAAA,IACF;AAEA,SAAK,MAAM,OAAO,aAAa,GAAG,KAAK;AAAA,EACzC;AAAA,EAEA,MAAc,cAA6B;AACzC,QAAI,CAAC,KAAK,aAAa,KAAK,YAAY,CAAC,KAAK,WAAW;AACvD;AAAA,IACF;AAGA,QAAI,KAAK,WAAW,QAAQ,KAAK,OAAO,aAAa;AACnD;AAAA,IACF;AAGA,UAAM,QAAQ,KAAK,MAAM,MAAM;AAC/B,QAAI,CAAC,OAAO;AACV;AAAA,IACF;AAEA,UAAM,MAAM,KAAK,KAAK,IAAI,KAAK;AAC/B,QAAI,CAAC,KAAK;AACR,WAAK,YAAY;AACjB;AAAA,IACF;AAGA,SAAK,WAAW,IAAI,KAAK;AACzB,UAAM,cAAc,QAAQ,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC;AAEhF,UAAM,WAAW,KAAK,SAAS,IAAI,KAAK;AACxC,aAAS,SAAS;AAClB,aAAS,cAAc;AACvB,aAAS,YAAY,KAAK,IAAI;AAE9B,SAAK,KAAK,eAAe,OAAO,WAAW;AAG3C,UAAM,iBAAiB,CAAC,WAAiC;AACvD,YAAM,UAAU,KAAK,SAAS,IAAI,KAAK;AACvC,UAAI,SAAS;AACX,eAAO,OAAO,SAAS,MAAM;AAC7B,aAAK,KAAK,gBAAgB,OAAO;AAAA,MACnC;AAAA,IACF;AAEA,QAAI;AAEF,YAAM,SAAS,MAAM,QAAQ,KAAK;AAAA,QAChC,KAAK,UAAU,KAAK,cAAc;AAAA,QAClC,IAAI;AAAA,UAAQ,CAAC,GAAG,WACd,WAAW,MAAM,OAAO,IAAI,MAAM,aAAa,CAAC,GAAG,KAAK,OAAO,cAAc;AAAA,QAC/E;AAAA,MACF,CAAC;AAGD,eAAS,SAAS;AAClB,eAAS,WAAW;AACpB,eAAS,cAAc,KAAK,IAAI;AAChC,eAAS,SAAS;AAElB,WAAK,KAAK,iBAAiB,OAAO,MAAM;AAAA,IAC1C,SAAS,OAAO;AAEd,eAAS,SAAS;AAClB,eAAS,cAAc,KAAK,IAAI;AAChC,eAAS,QAAQ,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAEtE,WAAK,KAAK,cAAc,OAAO,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAAA,IAC1F,UAAE;AACA,WAAK,WAAW,OAAO,KAAK;AAE5B,WAAK,YAAY;AAAA,IACnB;AAAA,EACF;AACF;AAUO,IAAM,oBAAN,cAAgC,aAA0B;AAAA,EACvD;AAAA,EACA,QAAwB;AAAA,EACxB,SAAyB;AAAA,EAEjC,YAAY,SAAsB,CAAC,GAAG;AACpC,UAAM;AACN,SAAK,SAAS;AAAA,MACZ,UAAU,OAAO,YAAY,QAAQ,IAAI,aAAa;AAAA,MACtD,WAAW,OAAO,aAAa;AAAA,MAC/B,aAAa,OAAO,eAAe;AAAA,MACnC,gBAAgB,OAAO,kBAAkB;AAAA,MACzC,YAAY,OAAO,cAAc;AAAA,MACjC,WAAW,OAAO,aAAa,EAAE,KAAK,KAAK,UAAU,IAAM;AAAA,IAC7D;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,aAA4B;AAChC,QAAI;AAEF,YAAM,EAAE,OAAO,OAAO,IAAI,MAAM,OAAO,QAAQ;AAE/C,YAAM,aAAa;AAAA,QACjB,KAAK,KAAK,OAAO;AAAA,MACnB;AAEA,WAAK,QAAQ,IAAI,MAAM,KAAK,OAAO,WAAW;AAAA,QAC5C;AAAA,QACA,mBAAmB;AAAA,UACjB,UAAU,KAAK,OAAO;AAAA,UACtB,SAAS;AAAA,YACP,MAAM;AAAA,YACN,OAAO;AAAA,UACT;AAAA,UACA,kBAAkB;AAAA,YAChB,OAAO;AAAA,UACT;AAAA,UACA,cAAc;AAAA,YACZ,OAAO;AAAA,UACT;AAAA,QACF;AAAA,MACF,CAAC;AAED,WAAK,KAAK,aAAa;AACvB,cAAQ,IAAI,mCAAmC,KAAK,OAAO,SAAS,EAAE;AAAA,IACxE,SAAS,OAAO;AACd,cAAQ,KAAK,+DAA+D;AAC5E,WAAK,KAAK,eAAe,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAClF,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,OAAO,KAA+C;AAC1D,QAAI,CAAC,KAAK,OAAO;AACf,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAEA,UAAM,YAAY,KAAK;AACvB,UAAM,SAAS,MAAM,UAAU,IAAI,YAAY,KAAK;AAAA,MAClD,UAAU,iBAAiB,IAAI,YAAY,QAAQ;AAAA,MACnD,OAAO,OAAO,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC;AAAA,IACpE,CAAC;AAED,WAAO,OAAO;AAAA,EAChB;AAAA;AAAA;AAAA;AAAA,EAKA,QACE,WACM;AACN,QAAI,CAAC,KAAK,OAAO;AACf,YAAM,IAAI,MAAM,uBAAuB;AAAA,IACzC;AAIA,YAAQ,IAAI,mCAAmC;AAAA,EACjD;AAAA;AAAA,EAGA,MAAM,QAAuB;AAC3B,UAAM,IAAI,KAAK;AACf,QAAI,EAAG,OAAM,EAAE,MAAM;AACrB,SAAK,KAAK,cAAc;AAAA,EAC1B;AAAA,EAEA,MAAM,SAAwB;AAC5B,UAAM,IAAI,KAAK;AACf,QAAI,EAAG,OAAM,EAAE,OAAO;AACtB,SAAK,KAAK,eAAe;AAAA,EAC3B;AAAA,EAEA,MAAM,QAAuB;AAC3B,UAAM,IAAI,KAAK;AACf,UAAM,IAAI,KAAK;AACf,QAAI,EAAG,OAAM,EAAE,MAAM;AACrB,QAAI,EAAG,OAAM,EAAE,MAAM;AAAA,EACvB;AAAA,EAEA,WAOE;AACA,WAAO,EAAE,SAAS,GAAG,QAAQ,GAAG,WAAW,GAAG,QAAQ,GAAG,SAAS,GAAG,OAAO,EAAE;AAAA,EAChF;AACF;AAUA,eAAsB,oBAAoB,SAAsB,CAAC,GAA+C;AAE9G,MAAI,OAAO,YAAY,QAAQ,IAAI,WAAW;AAC5C,QAAI;AACF,YAAM,YAAY,IAAI,kBAAkB,MAAM;AAC9C,YAAM,UAAU,WAAW;AAC3B,aAAO;AAAA,IACT,QAAQ;AACN,cAAQ,IAAI,yCAAyC;AAAA,IACvD;AAAA,EACF;AAGA,QAAM,cAAc,IAAI,cAAc,MAAM;AAC5C,QAAM,YAAY,WAAW;AAC7B,SAAO;AACT;AAMA,IAAI,gBAA0D;AAK9D,eAAsB,iBAAiB,QAAkE;AACvG,MAAI,CAAC,eAAe;AAClB,oBAAgB,MAAM,oBAAoB,MAAM;AAAA,EAClD;AACA,SAAO;AACT;;;AC1lBA,SAAS,gBAAAA,qBAAoB;AAwE7B,IAAM,sBAAoC,OAAO,MAAM,QAAQ,YAAY;AAEzE,QAAM,WAAW,MAAM,KAAK,OAAO,IAAI;AACvC,QAAM,IAAI,QAAQ,CAAC,YAAY,WAAW,SAAS,QAAQ,CAAC;AAG5D,QAAM,SAAS;AAAA,IACb,OAAO,KAAK,MAAM,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,IAC3C,QAAQ,KAAK,MAAM,MAAM,KAAK,OAAO,IAAI,GAAG;AAAA,EAC9C;AAGA,MAAI,KAAK,OAAO,IAAI,MAAM;AACxB,WAAO;AAAA,MACL,SAAS;AAAA,MACT,QAAQ;AAAA,MACR,OAAO,+BAA+B,IAAI;AAAA,MAC1C;AAAA,MACA;AAAA,IACF;AAAA,EACF;AAGA,MAAI;AACJ,UAAQ,MAAM;AAAA,IACZ,KAAK;AACH,eAAS;AAAA,QACP,eAAe;AAAA,UACb,EAAE,MAAM,WAAW,OAAO,IAAI,QAAQ,UAAU;AAAA,UAChD,EAAE,MAAM,WAAW,OAAO,IAAI,QAAQ,SAAS;AAAA,QACjD;AAAA,MACF;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,QAAS,OAAO,eAA6B,IAAI,CAAC,GAAG,OAAO;AAAA,UAC1D,GAAG;AAAA,UACH,YAAY,KAAK,IAAI;AAAA,QACvB,EAAE;AAAA,MACJ;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,OAAO,OAAO,SAAS;AAAA,QACvB,SAAS;AAAA,QACT,WAAW;AAAA,MACb;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,UAAU,CAAC,UAAU,cAAc,QAAQ,MAAM;AAAA,QACjD,SAAS,CAAC,KAAO,KAAM,KAAM,GAAI;AAAA,MACnC;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,UAAU;AAAA,QACV,QAAQ,OAAO;AAAA,QACf,OAAO,OAAO;AAAA,QACd,MAAM,MAAM,KAAK,IAAI,CAAC;AAAA,MACxB;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,SAAS,EAAE,KAAK,KAAK,MAAM,IAAK;AAAA,QAChC,aAAa,EAAE,SAAS,IAAI,QAAQ,IAAI,SAAS,GAAG;AAAA,MACtD;AACA;AAAA,IACF,KAAK;AACH,eAAS;AAAA,QACP,WAAW;AAAA,QACX,OAAO;AAAA,QACP,SAAS,EAAE,WAAW,IAAI,eAAe,GAAG,YAAY,GAAG;AAAA,MAC7D;AACA;AAAA,IACF;AACE,eAAS;AAAA,QACP;AAAA,QACA;AAAA,QACA,aAAY,oBAAI,KAAK,GAAE,YAAY;AAAA,MACrC;AAAA,EACJ;AAEA,SAAO;AAAA,IACL,SAAS;AAAA,IACT;AAAA,IACA;AAAA,IACA;AAAA,EACF;AACF;AAMO,IAAM,iBAAN,cAA6BA,cAA2B;AAAA,EACrD;AAAA,EACA,YAAY;AAAA,EAEpB,YAAY,SAAuB,CAAC,GAAG;AACrC,UAAM;AACN,SAAK,SAAS;AAAA,MACZ,WAAW,OAAO,aAAa;AAAA,MAC/B,cAAc,OAAO,gBAAgB;AAAA,MACrC,aAAa,OAAO,eAAe;AAAA,MACnC,eAAe,OAAO,kBAAkB;AAAA,IAC1C;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,OAAgD;AACvD,UAAM,QAAQ,OAAO,KAAK,mBAAmB;AAC3C,aAAO,KAAK,WAAW,KAAK,cAAc;AAAA,IAC5C,CAAC;AACD,SAAK,YAAY;AACjB,YAAQ,IAAI,gCAAgC;AAAA,EAC9C;AAAA;AAAA;AAAA;AAAA,EAKA,MAAM,WACJ,KACA,gBACyB;AACzB,UAAM,cAAc,QAAQ,KAAK,IAAI,CAAC,IAAI,KAAK,OAAO,EAAE,SAAS,EAAE,EAAE,MAAM,GAAG,CAAC,CAAC;AAChF,UAAM,YAAY,KAAK,IAAI;AAG3B,UAAM,UAA4B;AAAA,MAChC,OAAO,IAAI;AAAA,MACX;AAAA,MACA,YAAY,IAAI;AAAA,MAChB,aAAa,oBAAI,IAAI;AAAA,MACrB,UAAU,IAAI,YAAY,CAAC;AAAA,IAC7B;AAGA,QAAI,KAAK,OAAO,WAAW;AACzB,WAAK,OAAO,UAAU,eAAe,IAAI,YAAY,IAAI,cAAc,IAAI,MAAM,MAAM;AAAA,IACzF;AAEA,SAAK,KAAK,oBAAoB,IAAI,IAAI,WAAW;AAEjD,UAAM,iBAA2B,CAAC;AAClC,UAAM,cAAwB,CAAC;AAC/B,UAAM,cAA0C,CAAC;AACjD,QAAI,cAAc,EAAE,OAAO,GAAG,QAAQ,GAAG,OAAO,EAAE;AAElD,QAAI;AAEF,YAAM,UAAU,IAAI,IAAI,IAAI,MAAM,IAAI,CAAC,MAAM,CAAC,EAAE,IAAI,CAAC,CAAC,CAAC;AACvD,YAAM,YAAY,oBAAI,IAAY;AAClC,YAAM,UAAU,IAAI,IAAI,IAAI,MAAM,IAAI,CAAC,MAAM,EAAE,EAAE,CAAC;AAElD,aAAO,QAAQ,OAAO,GAAG;AAEvB,cAAM,QAAwB,CAAC;AAC/B,mBAAW,UAAU,SAAS;AAC5B,gBAAM,OAAO,QAAQ,IAAI,MAAM;AAC/B,gBAAM,OAAO,KAAK,aAAa,CAAC;AAChC,cAAI,KAAK,MAAM,CAAC,MAAM,UAAU,IAAI,CAAC,CAAC,GAAG;AACvC,kBAAM,KAAK,IAAI;AAAA,UACjB;AAAA,QACF;AAEA,YAAI,MAAM,WAAW,KAAK,QAAQ,OAAO,GAAG;AAC1C,gBAAM,IAAI,MAAM,oDAAoD;AAAA,QACtE;AAGA,cAAM,eAAe,MAAM,IAAI,OAAO,SAAS;AAE7C,gBAAM,iBAAiB,KAAK,cAAc,KAAK,UAAU,CAAC,GAAG,OAAO;AAEpE,eAAK,KAAK,gBAAgB,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI;AAGpD,cAAI,KAAK,OAAO,WAAW;AACzB,iBAAK,OAAO,UAAU,WAAW,aAAa,KAAK,IAAI,KAAK,MAAM,SAAS;AAAA,UAC7E;AAEA,cAAI;AAEF,kBAAMC,UAAS,MAAM,QAAQ,KAAK;AAAA,cAChC,KAAK,OAAO,aAAa,KAAK,MAAM,gBAAgB,OAAO;AAAA,cAC3D,IAAI;AAAA,gBAAoB,CAAC,GAAG,WAC1B,WAAW,MAAM,OAAO,IAAI,MAAM,cAAc,CAAC,GAAG,KAAK,OAAO,WAAW;AAAA,cAC7E;AAAA,YACF,CAAC;AAGD,oBAAQ,YAAY,IAAI,KAAK,IAAIA,OAAM;AACvC,wBAAY,KAAK,EAAE,IAAIA;AAEvB,gBAAIA,QAAO,SAAS;AAClB,6BAAe,KAAK,KAAK,EAAE;AAC3B,wBAAU,IAAI,KAAK,EAAE;AAGrB,kBAAIA,QAAO,QAAQ;AACjB,4BAAY,SAASA,QAAO,OAAO;AACnC,4BAAY,UAAUA,QAAO,OAAO;AACpC,4BAAY,SAASA,QAAO,OAAO,QAAQA,QAAO,OAAO;AAAA,cAC3D;AAGA,kBAAI,KAAK,OAAO,WAAW;AACzB,qBAAK,OAAO,UAAU;AAAA,kBACpB;AAAA,kBACA,KAAK;AAAA,kBACL,KAAK;AAAA,kBACL;AAAA,kBACAA,QAAO;AAAA,gBACT;AAAA,cACF;AAEA,mBAAK,KAAK,kBAAkB,IAAI,IAAI,KAAK,IAAIA,OAAM;AAAA,YACrD,OAAO;AACL,0BAAY,KAAK,KAAK,EAAE;AACxB,wBAAU,IAAI,KAAK,EAAE;AAGrB,kBAAI,KAAK,OAAO,WAAW;AACzB,qBAAK,OAAO,UAAU;AAAA,kBACpB;AAAA,kBACA,KAAK;AAAA,kBACL,KAAK;AAAA,kBACL;AAAA,kBACAA,QAAO;AAAA,kBACPA,QAAO;AAAA,gBACT;AAAA,cACF;AAEA,mBAAK,KAAK,eAAe,IAAI,IAAI,KAAK,IAAI,IAAI,MAAMA,QAAO,SAAS,eAAe,CAAC;AAAA,YACtF;AAEA,mBAAO,EAAE,MAAM,QAAAA,QAAO;AAAA,UACxB,SAAS,OAAO;AACd,kBAAM,cAA0B;AAAA,cAC9B,SAAS;AAAA,cACT,QAAQ;AAAA,cACR,OAAO,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,YAC9D;AAEA,oBAAQ,YAAY,IAAI,KAAK,IAAI,WAAW;AAC5C,wBAAY,KAAK,EAAE,IAAI;AACvB,wBAAY,KAAK,KAAK,EAAE;AACxB,sBAAU,IAAI,KAAK,EAAE;AAGrB,gBAAI,KAAK,OAAO,WAAW;AACzB,mBAAK,OAAO,UAAU;AAAA,gBACpB;AAAA,gBACA,KAAK;AAAA,gBACL,KAAK;AAAA,gBACL;AAAA,gBACA;AAAA,gBACA,YAAY;AAAA,cACd;AAAA,YACF;AAEA,iBAAK,KAAK,eAAe,IAAI,IAAI,KAAK,IAAI,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAEnG,mBAAO,EAAE,MAAM,QAAQ,YAAY;AAAA,UACrC,UAAE;AACA,oBAAQ,OAAO,KAAK,EAAE;AAAA,UACxB;AAAA,QACF,CAAC;AAGD,YAAI,KAAK,OAAO,eAAe;AAC7B,gBAAM,QAAQ,IAAI,YAAY;AAAA,QAChC,OAAO;AACL,qBAAW,WAAW,cAAc;AAClC,kBAAM;AAAA,UACR;AAAA,QACF;AAGA,cAAM,WAAW,KAAK,MAAO,UAAU,OAAO,IAAI,MAAM,SAAU,GAAG;AACrE,uBAAe;AAAA,UACb;AAAA,UACA,gBAAgB,CAAC,GAAG,cAAc;AAAA,UAClC,aAAa,CAAC,GAAG,WAAW;AAAA,QAC9B,CAAC;AAAA,MACH;AAGA,YAAM,SACJ,YAAY,WAAW,IACnB,cACA,eAAe,SAAS,IACxB,YACA;AAEN,YAAM,SAAyB;AAAA,QAC7B;AAAA,QACA,YAAY,IAAI;AAAA,QAChB;AAAA,QACA;AAAA,QACA,eAAe,KAAK,IAAI,IAAI;AAAA,QAC5B;AAAA,QACA;AAAA,QACA;AAAA,MACF;AAGA,UAAI,KAAK,OAAO,WAAW;AACzB,aAAK,OAAO,UAAU;AAAA,UACpB;AAAA,UACA,WAAW,cAAc,cAAc;AAAA,UACvC,YAAY,SAAS,IAAI,iBAAiB,YAAY,KAAK,IAAI,CAAC,KAAK;AAAA,QACvE;AAAA,MACF;AAEA,WAAK,KAAK,sBAAsB,IAAI,IAAI,MAAM;AAC9C,aAAO;AAAA,IACT,SAAS,OAAO;AAEd,UAAI,KAAK,OAAO,WAAW;AACzB,aAAK,OAAO,UAAU;AAAA,UACpB;AAAA,UACA;AAAA,UACA,iBAAiB,QAAQ,MAAM,UAAU,OAAO,KAAK;AAAA,QACvD;AAAA,MACF;AAEA,WAAK,KAAK,mBAAmB,IAAI,IAAI,iBAAiB,QAAQ,QAAQ,IAAI,MAAM,OAAO,KAAK,CAAC,CAAC;AAC9F,YAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,cACN,QACA,SACyB;AACzB,UAAM,WAAoC,CAAC;AAE3C,eAAW,CAAC,KAAK,KAAK,KAAK,OAAO,QAAQ,MAAM,GAAG;AACjD,UAAI,OAAO,UAAU,YAAY,MAAM,WAAW,GAAG,GAAG;AAEtD,cAAM,CAAC,QAAQ,GAAG,IAAI,IAAI,MAAM,MAAM,CAAC,EAAE,MAAM,GAAG;AAClD,cAAM,aAAa,QAAQ,YAAY,IAAI,MAAM;AAEjD,YAAI,YAAY,WAAW,WAAW,QAAQ;AAC5C,cAAI,MAAe,WAAW;AAC9B,qBAAW,KAAK,MAAM;AACpB,gBAAI,OAAO,OAAO,QAAQ,YAAY,KAAK,KAAK;AAC9C,oBAAO,IAAgC,CAAC;AAAA,YAC1C,OAAO;AACL,oBAAM;AACN;AAAA,YACF;AAAA,UACF;AACA,mBAAS,GAAG,IAAI;AAAA,QAClB,OAAO;AACL,mBAAS,GAAG,IAAI;AAAA,QAClB;AAAA,MACF,OAAO;AACL,iBAAS,GAAG,IAAI;AAAA,MAClB;AAAA,IACF;AAEA,WAAO;AAAA,EACT;AACF;AAUO,SAAS,0BAAwC;AAEtD,SAAO,OAAO,MAAM,QAAQ,YAAY;AACtC,UAAM,EAAE,iBAAiB,IAAI,MAAM,OAAO,8BAAgC;AAC1E,UAAM,WAAW,iBAAiB;AAElC,UAAM,SAAS,MAAM,SAAS,QAAQ,MAAM,QAAQ;AAAA,MAClD,aAAa,QAAQ;AAAA,MACrB,QAAQ;AAAA;AAAA,MACR,YAAY,QAAQ;AAAA,MACpB;AAAA,MACA,iBAAiB,OAAO,YAAY,QAAQ,WAAW;AAAA,IACzD,CAAC;AAED,WAAO;AAAA,MACL,SAAS,OAAO;AAAA,MAChB,QAAQ,OAAO;AAAA,MACf,OAAO,OAAO;AAAA,MACd,QAAQ,OAAO,aACX,EAAE,OAAO,KAAK,MAAM,OAAO,aAAa,GAAG,GAAG,QAAQ,KAAK,MAAM,OAAO,aAAa,GAAG,EAAE,IAC1F;AAAA,MACJ,UAAU,OAAO;AAAA,IACnB;AAAA,EACF;AACF;AASO,SAAS,qBACd,OACA,SAAuB,CAAC,GACR;AAChB,QAAM,SAAS,IAAI,eAAe,MAAM;AACxC,SAAO,SAAS,KAAK;AACrB,SAAO;AACT;AAKO,SAAS,kBACd,OACA,SAA6C,CAAC,GAC9B;AAChB,QAAM,SAAS,IAAI,eAAe;AAAA,IAChC,GAAG;AAAA,IACH,cAAc,wBAAwB;AAAA,EACxC,CAAC;AACD,SAAO,SAAS,KAAK;AACrB,SAAO;AACT;","names":["EventEmitter","result"]}