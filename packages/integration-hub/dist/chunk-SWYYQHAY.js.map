{"version":3,"sources":["../src/analytics.ts"],"sourcesContent":["/**\n * Analytics Manager\n *\n * Tracks pipeline execution costs, success rates, and token usage.\n * Provides aggregated metrics for dashboard visualization.\n *\n * Supports both in-memory and persistent (Supabase) storage modes.\n */\n\nimport { EventEmitter } from 'eventemitter3';\nimport type { SupabaseStorage } from './storage/supabase.js';\n\n// Types\nexport interface PipelineExecution {\n  id: string;\n  pipelineId: string;\n  pipelineName: string;\n  status: 'running' | 'completed' | 'failed' | 'cancelled';\n  startTime: number;\n  endTime?: number;\n  duration?: number;\n  steps: StepExecution[];\n  cost: ExecutionCost;\n  tokens: TokenUsage;\n  error?: string;\n}\n\nexport interface StepExecution {\n  id: string;\n  tool: string;\n  status: 'pending' | 'running' | 'completed' | 'failed' | 'skipped';\n  startTime?: number;\n  endTime?: number;\n  duration?: number;\n  tokens: TokenUsage;\n  cost: number;\n  error?: string;\n}\n\nexport interface TokenUsage {\n  input: number;\n  output: number;\n  total: number;\n}\n\nexport interface ExecutionCost {\n  total: number;\n  breakdown: {\n    llm: number;\n    api: number;\n    compute: number;\n  };\n  currency: 'USD';\n}\n\nexport interface DailyStats {\n  date: string;\n  executions: number;\n  successful: number;\n  failed: number;\n  totalCost: number;\n  totalTokens: number;\n  avgDuration: number;\n  byPipeline: Record<string, { count: number; successRate: number; avgCost: number }>;\n}\n\nexport interface AnalyticsSummary {\n  period: 'day' | 'week' | 'month';\n  totalExecutions: number;\n  successRate: number;\n  totalCost: number;\n  totalTokens: number;\n  avgDuration: number;\n  topPipelines: Array<{ id: string; name: string; count: number; successRate: number }>;\n  costTrend: Array<{ date: string; cost: number }>;\n  executionTrend: Array<{ date: string; count: number; successRate: number }>;\n}\n\nexport interface AnalyticsEvents {\n  'execution:start': (execution: PipelineExecution) => void;\n  'execution:complete': (execution: PipelineExecution) => void;\n  'step:complete': (step: StepExecution, executionId: string) => void;\n  'cost:update': (executionId: string, cost: ExecutionCost) => void;\n  'stats:daily': (stats: DailyStats) => void;\n}\n\n// Cost estimation constants (per 1K tokens)\nconst COST_PER_1K_INPUT = 0.003;  // Claude Sonnet\nconst COST_PER_1K_OUTPUT = 0.015; // Claude Sonnet\nconst API_CALL_BASE_COST = 0.001; // Base cost per external API call\n\nexport interface AnalyticsConfig {\n  /** Use persistent storage (Supabase) */\n  persistent?: boolean;\n  /** Max executions to keep in memory (default: 1000) */\n  maxInMemory?: number;\n  /** Sync to storage on every update (default: true) */\n  autoSync?: boolean;\n}\n\nexport class AnalyticsManager extends EventEmitter<AnalyticsEvents> {\n  private executions: Map<string, PipelineExecution> = new Map();\n  private dailyStats: Map<string, DailyStats> = new Map();\n  private maxExecutionsInMemory = 1000;\n  private storage: SupabaseStorage | null = null;\n  private config: AnalyticsConfig;\n\n  constructor(config: AnalyticsConfig = {}) {\n    super();\n    this.config = {\n      persistent: false,\n      maxInMemory: 1000,\n      autoSync: true,\n      ...config,\n    };\n    this.maxExecutionsInMemory = this.config.maxInMemory!;\n  }\n\n  /**\n   * Enable persistent storage with Supabase\n   */\n  async enablePersistence(storage: SupabaseStorage): Promise<void> {\n    this.storage = storage;\n    this.config.persistent = true;\n\n    // Load recent executions from storage\n    if (storage.connected) {\n      try {\n        const recent = await storage.getRecentExecutions(this.maxExecutionsInMemory);\n        for (const exec of recent) {\n          this.executions.set(exec.id, exec);\n        }\n        console.log(`[Analytics] Loaded ${recent.length} executions from storage`);\n      } catch (error) {\n        console.error('[Analytics] Failed to load from storage:', error);\n      }\n    }\n  }\n\n  /**\n   * Check if persistent storage is enabled\n   */\n  get isPersistent(): boolean {\n    return this.config.persistent === true && this.storage !== null;\n  }\n\n  /**\n   * Start tracking a new pipeline execution\n   */\n  startExecution(pipelineId: string, pipelineName: string, stepCount: number): string {\n    const executionId = `exec_${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;\n\n    const execution: PipelineExecution = {\n      id: executionId,\n      pipelineId,\n      pipelineName,\n      status: 'running',\n      startTime: Date.now(),\n      steps: [],\n      cost: {\n        total: 0,\n        breakdown: { llm: 0, api: 0, compute: 0 },\n        currency: 'USD',\n      },\n      tokens: { input: 0, output: 0, total: 0 },\n    };\n\n    this.executions.set(executionId, execution);\n    this.emit('execution:start', execution);\n\n    // Sync to storage\n    if (this.isPersistent && this.config.autoSync) {\n      this.storage!.saveExecution(execution).catch((err) => {\n        console.error('[Analytics] Failed to save execution to storage:', err);\n      });\n    }\n\n    // Cleanup old executions\n    this.cleanupOldExecutions();\n\n    return executionId;\n  }\n\n  /**\n   * Record step execution\n   */\n  recordStep(\n    executionId: string,\n    stepId: string,\n    tool: string,\n    status: StepExecution['status'],\n    tokens?: Partial<TokenUsage>,\n    error?: string\n  ): void {\n    const execution = this.executions.get(executionId);\n    if (!execution) return;\n\n    // Find existing step or create new\n    let step = execution.steps.find(s => s.id === stepId);\n\n    if (!step) {\n      step = {\n        id: stepId,\n        tool,\n        status: 'pending',\n        tokens: { input: 0, output: 0, total: 0 },\n        cost: 0,\n      };\n      execution.steps.push(step);\n    }\n\n    // Update step\n    if (status === 'running' && !step.startTime) {\n      step.startTime = Date.now();\n    }\n\n    step.status = status;\n\n    if (['completed', 'failed', 'skipped'].includes(status)) {\n      step.endTime = Date.now();\n      step.duration = step.endTime - (step.startTime || step.endTime);\n    }\n\n    if (tokens) {\n      step.tokens.input += tokens.input || 0;\n      step.tokens.output += tokens.output || 0;\n      step.tokens.total = step.tokens.input + step.tokens.output;\n    }\n\n    if (error) {\n      step.error = error;\n    }\n\n    // Calculate step cost\n    step.cost = this.calculateStepCost(step);\n\n    // Update execution totals\n    this.updateExecutionTotals(execution);\n\n    this.emit('step:complete', step, executionId);\n  }\n\n  /**\n   * Complete pipeline execution\n   */\n  completeExecution(\n    executionId: string,\n    status: 'completed' | 'failed' | 'cancelled',\n    error?: string\n  ): PipelineExecution | undefined {\n    const execution = this.executions.get(executionId);\n    if (!execution) return undefined;\n\n    execution.status = status;\n    execution.endTime = Date.now();\n    execution.duration = execution.endTime - execution.startTime;\n\n    if (error) {\n      execution.error = error;\n    }\n\n    // Update execution totals one final time\n    this.updateExecutionTotals(execution);\n\n    // Update daily stats\n    this.updateDailyStats(execution);\n\n    // Sync completed execution to storage\n    if (this.isPersistent && this.config.autoSync) {\n      this.storage!.updateExecution(execution).catch((err) => {\n        console.error('[Analytics] Failed to update execution in storage:', err);\n      });\n    }\n\n    this.emit('execution:complete', execution);\n\n    return execution;\n  }\n\n  /**\n   * Get execution by ID\n   */\n  getExecution(executionId: string): PipelineExecution | undefined {\n    return this.executions.get(executionId);\n  }\n\n  /**\n   * Get recent executions\n   */\n  getRecentExecutions(limit = 50): PipelineExecution[] {\n    return Array.from(this.executions.values())\n      .sort((a, b) => b.startTime - a.startTime)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get executions by pipeline ID\n   */\n  getExecutionsByPipeline(pipelineId: string, limit = 20): PipelineExecution[] {\n    return Array.from(this.executions.values())\n      .filter(e => e.pipelineId === pipelineId)\n      .sort((a, b) => b.startTime - a.startTime)\n      .slice(0, limit);\n  }\n\n  /**\n   * Get daily statistics\n   */\n  getDailyStats(date?: string): DailyStats | undefined {\n    const dateKey = date || new Date().toISOString().split('T')[0];\n    return this.dailyStats.get(dateKey);\n  }\n\n  /**\n   * Get statistics for a date range\n   */\n  getStatsRange(startDate: string, endDate: string): DailyStats[] {\n    const stats: DailyStats[] = [];\n    const current = new Date(startDate);\n    const end = new Date(endDate);\n\n    while (current <= end) {\n      const dateKey = current.toISOString().split('T')[0];\n      const dayStat = this.dailyStats.get(dateKey);\n      if (dayStat) {\n        stats.push(dayStat);\n      }\n      current.setDate(current.getDate() + 1);\n    }\n\n    return stats;\n  }\n\n  /**\n   * Get analytics summary for a period\n   */\n  getSummary(period: 'day' | 'week' | 'month' = 'week'): AnalyticsSummary {\n    const now = new Date();\n    let startDate: Date;\n\n    switch (period) {\n      case 'day':\n        startDate = new Date(now);\n        startDate.setHours(0, 0, 0, 0);\n        break;\n      case 'week':\n        startDate = new Date(now);\n        startDate.setDate(now.getDate() - 7);\n        break;\n      case 'month':\n        startDate = new Date(now);\n        startDate.setMonth(now.getMonth() - 1);\n        break;\n    }\n\n    // Get executions in period\n    const executions = Array.from(this.executions.values())\n      .filter(e => e.startTime >= startDate.getTime());\n\n    const totalExecutions = executions.length;\n    const successful = executions.filter(e => e.status === 'completed').length;\n    const successRate = totalExecutions > 0 ? (successful / totalExecutions) * 100 : 0;\n    const totalCost = executions.reduce((sum, e) => sum + e.cost.total, 0);\n    const totalTokens = executions.reduce((sum, e) => sum + e.tokens.total, 0);\n    const completedExecs = executions.filter(e => e.duration !== undefined);\n    const avgDuration = completedExecs.length > 0\n      ? completedExecs.reduce((sum, e) => sum + (e.duration || 0), 0) / completedExecs.length\n      : 0;\n\n    // Group by pipeline\n    const pipelineStats = new Map<string, { count: number; success: number; name: string }>();\n    for (const exec of executions) {\n      const existing = pipelineStats.get(exec.pipelineId) || { count: 0, success: 0, name: exec.pipelineName };\n      existing.count++;\n      if (exec.status === 'completed') existing.success++;\n      pipelineStats.set(exec.pipelineId, existing);\n    }\n\n    const topPipelines = Array.from(pipelineStats.entries())\n      .map(([id, stats]) => ({\n        id,\n        name: stats.name,\n        count: stats.count,\n        successRate: stats.count > 0 ? (stats.success / stats.count) * 100 : 0,\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 5);\n\n    // Build trends\n    const costTrend: Array<{ date: string; cost: number }> = [];\n    const executionTrend: Array<{ date: string; count: number; successRate: number }> = [];\n\n    const days = period === 'day' ? 1 : period === 'week' ? 7 : 30;\n    for (let i = 0; i < days; i++) {\n      const date = new Date(now);\n      date.setDate(now.getDate() - i);\n      const dateKey = date.toISOString().split('T')[0];\n\n      const dayStats = this.dailyStats.get(dateKey);\n      costTrend.unshift({\n        date: dateKey,\n        cost: dayStats?.totalCost || 0,\n      });\n      executionTrend.unshift({\n        date: dateKey,\n        count: dayStats?.executions || 0,\n        successRate: dayStats?.executions\n          ? ((dayStats.successful / dayStats.executions) * 100)\n          : 0,\n      });\n    }\n\n    return {\n      period,\n      totalExecutions,\n      successRate: Math.round(successRate * 100) / 100,\n      totalCost: Math.round(totalCost * 1000) / 1000,\n      totalTokens,\n      avgDuration: Math.round(avgDuration),\n      topPipelines,\n      costTrend,\n      executionTrend,\n    };\n  }\n\n  /**\n   * Get token usage breakdown\n   */\n  getTokenUsageBreakdown(period: 'day' | 'week' | 'month' = 'week'): {\n    total: TokenUsage;\n    byTool: Record<string, TokenUsage>;\n    byPipeline: Record<string, TokenUsage>;\n    trend: Array<{ date: string; tokens: number }>;\n  } {\n    const now = new Date();\n    let startDate: Date;\n\n    switch (period) {\n      case 'day':\n        startDate = new Date(now);\n        startDate.setHours(0, 0, 0, 0);\n        break;\n      case 'week':\n        startDate = new Date(now);\n        startDate.setDate(now.getDate() - 7);\n        break;\n      case 'month':\n        startDate = new Date(now);\n        startDate.setMonth(now.getMonth() - 1);\n        break;\n    }\n\n    const executions = Array.from(this.executions.values())\n      .filter(e => e.startTime >= startDate.getTime());\n\n    const total: TokenUsage = { input: 0, output: 0, total: 0 };\n    const byTool: Record<string, TokenUsage> = {};\n    const byPipeline: Record<string, TokenUsage> = {};\n\n    for (const exec of executions) {\n      // Total\n      total.input += exec.tokens.input;\n      total.output += exec.tokens.output;\n      total.total += exec.tokens.total;\n\n      // By pipeline\n      if (!byPipeline[exec.pipelineId]) {\n        byPipeline[exec.pipelineId] = { input: 0, output: 0, total: 0 };\n      }\n      byPipeline[exec.pipelineId].input += exec.tokens.input;\n      byPipeline[exec.pipelineId].output += exec.tokens.output;\n      byPipeline[exec.pipelineId].total += exec.tokens.total;\n\n      // By tool\n      for (const step of exec.steps) {\n        if (!byTool[step.tool]) {\n          byTool[step.tool] = { input: 0, output: 0, total: 0 };\n        }\n        byTool[step.tool].input += step.tokens.input;\n        byTool[step.tool].output += step.tokens.output;\n        byTool[step.tool].total += step.tokens.total;\n      }\n    }\n\n    // Build trend\n    const trend: Array<{ date: string; tokens: number }> = [];\n    const days = period === 'day' ? 1 : period === 'week' ? 7 : 30;\n    for (let i = 0; i < days; i++) {\n      const date = new Date(now);\n      date.setDate(now.getDate() - i);\n      const dateKey = date.toISOString().split('T')[0];\n      const dayStats = this.dailyStats.get(dateKey);\n      trend.unshift({\n        date: dateKey,\n        tokens: dayStats?.totalTokens || 0,\n      });\n    }\n\n    return { total, byTool, byPipeline, trend };\n  }\n\n  // Private methods\n  private calculateStepCost(step: StepExecution): number {\n    const inputCost = (step.tokens.input / 1000) * COST_PER_1K_INPUT;\n    const outputCost = (step.tokens.output / 1000) * COST_PER_1K_OUTPUT;\n    const apiCost = API_CALL_BASE_COST; // One API call per step\n\n    return inputCost + outputCost + apiCost;\n  }\n\n  private updateExecutionTotals(execution: PipelineExecution): void {\n    let totalInput = 0;\n    let totalOutput = 0;\n    let totalLLMCost = 0;\n    let totalAPICost = 0;\n\n    for (const step of execution.steps) {\n      totalInput += step.tokens.input;\n      totalOutput += step.tokens.output;\n      totalLLMCost += (step.tokens.input / 1000) * COST_PER_1K_INPUT;\n      totalLLMCost += (step.tokens.output / 1000) * COST_PER_1K_OUTPUT;\n      totalAPICost += API_CALL_BASE_COST;\n    }\n\n    execution.tokens = {\n      input: totalInput,\n      output: totalOutput,\n      total: totalInput + totalOutput,\n    };\n\n    execution.cost = {\n      total: totalLLMCost + totalAPICost,\n      breakdown: {\n        llm: totalLLMCost,\n        api: totalAPICost,\n        compute: 0, // Could add compute costs later\n      },\n      currency: 'USD',\n    };\n\n    this.emit('cost:update', execution.id, execution.cost);\n  }\n\n  private updateDailyStats(execution: PipelineExecution): void {\n    const dateKey = new Date(execution.startTime).toISOString().split('T')[0];\n\n    let stats = this.dailyStats.get(dateKey);\n    if (!stats) {\n      stats = {\n        date: dateKey,\n        executions: 0,\n        successful: 0,\n        failed: 0,\n        totalCost: 0,\n        totalTokens: 0,\n        avgDuration: 0,\n        byPipeline: {},\n      };\n      this.dailyStats.set(dateKey, stats);\n    }\n\n    stats.executions++;\n    if (execution.status === 'completed') stats.successful++;\n    if (execution.status === 'failed') stats.failed++;\n    stats.totalCost += execution.cost.total;\n    stats.totalTokens += execution.tokens.total;\n\n    // Update average duration\n    const completedToday = Array.from(this.executions.values())\n      .filter(e =>\n        new Date(e.startTime).toISOString().split('T')[0] === dateKey &&\n        e.duration !== undefined\n      );\n    if (completedToday.length > 0) {\n      stats.avgDuration = completedToday.reduce((sum, e) => sum + (e.duration || 0), 0) / completedToday.length;\n    }\n\n    // Update by pipeline\n    if (!stats.byPipeline[execution.pipelineId]) {\n      stats.byPipeline[execution.pipelineId] = { count: 0, successRate: 0, avgCost: 0 };\n    }\n    const pipelineStats = stats.byPipeline[execution.pipelineId];\n    pipelineStats.count++;\n\n    const pipelineExecs = Array.from(this.executions.values())\n      .filter(e =>\n        e.pipelineId === execution.pipelineId &&\n        new Date(e.startTime).toISOString().split('T')[0] === dateKey\n      );\n    const pipelineSuccessful = pipelineExecs.filter(e => e.status === 'completed').length;\n    pipelineStats.successRate = pipelineExecs.length > 0\n      ? (pipelineSuccessful / pipelineExecs.length) * 100\n      : 0;\n    pipelineStats.avgCost = pipelineExecs.reduce((sum, e) => sum + e.cost.total, 0) / pipelineExecs.length;\n\n    this.emit('stats:daily', stats);\n  }\n\n  private cleanupOldExecutions(): void {\n    if (this.executions.size <= this.maxExecutionsInMemory) return;\n\n    // Remove oldest executions\n    const sorted = Array.from(this.executions.entries())\n      .sort(([, a], [, b]) => a.startTime - b.startTime);\n\n    const toRemove = sorted.slice(0, sorted.length - this.maxExecutionsInMemory);\n    for (const [id] of toRemove) {\n      this.executions.delete(id);\n    }\n  }\n}\n\n// Singleton instance\nlet analyticsManager: AnalyticsManager | null = null;\n\n/**\n * Get or create the analytics manager singleton\n */\nexport function getAnalyticsManager(config?: AnalyticsConfig): AnalyticsManager {\n  if (!analyticsManager) {\n    analyticsManager = new AnalyticsManager(config);\n  }\n  return analyticsManager;\n}\n\n/**\n * Create analytics manager with Supabase persistence\n */\nexport async function createPersistentAnalytics(\n  storageConfig?: { url: string; serviceKey: string }\n): Promise<AnalyticsManager> {\n  // Lazy import to avoid circular dependency\n  const { getSupabaseStorage } = await import('./storage/supabase.js');\n\n  const storage = getSupabaseStorage(storageConfig ? {\n    url: storageConfig.url,\n    serviceKey: storageConfig.serviceKey,\n    fallbackToMemory: true,\n  } : undefined);\n\n  await storage.initialize();\n\n  const analytics = getAnalyticsManager({ persistent: true });\n  await analytics.enablePersistence(storage);\n\n  return analytics;\n}\n"],"mappings":"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","names":[]}