{"version":3,"sources":["../src/storage/supabase.ts"],"sourcesContent":["/**\n * Supabase Storage Module\n *\n * Provides persistent storage for pipeline analytics, webhook configs,\n * and pipeline templates using Supabase as the backend.\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport type {\n  PipelineExecution,\n  StepExecution,\n  TokenUsage,\n  ExecutionCost,\n  DailyStats,\n  AnalyticsSummary,\n} from \"../analytics.js\";\n\n// =========================================================================\n// TYPES\n// =========================================================================\n\nexport interface SupabaseConfig {\n  url: string;\n  serviceKey: string;\n  /** If true, fall back to in-memory when Supabase unavailable */\n  fallbackToMemory?: boolean;\n}\n\nexport interface WebhookConfig {\n  id: string;\n  name: string;\n  url: string;\n  secret: string;\n  events: WebhookEventType[];\n  enabled: boolean;\n  retryCount: number;\n  timeoutMs: number;\n  lastTriggeredAt?: Date;\n  lastStatus?: string;\n  failureCount: number;\n  metadata: Record<string, unknown>;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport type WebhookEventType =\n  | \"pipeline.started\"\n  | \"pipeline.completed\"\n  | \"pipeline.failed\"\n  | \"cost.threshold\"\n  | \"daily.summary\";\n\nexport interface WebhookDelivery {\n  id: string;\n  webhookId: string;\n  eventType: WebhookEventType;\n  payload: Record<string, unknown>;\n  status: \"pending\" | \"delivered\" | \"failed\" | \"retrying\";\n  attempts: number;\n  responseStatus?: number;\n  responseBody?: string;\n  error?: string;\n  deliveredAt?: Date;\n  createdAt: Date;\n}\n\nexport interface PipelineTemplate {\n  id: string;\n  name: string;\n  description?: string;\n  category: string;\n  steps: Array<{\n    id: string;\n    tool: string;\n    inputs?: Record<string, unknown>;\n    dependsOn?: string[];\n  }>;\n  defaultInputs: Record<string, unknown>;\n  isPublic: boolean;\n  usageCount: number;\n  avgCost?: number;\n  avgDurationMs?: number;\n  successRate?: number;\n  author?: string;\n  tags: string[];\n  metadata: Record<string, unknown>;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport interface StorageEvents {\n  \"execution:saved\": (execution: PipelineExecution) => void;\n  \"execution:updated\": (execution: PipelineExecution) => void;\n  \"webhook:triggered\": (delivery: WebhookDelivery) => void;\n  \"error\": (error: Error) => void;\n  \"connected\": () => void;\n  \"disconnected\": () => void;\n}\n\n// Database row types\ninterface ExecutionRow {\n  id: string;\n  execution_id: string;\n  pipeline_id: string;\n  pipeline_name: string;\n  status: string;\n  started_at: string;\n  completed_at?: string;\n  duration_ms?: number;\n  total_tokens: number;\n  input_tokens: number;\n  output_tokens: number;\n  total_cost: number;\n  llm_cost: number;\n  api_cost: number;\n  steps: StepExecution[];\n  error?: string;\n  metadata: Record<string, unknown>;\n  created_at: string;\n  updated_at: string;\n}\n\ninterface DailyRow {\n  date: string;\n  total_executions: number;\n  successful: number;\n  failed: number;\n  cancelled: number;\n  total_tokens: number;\n  input_tokens: number;\n  output_tokens: number;\n  total_cost: number;\n  avg_duration_ms: number;\n  by_pipeline: Record<string, { count: number; successRate: number; avgCost: number }>;\n  by_tool: Record<string, TokenUsage>;\n}\n\n// =========================================================================\n// SUPABASE STORAGE CLASS\n// =========================================================================\n\nexport class SupabaseStorage extends EventEmitter<StorageEvents> {\n  private config: SupabaseConfig;\n  private isConnected = false;\n  private fallbackExecutions: Map<string, PipelineExecution> = new Map();\n\n  constructor(config: SupabaseConfig) {\n    super();\n    this.config = {\n      fallbackToMemory: true,\n      ...config,\n    };\n  }\n\n  /**\n   * Initialize connection and verify schema\n   */\n  async initialize(): Promise<boolean> {\n    try {\n      // Test connection with a simple query\n      const response = await this.query(\"SELECT 1 as test\");\n      if (response.ok) {\n        this.isConnected = true;\n        this.emit(\"connected\");\n        return true;\n      }\n      throw new Error(\"Connection test failed\");\n    } catch (error) {\n      this.isConnected = false;\n      this.emit(\"error\", error instanceof Error ? error : new Error(String(error)));\n\n      if (this.config.fallbackToMemory) {\n        console.warn(\"[SupabaseStorage] Using in-memory fallback\");\n        return true;\n      }\n      return false;\n    }\n  }\n\n  /**\n   * Check if connected to Supabase\n   */\n  get connected(): boolean {\n    return this.isConnected;\n  }\n\n  // =========================================================================\n  // PIPELINE EXECUTIONS\n  // =========================================================================\n\n  /**\n   * Save a new pipeline execution\n   */\n  async saveExecution(execution: PipelineExecution): Promise<void> {\n    if (!this.isConnected) {\n      if (this.config.fallbackToMemory) {\n        this.fallbackExecutions.set(execution.id, execution);\n        this.emit(\"execution:saved\", execution);\n        return;\n      }\n      throw new Error(\"Not connected to Supabase\");\n    }\n\n    const row = this.executionToRow(execution);\n\n    const response = await this.query(\n      `INSERT INTO pipeline_executions (\n        execution_id, pipeline_id, pipeline_name, status, started_at,\n        completed_at, duration_ms, total_tokens, input_tokens, output_tokens,\n        total_cost, llm_cost, api_cost, steps, error, metadata\n      ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16)\n      ON CONFLICT (execution_id) DO UPDATE SET\n        status = EXCLUDED.status,\n        completed_at = EXCLUDED.completed_at,\n        duration_ms = EXCLUDED.duration_ms,\n        total_tokens = EXCLUDED.total_tokens,\n        input_tokens = EXCLUDED.input_tokens,\n        output_tokens = EXCLUDED.output_tokens,\n        total_cost = EXCLUDED.total_cost,\n        llm_cost = EXCLUDED.llm_cost,\n        api_cost = EXCLUDED.api_cost,\n        steps = EXCLUDED.steps,\n        error = EXCLUDED.error`,\n      [\n        row.execution_id,\n        row.pipeline_id,\n        row.pipeline_name,\n        row.status,\n        row.started_at,\n        row.completed_at,\n        row.duration_ms,\n        row.total_tokens,\n        row.input_tokens,\n        row.output_tokens,\n        row.total_cost,\n        row.llm_cost,\n        row.api_cost,\n        JSON.stringify(row.steps),\n        row.error,\n        JSON.stringify(row.metadata || {}),\n      ]\n    );\n\n    if (!response.ok) {\n      throw new Error(`Failed to save execution: ${response.error}`);\n    }\n\n    this.emit(\"execution:saved\", execution);\n  }\n\n  /**\n   * Update an existing execution\n   */\n  async updateExecution(execution: PipelineExecution): Promise<void> {\n    await this.saveExecution(execution); // Uses upsert\n    this.emit(\"execution:updated\", execution);\n  }\n\n  /**\n   * Get execution by ID\n   */\n  async getExecution(executionId: string): Promise<PipelineExecution | null> {\n    if (!this.isConnected && this.config.fallbackToMemory) {\n      return this.fallbackExecutions.get(executionId) || null;\n    }\n\n    const response = await this.query<ExecutionRow[]>(\n      \"SELECT * FROM pipeline_executions WHERE execution_id = $1\",\n      [executionId]\n    );\n\n    if (!response.ok || !response.data?.length) {\n      return null;\n    }\n\n    return this.rowToExecution(response.data[0]);\n  }\n\n  /**\n   * Get recent executions\n   */\n  async getRecentExecutions(limit = 50): Promise<PipelineExecution[]> {\n    if (!this.isConnected && this.config.fallbackToMemory) {\n      return Array.from(this.fallbackExecutions.values())\n        .sort((a, b) => b.startTime - a.startTime)\n        .slice(0, limit);\n    }\n\n    const response = await this.query<ExecutionRow[]>(\n      \"SELECT * FROM pipeline_executions ORDER BY started_at DESC LIMIT $1\",\n      [limit]\n    );\n\n    if (!response.ok || !response.data) {\n      return [];\n    }\n\n    return response.data.map((row) => this.rowToExecution(row));\n  }\n\n  /**\n   * Get executions by pipeline ID\n   */\n  async getExecutionsByPipeline(pipelineId: string, limit = 20): Promise<PipelineExecution[]> {\n    if (!this.isConnected && this.config.fallbackToMemory) {\n      return Array.from(this.fallbackExecutions.values())\n        .filter((e) => e.pipelineId === pipelineId)\n        .sort((a, b) => b.startTime - a.startTime)\n        .slice(0, limit);\n    }\n\n    const response = await this.query<ExecutionRow[]>(\n      \"SELECT * FROM pipeline_executions WHERE pipeline_id = $1 ORDER BY started_at DESC LIMIT $2\",\n      [pipelineId, limit]\n    );\n\n    if (!response.ok || !response.data) {\n      return [];\n    }\n\n    return response.data.map((row) => this.rowToExecution(row));\n  }\n\n  /**\n   * Get executions in date range\n   */\n  async getExecutionsInRange(startDate: Date, endDate: Date): Promise<PipelineExecution[]> {\n    if (!this.isConnected && this.config.fallbackToMemory) {\n      return Array.from(this.fallbackExecutions.values())\n        .filter((e) => e.startTime >= startDate.getTime() && e.startTime <= endDate.getTime())\n        .sort((a, b) => b.startTime - a.startTime);\n    }\n\n    const response = await this.query<ExecutionRow[]>(\n      \"SELECT * FROM pipeline_executions WHERE started_at >= $1 AND started_at <= $2 ORDER BY started_at DESC\",\n      [startDate.toISOString(), endDate.toISOString()]\n    );\n\n    if (!response.ok || !response.data) {\n      return [];\n    }\n\n    return response.data.map((row) => this.rowToExecution(row));\n  }\n\n  // =========================================================================\n  // DAILY ANALYTICS\n  // =========================================================================\n\n  /**\n   * Get daily stats\n   */\n  async getDailyStats(date?: string): Promise<DailyStats | null> {\n    const dateKey = date || new Date().toISOString().split(\"T\")[0];\n\n    if (!this.isConnected) {\n      return null;\n    }\n\n    const response = await this.query<DailyRow[]>(\n      \"SELECT * FROM daily_analytics WHERE date = $1\",\n      [dateKey]\n    );\n\n    if (!response.ok || !response.data?.length) {\n      return null;\n    }\n\n    const row = response.data[0];\n    return {\n      date: row.date,\n      executions: row.total_executions,\n      successful: row.successful,\n      failed: row.failed,\n      totalCost: row.total_cost,\n      totalTokens: row.total_tokens,\n      avgDuration: row.avg_duration_ms,\n      byPipeline: row.by_pipeline || {},\n    };\n  }\n\n  /**\n   * Get stats for date range\n   */\n  async getStatsRange(startDate: string, endDate: string): Promise<DailyStats[]> {\n    if (!this.isConnected) {\n      return [];\n    }\n\n    const response = await this.query<DailyRow[]>(\n      \"SELECT * FROM daily_analytics WHERE date >= $1 AND date <= $2 ORDER BY date ASC\",\n      [startDate, endDate]\n    );\n\n    if (!response.ok || !response.data) {\n      return [];\n    }\n\n    return response.data.map((row) => ({\n      date: row.date,\n      executions: row.total_executions,\n      successful: row.successful,\n      failed: row.failed,\n      totalCost: row.total_cost,\n      totalTokens: row.total_tokens,\n      avgDuration: row.avg_duration_ms,\n      byPipeline: row.by_pipeline || {},\n    }));\n  }\n\n  /**\n   * Get analytics summary\n   */\n  async getSummary(period: \"day\" | \"week\" | \"month\"): Promise<AnalyticsSummary> {\n    const now = new Date();\n    let startDate: Date;\n\n    switch (period) {\n      case \"day\":\n        startDate = new Date(now);\n        startDate.setHours(0, 0, 0, 0);\n        break;\n      case \"week\":\n        startDate = new Date(now);\n        startDate.setDate(now.getDate() - 7);\n        break;\n      case \"month\":\n        startDate = new Date(now);\n        startDate.setMonth(now.getMonth() - 1);\n        break;\n    }\n\n    const executions = await this.getExecutionsInRange(startDate, now);\n\n    const totalExecutions = executions.length;\n    const successful = executions.filter((e) => e.status === \"completed\").length;\n    const successRate = totalExecutions > 0 ? (successful / totalExecutions) * 100 : 0;\n    const totalCost = executions.reduce((sum, e) => sum + e.cost.total, 0);\n    const totalTokens = executions.reduce((sum, e) => sum + e.tokens.total, 0);\n    const completedExecs = executions.filter((e) => e.duration !== undefined);\n    const avgDuration =\n      completedExecs.length > 0\n        ? completedExecs.reduce((sum, e) => sum + (e.duration || 0), 0) / completedExecs.length\n        : 0;\n\n    // Group by pipeline\n    const pipelineStats = new Map<string, { count: number; success: number; name: string }>();\n    for (const exec of executions) {\n      const existing = pipelineStats.get(exec.pipelineId) || {\n        count: 0,\n        success: 0,\n        name: exec.pipelineName,\n      };\n      existing.count++;\n      if (exec.status === \"completed\") existing.success++;\n      pipelineStats.set(exec.pipelineId, existing);\n    }\n\n    const topPipelines = Array.from(pipelineStats.entries())\n      .map(([id, stats]) => ({\n        id,\n        name: stats.name,\n        count: stats.count,\n        successRate: stats.count > 0 ? (stats.success / stats.count) * 100 : 0,\n      }))\n      .sort((a, b) => b.count - a.count)\n      .slice(0, 5);\n\n    // Build trends from daily stats\n    const days = period === \"day\" ? 1 : period === \"week\" ? 7 : 30;\n    const statsRange = await this.getStatsRange(\n      startDate.toISOString().split(\"T\")[0],\n      now.toISOString().split(\"T\")[0]\n    );\n\n    const statsMap = new Map(statsRange.map((s) => [s.date, s]));\n    const costTrend: Array<{ date: string; cost: number }> = [];\n    const executionTrend: Array<{ date: string; count: number; successRate: number }> = [];\n\n    for (let i = 0; i < days; i++) {\n      const date = new Date(now);\n      date.setDate(now.getDate() - (days - 1 - i));\n      const dateKey = date.toISOString().split(\"T\")[0];\n      const dayStats = statsMap.get(dateKey);\n\n      costTrend.push({\n        date: dateKey,\n        cost: dayStats?.totalCost || 0,\n      });\n      executionTrend.push({\n        date: dateKey,\n        count: dayStats?.executions || 0,\n        successRate: dayStats?.executions\n          ? (dayStats.successful / dayStats.executions) * 100\n          : 0,\n      });\n    }\n\n    return {\n      period,\n      totalExecutions,\n      successRate: Math.round(successRate * 100) / 100,\n      totalCost: Math.round(totalCost * 1000) / 1000,\n      totalTokens,\n      avgDuration: Math.round(avgDuration),\n      topPipelines,\n      costTrend,\n      executionTrend,\n    };\n  }\n\n  // =========================================================================\n  // WEBHOOK CONFIGURATIONS\n  // =========================================================================\n\n  /**\n   * Save webhook config\n   */\n  async saveWebhook(webhook: Omit<WebhookConfig, \"id\" | \"createdAt\" | \"updatedAt\">): Promise<WebhookConfig> {\n    const response = await this.query<Array<{ id: string; created_at: string; updated_at: string }>>(\n      `INSERT INTO webhook_configs (name, url, secret, events, enabled, retry_count, timeout_ms, metadata)\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8)\n       RETURNING id, created_at, updated_at`,\n      [\n        webhook.name,\n        webhook.url,\n        webhook.secret,\n        webhook.events,\n        webhook.enabled,\n        webhook.retryCount,\n        webhook.timeoutMs,\n        JSON.stringify(webhook.metadata || {}),\n      ]\n    );\n\n    if (!response.ok || !response.data?.length) {\n      throw new Error(\"Failed to save webhook\");\n    }\n\n    const row = response.data[0];\n    return {\n      ...webhook,\n      id: row.id,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n    };\n  }\n\n  /**\n   * Get all enabled webhooks\n   */\n  async getEnabledWebhooks(): Promise<WebhookConfig[]> {\n    const response = await this.query<Array<{\n      id: string;\n      name: string;\n      url: string;\n      secret: string;\n      events: WebhookEventType[];\n      enabled: boolean;\n      retry_count: number;\n      timeout_ms: number;\n      last_triggered_at?: string;\n      last_status?: string;\n      failure_count: number;\n      metadata: Record<string, unknown>;\n      created_at: string;\n      updated_at: string;\n    }>>(\n      \"SELECT * FROM webhook_configs WHERE enabled = true\"\n    );\n\n    if (!response.ok || !response.data) {\n      return [];\n    }\n\n    return response.data.map((row) => ({\n      id: row.id,\n      name: row.name,\n      url: row.url,\n      secret: row.secret,\n      events: row.events,\n      enabled: row.enabled,\n      retryCount: row.retry_count,\n      timeoutMs: row.timeout_ms,\n      lastTriggeredAt: row.last_triggered_at ? new Date(row.last_triggered_at) : undefined,\n      lastStatus: row.last_status,\n      failureCount: row.failure_count,\n      metadata: row.metadata,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n    }));\n  }\n\n  /**\n   * Record webhook delivery\n   */\n  async recordDelivery(delivery: Omit<WebhookDelivery, \"id\" | \"createdAt\">): Promise<void> {\n    await this.query(\n      `INSERT INTO webhook_deliveries (webhook_id, event_type, payload, status, attempts, response_status, response_body, error, delivered_at)\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)`,\n      [\n        delivery.webhookId,\n        delivery.eventType,\n        JSON.stringify(delivery.payload),\n        delivery.status,\n        delivery.attempts,\n        delivery.responseStatus,\n        delivery.responseBody,\n        delivery.error,\n        delivery.deliveredAt?.toISOString(),\n      ]\n    );\n  }\n\n  // =========================================================================\n  // PIPELINE TEMPLATES\n  // =========================================================================\n\n  /**\n   * Save pipeline template\n   */\n  async saveTemplate(\n    template: Omit<PipelineTemplate, \"id\" | \"createdAt\" | \"updatedAt\">\n  ): Promise<PipelineTemplate> {\n    const response = await this.query<Array<{ id: string; created_at: string; updated_at: string }>>(\n      `INSERT INTO pipeline_templates (name, description, category, steps, default_inputs, is_public, author, tags, metadata)\n       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n       RETURNING id, created_at, updated_at`,\n      [\n        template.name,\n        template.description,\n        template.category,\n        JSON.stringify(template.steps),\n        JSON.stringify(template.defaultInputs || {}),\n        template.isPublic,\n        template.author,\n        template.tags,\n        JSON.stringify(template.metadata || {}),\n      ]\n    );\n\n    if (!response.ok || !response.data?.length) {\n      throw new Error(\"Failed to save template\");\n    }\n\n    const row = response.data[0];\n    return {\n      ...template,\n      id: row.id,\n      usageCount: 0,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n    };\n  }\n\n  /**\n   * Get public templates\n   */\n  async getPublicTemplates(category?: string): Promise<PipelineTemplate[]> {\n    let sql = \"SELECT * FROM pipeline_templates WHERE is_public = true\";\n    const params: unknown[] = [];\n\n    if (category) {\n      sql += \" AND category = $1\";\n      params.push(category);\n    }\n\n    sql += \" ORDER BY usage_count DESC\";\n\n    const response = await this.query<Array<{\n      id: string;\n      name: string;\n      description?: string;\n      category: string;\n      steps: PipelineTemplate[\"steps\"];\n      default_inputs: Record<string, unknown>;\n      is_public: boolean;\n      usage_count: number;\n      avg_cost?: number;\n      avg_duration_ms?: number;\n      success_rate?: number;\n      author?: string;\n      tags: string[];\n      metadata: Record<string, unknown>;\n      created_at: string;\n      updated_at: string;\n    }>>(sql, params);\n\n    if (!response.ok || !response.data) {\n      return [];\n    }\n\n    return response.data.map((row) => ({\n      id: row.id,\n      name: row.name,\n      description: row.description,\n      category: row.category,\n      steps: row.steps,\n      defaultInputs: row.default_inputs,\n      isPublic: row.is_public,\n      usageCount: row.usage_count,\n      avgCost: row.avg_cost,\n      avgDurationMs: row.avg_duration_ms,\n      successRate: row.success_rate,\n      author: row.author,\n      tags: row.tags,\n      metadata: row.metadata,\n      createdAt: new Date(row.created_at),\n      updatedAt: new Date(row.updated_at),\n    }));\n  }\n\n  /**\n   * Increment template usage count\n   */\n  async incrementTemplateUsage(templateId: string): Promise<void> {\n    await this.query(\n      \"UPDATE pipeline_templates SET usage_count = usage_count + 1 WHERE id = $1\",\n      [templateId]\n    );\n  }\n\n  // =========================================================================\n  // PRIVATE HELPERS\n  // =========================================================================\n\n  private async query<T = unknown>(\n    sql: string,\n    params: unknown[] = []\n  ): Promise<{ ok: boolean; data?: T; error?: string }> {\n    try {\n      const response = await fetch(`${this.config.url}/rest/v1/rpc/raw_sql`, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          apikey: this.config.serviceKey,\n          Authorization: `Bearer ${this.config.serviceKey}`,\n          Prefer: \"return=representation\",\n        },\n        body: JSON.stringify({ query: sql, params }),\n      });\n\n      if (!response.ok) {\n        // Fall back to PostgREST API for simple queries\n        return this.postgrestQuery<T>(sql, params);\n      }\n\n      const data = await response.json();\n      return { ok: true, data };\n    } catch (error) {\n      // Try PostgREST fallback\n      return this.postgrestQuery<T>(sql, params);\n    }\n  }\n\n  private async postgrestQuery<T>(\n    sql: string,\n    params: unknown[]\n  ): Promise<{ ok: boolean; data?: T; error?: string }> {\n    // Parse SQL to determine operation and table\n    const selectMatch = sql.match(/SELECT\\s+\\*\\s+FROM\\s+(\\w+)/i);\n    const insertMatch = sql.match(/INSERT\\s+INTO\\s+(\\w+)/i);\n\n    if (selectMatch) {\n      const table = selectMatch[1];\n      try {\n        // Extract WHERE conditions (simplified)\n        let url = `${this.config.url}/rest/v1/${table}?select=*`;\n\n        // Handle simple equality conditions\n        const whereMatch = sql.match(/WHERE\\s+(\\w+)\\s*=\\s*\\$(\\d+)/gi);\n        if (whereMatch && params.length > 0) {\n          whereMatch.forEach((match) => {\n            const [, col, idx] = match.match(/WHERE\\s+(\\w+)\\s*=\\s*\\$(\\d+)/i) || [];\n            if (col && idx) {\n              url += `&${col}=eq.${encodeURIComponent(String(params[parseInt(idx) - 1]))}`;\n            }\n          });\n        }\n\n        // Handle ORDER BY\n        const orderMatch = sql.match(/ORDER BY\\s+(\\w+)\\s+(ASC|DESC)?/i);\n        if (orderMatch) {\n          const [, col, dir] = orderMatch;\n          url += `&order=${col}.${(dir || \"asc\").toLowerCase()}`;\n        }\n\n        // Handle LIMIT\n        const limitMatch = sql.match(/LIMIT\\s+\\$?(\\d+)/i);\n        if (limitMatch) {\n          const limitIdx = parseInt(limitMatch[1]);\n          const limit = sql.includes(\"$\") ? params[limitIdx - 1] : limitIdx;\n          url += `&limit=${limit}`;\n        }\n\n        const response = await fetch(url, {\n          headers: {\n            apikey: this.config.serviceKey,\n            Authorization: `Bearer ${this.config.serviceKey}`,\n          },\n        });\n\n        if (!response.ok) {\n          return { ok: false, error: `HTTP ${response.status}` };\n        }\n\n        const data = await response.json();\n        return { ok: true, data: data as T };\n      } catch (error) {\n        return { ok: false, error: String(error) };\n      }\n    }\n\n    if (insertMatch) {\n      const table = insertMatch[1];\n      try {\n        // Parse column names from INSERT\n        const colsMatch = sql.match(/\\(([^)]+)\\)\\s*VALUES/i);\n        if (!colsMatch) {\n          return { ok: false, error: \"Could not parse INSERT columns\" };\n        }\n\n        const columns = colsMatch[1].split(\",\").map((c) => c.trim());\n        const body: Record<string, unknown> = {};\n\n        columns.forEach((col, idx) => {\n          body[col] = params[idx];\n        });\n\n        const response = await fetch(`${this.config.url}/rest/v1/${table}`, {\n          method: \"POST\",\n          headers: {\n            \"Content-Type\": \"application/json\",\n            apikey: this.config.serviceKey,\n            Authorization: `Bearer ${this.config.serviceKey}`,\n            Prefer: \"return=representation\",\n          },\n          body: JSON.stringify(body),\n        });\n\n        if (!response.ok) {\n          return { ok: false, error: `HTTP ${response.status}` };\n        }\n\n        const data = await response.json();\n        return { ok: true, data: data as T };\n      } catch (error) {\n        return { ok: false, error: String(error) };\n      }\n    }\n\n    // For other queries, return success (test query)\n    if (sql.includes(\"SELECT 1\")) {\n      return { ok: true, data: [{ test: 1 }] as T };\n    }\n\n    return { ok: false, error: \"Unsupported query type\" };\n  }\n\n  private executionToRow(execution: PipelineExecution): Partial<ExecutionRow> {\n    return {\n      execution_id: execution.id,\n      pipeline_id: execution.pipelineId,\n      pipeline_name: execution.pipelineName,\n      status: execution.status,\n      started_at: new Date(execution.startTime).toISOString(),\n      completed_at: execution.endTime ? new Date(execution.endTime).toISOString() : undefined,\n      duration_ms: execution.duration,\n      total_tokens: execution.tokens.total,\n      input_tokens: execution.tokens.input,\n      output_tokens: execution.tokens.output,\n      total_cost: execution.cost.total,\n      llm_cost: execution.cost.breakdown.llm,\n      api_cost: execution.cost.breakdown.api,\n      steps: execution.steps,\n      error: execution.error,\n      metadata: {},\n    };\n  }\n\n  private rowToExecution(row: ExecutionRow): PipelineExecution {\n    return {\n      id: row.execution_id,\n      pipelineId: row.pipeline_id,\n      pipelineName: row.pipeline_name,\n      status: row.status as PipelineExecution[\"status\"],\n      startTime: new Date(row.started_at).getTime(),\n      endTime: row.completed_at ? new Date(row.completed_at).getTime() : undefined,\n      duration: row.duration_ms,\n      steps: row.steps,\n      tokens: {\n        input: row.input_tokens,\n        output: row.output_tokens,\n        total: row.total_tokens,\n      },\n      cost: {\n        total: row.total_cost,\n        breakdown: {\n          llm: row.llm_cost,\n          api: row.api_cost,\n          compute: 0,\n        },\n        currency: \"USD\",\n      },\n      error: row.error,\n    };\n  }\n}\n\n// =========================================================================\n// SINGLETON\n// =========================================================================\n\nlet storageInstance: SupabaseStorage | null = null;\n\n/**\n * Get or create Supabase storage instance\n */\nexport function getSupabaseStorage(config?: SupabaseConfig): SupabaseStorage {\n  if (!storageInstance && config) {\n    storageInstance = new SupabaseStorage(config);\n  }\n\n  if (!storageInstance) {\n    // Create with env vars\n    storageInstance = new SupabaseStorage({\n      url: process.env.SUPABASE_URL || \"\",\n      serviceKey: process.env.SUPABASE_SERVICE_KEY || \"\",\n      fallbackToMemory: true,\n    });\n  }\n\n  return storageInstance;\n}\n\n/**\n * Initialize storage from environment\n */\nexport async function initializeStorage(): Promise<SupabaseStorage> {\n  const storage = getSupabaseStorage();\n  await storage.initialize();\n  return storage;\n}\n"],"mappings":"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","names":[]}