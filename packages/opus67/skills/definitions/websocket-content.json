{"text":"# WebSocket Expert\n\n> **ID:** `websocket-expert`\n> **Tier:** 2\n> **Token Cost:** 6000\n> **MCP Connections:** None\n\n## What This Skill Does\n\nMaster real-time communication with WebSockets and Socket.io. Build collaborative applications, live dashboards, chat systems, and real-time notifications with proper connection management and scaling.\n\n- WebSocket server implementation with ws library\n- Socket.io server and client setup\n- Connection management and reconnection logic\n- Room and channel patterns for multi-user apps\n- Presence detection and user status\n- Message queuing and delivery guarantees\n- Horizontal scaling with Redis adapter\n- Authentication and authorization\n- Error handling and heartbeats\n- React hooks for WebSocket state\n\n## When to Use\n\nThis skill is automatically loaded when:\n\n- **Keywords:** websocket, socket.io, real-time, ws, live, streaming, push\n- **File Types:** socket.ts, ws.ts, websocket.ts\n- **Directories:** /socket, /ws, /realtime\n\n## Core Capabilities\n\n### 1. WebSocket Server Setup\n\nImplement a production-ready WebSocket server.\n\n**Basic WebSocket Server with ws:**\n\n```typescript\n// src/lib/websocket/server.ts\nimport { WebSocketServer, WebSocket } from 'ws';\nimport { IncomingMessage } from 'http';\nimport { parse } from 'url';\n\ninterface ExtendedWebSocket extends WebSocket {\n  id: string;\n  userId?: string;\n  isAlive: boolean;\n  rooms: Set<string>;\n}\n\ninterface WebSocketMessage {\n  type: string;\n  payload?: unknown;\n  room?: string;\n}\n\nclass WebSocketManager {\n  private wss: WebSocketServer;\n  private clients: Map<string, ExtendedWebSocket> = new Map();\n  private rooms: Map<string, Set<string>> = new Map();\n  private userSockets: Map<string, Set<string>> = new Map();\n\n  constructor(server: any) {\n    this.wss = new WebSocketServer({ server, path: '/ws' });\n    this.setupConnectionHandler();\n    this.setupHeartbeat();\n  }\n\n  private setupConnectionHandler(): void {\n    this.wss.on('connection', async (ws: ExtendedWebSocket, req: IncomingMessage) => {\n      // Generate unique client ID\n      ws.id = crypto.randomUUID();\n      ws.isAlive = true;\n      ws.rooms = new Set();\n\n      // Authenticate from query params or headers\n      const { query } = parse(req.url || '', true);\n      const token = query.token as string || req.headers.authorization?.split(' ')[1];\n\n      if (token) {\n        try {\n          const user = await this.verifyToken(token);\n          ws.userId = user.id;\n          this.trackUserSocket(user.id, ws.id);\n        } catch (error) {\n          ws.close(4001, 'Authentication failed');\n          return;\n        }\n      }\n\n      this.clients.set(ws.id, ws);\n      console.log(`Client connected: ${ws.id}`);\n\n      // Handle incoming messages\n      ws.on('message', (data) => this.handleMessage(ws, data));\n\n      // Handle pong for heartbeat\n      ws.on('pong', () => { ws.isAlive = true; });\n\n      // Handle disconnection\n      ws.on('close', () => this.handleDisconnect(ws));\n\n      // Send welcome message\n      this.send(ws, { type: 'connected', payload: { clientId: ws.id } });\n    });\n  }\n\n  private setupHeartbeat(): void {\n    setInterval(() => {\n      this.wss.clients.forEach((ws) => {\n        const extWs = ws as ExtendedWebSocket;\n        if (!extWs.isAlive) {\n          extWs.terminate();\n          return;\n        }\n        extWs.isAlive = false;\n        extWs.ping();\n      });\n    }, 30000);\n  }\n\n  private async handleMessage(ws: ExtendedWebSocket, data: any): Promise<void> {\n    try {\n      const message: WebSocketMessage = JSON.parse(data.toString());\n\n      switch (message.type) {\n        case 'join':\n          this.joinRoom(ws, message.payload as string);\n          break;\n        case 'leave':\n          this.leaveRoom(ws, message.payload as string);\n          break;\n        case 'message':\n          if (message.room) {\n            this.broadcastToRoom(message.room, message, ws.id);\n          }\n          break;\n        case 'ping':\n          this.send(ws, { type: 'pong' });\n          break;\n        default:\n          this.emit('message', { ws, message });\n      }\n    } catch (error) {\n      this.send(ws, { type: 'error', payload: 'Invalid message format' });\n    }\n  }\n\n  private handleDisconnect(ws: ExtendedWebSocket): void {\n    // Leave all rooms\n    ws.rooms.forEach((room) => this.leaveRoom(ws, room));\n\n    // Remove from user tracking\n    if (ws.userId) {\n      const userSockets = this.userSockets.get(ws.userId);\n      if (userSockets) {\n        userSockets.delete(ws.id);\n        if (userSockets.size === 0) {\n          this.userSockets.delete(ws.userId);\n          this.emit('userOffline', ws.userId);\n        }\n      }\n    }\n\n    this.clients.delete(ws.id);\n    console.log(`Client disconnected: ${ws.id}`);\n  }\n\n  // Room management\n  joinRoom(ws: ExtendedWebSocket, room: string): void {\n    if (!this.rooms.has(room)) {\n      this.rooms.set(room, new Set());\n    }\n    this.rooms.get(room)!.add(ws.id);\n    ws.rooms.add(room);\n\n    this.send(ws, { type: 'joined', payload: room });\n    this.broadcastToRoom(room, {\n      type: 'user_joined',\n      payload: { clientId: ws.id, userId: ws.userId },\n    }, ws.id);\n  }\n\n  leaveRoom(ws: ExtendedWebSocket, room: string): void {\n    const roomClients = this.rooms.get(room);\n    if (roomClients) {\n      roomClients.delete(ws.id);\n      if (roomClients.size === 0) {\n        this.rooms.delete(room);\n      } else {\n        this.broadcastToRoom(room, {\n          type: 'user_left',\n          payload: { clientId: ws.id, userId: ws.userId },\n        });\n      }\n    }\n    ws.rooms.delete(room);\n  }\n\n  // Messaging\n  send(ws: ExtendedWebSocket, message: WebSocketMessage): void {\n    if (ws.readyState === WebSocket.OPEN) {\n      ws.send(JSON.stringify(message));\n    }\n  }\n\n  broadcast(message: WebSocketMessage, excludeId?: string): void {\n    this.clients.forEach((client) => {\n      if (client.id !== excludeId) {\n        this.send(client, message);\n      }\n    });\n  }\n\n  broadcastToRoom(room: string, message: WebSocketMessage, excludeId?: string): void {\n    const roomClients = this.rooms.get(room);\n    if (!roomClients) return;\n\n    roomClients.forEach((clientId) => {\n      if (clientId !== excludeId) {\n        const client = this.clients.get(clientId);\n        if (client) this.send(client, message);\n      }\n    });\n  }\n\n  sendToUser(userId: string, message: WebSocketMessage): void {\n    const userSockets = this.userSockets.get(userId);\n    if (!userSockets) return;\n\n    userSockets.forEach((socketId) => {\n      const client = this.clients.get(socketId);\n      if (client) this.send(client, message);\n    });\n  }\n\n  // Helpers\n  private trackUserSocket(userId: string, socketId: string): void {\n    if (!this.userSockets.has(userId)) {\n      this.userSockets.set(userId, new Set());\n      this.emit('userOnline', userId);\n    }\n    this.userSockets.get(userId)!.add(socketId);\n  }\n\n  private async verifyToken(token: string): Promise<{ id: string }> {\n    // Implement your auth verification\n    return { id: 'user-123' };\n  }\n\n  private emit(event: string, data: any): void {\n    // Event emitter for external handlers\n  }\n\n  // Stats\n  getStats() {\n    return {\n      totalClients: this.clients.size,\n      totalRooms: this.rooms.size,\n      onlineUsers: this.userSockets.size,\n    };\n  }\n}\n\nexport { WebSocketManager };\n```\n\n**Best Practices:**\n- Implement heartbeat/ping-pong for connection health\n- Use binary frames for large data transfers\n- Authenticate on connection, not per message\n- Set reasonable message size limits\n- Handle backpressure for slow clients\n\n**Gotchas:**\n- WebSocket connections count against server limits\n- Proxy/load balancer configuration required\n- Browser limits concurrent WebSocket connections\n- Memory leaks from uncleared event listeners\n\n### 2. Socket.io Implementation\n\nSocket.io provides fallbacks and advanced features.\n\n**Socket.io Server:**\n\n```typescript\n// src/lib/socket/server.ts\nimport { Server, Socket } from 'socket.io';\nimport { createAdapter } from '@socket.io/redis-adapter';\nimport { createClient } from 'redis';\n\ninterface ServerToClientEvents {\n  message: (data: { content: string; sender: string; timestamp: number }) => void;\n  userJoined: (data: { userId: string; username: string }) => void;\n  userLeft: (data: { userId: string }) => void;\n  typing: (data: { userId: string; isTyping: boolean }) => void;\n  presence: (data: { online: string[] }) => void;\n}\n\ninterface ClientToServerEvents {\n  joinRoom: (room: string, callback: (success: boolean) => void) => void;\n  leaveRoom: (room: string) => void;\n  sendMessage: (data: { room: string; content: string }) => void;\n  typing: (data: { room: string; isTyping: boolean }) => void;\n}\n\ninterface InterServerEvents {\n  ping: () => void;\n}\n\ninterface SocketData {\n  userId: string;\n  username: string;\n}\n\nexport async function createSocketServer(httpServer: any) {\n  const io = new Server<ClientToServerEvents, ServerToClientEvents, InterServerEvents, SocketData>(httpServer, {\n    cors: {\n      origin: process.env.FRONTEND_URL || 'http://localhost:3000',\n      methods: ['GET', 'POST'],\n      credentials: true,\n    },\n    transports: ['websocket', 'polling'],\n    pingInterval: 25000,\n    pingTimeout: 20000,\n  });\n\n  // Redis adapter for horizontal scaling\n  if (process.env.REDIS_URL) {\n    const pubClient = createClient({ url: process.env.REDIS_URL });\n    const subClient = pubClient.duplicate();\n    await Promise.all([pubClient.connect(), subClient.connect()]);\n    io.adapter(createAdapter(pubClient, subClient));\n  }\n\n  // Authentication middleware\n  io.use(async (socket, next) => {\n    const token = socket.handshake.auth.token || socket.handshake.headers.authorization?.split(' ')[1];\n\n    if (!token) {\n      return next(new Error('Authentication required'));\n    }\n\n    try {\n      const user = await verifyToken(token);\n      socket.data.userId = user.id;\n      socket.data.username = user.username;\n      next();\n    } catch (error) {\n      next(new Error('Invalid token'));\n    }\n  });\n\n  io.on('connection', (socket) => {\n    console.log(`User connected: ${socket.data.userId}`);\n\n    // Join user's personal room for direct messages\n    socket.join(`user:${socket.data.userId}`);\n\n    // Handle room joining\n    socket.on('joinRoom', async (room, callback) => {\n      // Validate room access\n      const canJoin = await checkRoomAccess(socket.data.userId, room);\n      if (!canJoin) {\n        callback(false);\n        return;\n      }\n\n      socket.join(room);\n      socket.to(room).emit('userJoined', {\n        userId: socket.data.userId,\n        username: socket.data.username,\n      });\n\n      // Send current online users\n      const sockets = await io.in(room).fetchSockets();\n      const online = sockets.map((s) => s.data.userId);\n      socket.emit('presence', { online });\n\n      callback(true);\n    });\n\n    // Handle room leaving\n    socket.on('leaveRoom', (room) => {\n      socket.leave(room);\n      socket.to(room).emit('userLeft', { userId: socket.data.userId });\n    });\n\n    // Handle messages\n    socket.on('sendMessage', async (data) => {\n      const message = {\n        content: data.content,\n        sender: socket.data.userId,\n        timestamp: Date.now(),\n      };\n\n      // Persist message\n      await saveMessage(data.room, message);\n\n      // Broadcast to room\n      io.to(data.room).emit('message', message);\n    });\n\n    // Handle typing indicator\n    socket.on('typing', (data) => {\n      socket.to(data.room).emit('typing', {\n        userId: socket.data.userId,\n        isTyping: data.isTyping,\n      });\n    });\n\n    // Handle disconnection\n    socket.on('disconnect', () => {\n      console.log(`User disconnected: ${socket.data.userId}`);\n    });\n  });\n\n  return io;\n}\n\nasync function verifyToken(token: string) {\n  // Implement your auth\n  return { id: 'user-123', username: 'john' };\n}\n\nasync function checkRoomAccess(userId: string, room: string) {\n  return true;\n}\n\nasync function saveMessage(room: string, message: any) {\n  // Save to database\n}\n```\n\n**Best Practices:**\n- Use Redis adapter for multi-server deployments\n- Implement proper error handling middleware\n- Use namespaces to separate concerns\n- Validate room access before joining\n- Persist important messages to database\n\n**Gotchas:**\n- Socket.io adds overhead compared to raw WebSockets\n- Polling fallback increases server load\n- Redis adapter requires proper pub/sub setup\n- Memory usage grows with connected users\n\n### 3. React WebSocket Hook\n\nCreate reusable hooks for WebSocket state.\n\n**WebSocket Hook:**\n\n```typescript\n// src/hooks/useWebSocket.ts\nimport { useEffect, useRef, useState, useCallback } from 'react';\n\ntype ConnectionStatus = 'connecting' | 'connected' | 'disconnected' | 'error';\n\ninterface UseWebSocketOptions {\n  url: string;\n  token?: string;\n  reconnect?: boolean;\n  reconnectInterval?: number;\n  maxReconnectAttempts?: number;\n  onOpen?: () => void;\n  onClose?: () => void;\n  onError?: (error: Event) => void;\n  onMessage?: (data: any) => void;\n}\n\nexport function useWebSocket(options: UseWebSocketOptions) {\n  const {\n    url,\n    token,\n    reconnect = true,\n    reconnectInterval = 3000,\n    maxReconnectAttempts = 5,\n    onOpen,\n    onClose,\n    onError,\n    onMessage,\n  } = options;\n\n  const [status, setStatus] = useState<ConnectionStatus>('disconnected');\n  const [lastMessage, setLastMessage] = useState<any>(null);\n  const wsRef = useRef<WebSocket | null>(null);\n  const reconnectAttemptsRef = useRef(0);\n  const reconnectTimeoutRef = useRef<NodeJS.Timeout>();\n\n  const connect = useCallback(() => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) return;\n\n    setStatus('connecting');\n\n    const wsUrl = token ? `${url}?token=${token}` : url;\n    const ws = new WebSocket(wsUrl);\n\n    ws.onopen = () => {\n      setStatus('connected');\n      reconnectAttemptsRef.current = 0;\n      onOpen?.();\n    };\n\n    ws.onclose = () => {\n      setStatus('disconnected');\n      onClose?.();\n\n      if (reconnect && reconnectAttemptsRef.current < maxReconnectAttempts) {\n        reconnectAttemptsRef.current++;\n        reconnectTimeoutRef.current = setTimeout(connect, reconnectInterval);\n      }\n    };\n\n    ws.onerror = (error) => {\n      setStatus('error');\n      onError?.(error);\n    };\n\n    ws.onmessage = (event) => {\n      try {\n        const data = JSON.parse(event.data);\n        setLastMessage(data);\n        onMessage?.(data);\n      } catch {\n        setLastMessage(event.data);\n        onMessage?.(event.data);\n      }\n    };\n\n    wsRef.current = ws;\n  }, [url, token, reconnect, reconnectInterval, maxReconnectAttempts, onOpen, onClose, onError, onMessage]);\n\n  const disconnect = useCallback(() => {\n    if (reconnectTimeoutRef.current) {\n      clearTimeout(reconnectTimeoutRef.current);\n    }\n    wsRef.current?.close();\n    wsRef.current = null;\n  }, []);\n\n  const send = useCallback((data: any) => {\n    if (wsRef.current?.readyState === WebSocket.OPEN) {\n      wsRef.current.send(typeof data === 'string' ? data : JSON.stringify(data));\n      return true;\n    }\n    return false;\n  }, []);\n\n  useEffect(() => {\n    connect();\n    return () => disconnect();\n  }, [connect, disconnect]);\n\n  return {\n    status,\n    lastMessage,\n    send,\n    connect,\n    disconnect,\n    isConnected: status === 'connected',\n  };\n}\n```\n\n**Socket.io Hook:**\n\n```typescript\n// src/hooks/useSocket.ts\nimport { useEffect, useRef, useState, useCallback } from 'react';\nimport { io, Socket } from 'socket.io-client';\n\ninterface UseSocketOptions {\n  url?: string;\n  token?: string;\n  autoConnect?: boolean;\n}\n\nexport function useSocket(options: UseSocketOptions = {}) {\n  const { url = '', token, autoConnect = true } = options;\n\n  const [isConnected, setIsConnected] = useState(false);\n  const socketRef = useRef<Socket | null>(null);\n\n  useEffect(() => {\n    const socket = io(url, {\n      auth: { token },\n      autoConnect,\n      transports: ['websocket', 'polling'],\n    });\n\n    socket.on('connect', () => setIsConnected(true));\n    socket.on('disconnect', () => setIsConnected(false));\n\n    socketRef.current = socket;\n\n    return () => {\n      socket.disconnect();\n    };\n  }, [url, token, autoConnect]);\n\n  const emit = useCallback(<T>(event: string, data?: T) => {\n    socketRef.current?.emit(event, data);\n  }, []);\n\n  const on = useCallback(<T>(event: string, callback: (data: T) => void) => {\n    socketRef.current?.on(event, callback);\n    return () => socketRef.current?.off(event, callback);\n  }, []);\n\n  const off = useCallback((event: string) => {\n    socketRef.current?.off(event);\n  }, []);\n\n  const joinRoom = useCallback((room: string) => {\n    return new Promise<boolean>((resolve) => {\n      socketRef.current?.emit('joinRoom', room, resolve);\n    });\n  }, []);\n\n  const leaveRoom = useCallback((room: string) => {\n    socketRef.current?.emit('leaveRoom', room);\n  }, []);\n\n  return {\n    socket: socketRef.current,\n    isConnected,\n    emit,\n    on,\n    off,\n    joinRoom,\n    leaveRoom,\n  };\n}\n```\n\n**Best Practices:**\n- Clean up connections on unmount\n- Implement exponential backoff for reconnection\n- Use refs to avoid stale closures\n- Memoize callbacks to prevent re-renders\n- Handle connection state in UI\n\n**Gotchas:**\n- React StrictMode causes double mount/unmount\n- State updates in callbacks may be stale\n- Multiple components can share one connection\n- Memory leaks from event listener cleanup\n\n### 4. Room and Presence Patterns\n\nImplement multi-user collaborative features.\n\n**Presence System:**\n\n```typescript\n// src/lib/socket/presence.ts\nimport { Redis } from 'ioredis';\n\nconst redis = new Redis(process.env.REDIS_URL!);\n\ninterface UserPresence {\n  oderId: string;\n  status: 'online' | 'away' | 'busy';\n  lastSeen: number;\n  metadata?: Record<string, any>;\n}\n\nclass PresenceManager {\n  private prefix = 'presence';\n  private ttl = 60; // seconds\n\n  async setOnline(userId: string, metadata?: Record<string, any>): Promise<void> {\n    const presence: UserPresence = {\n      oderId: oderId,\n      status: 'online',\n      lastSeen: Date.now(),\n      metadata,\n    };\n\n    await redis.setex(\n      `${this.prefix}:${userId}`,\n      this.ttl,\n      JSON.stringify(presence)\n    );\n  }\n\n  async setStatus(userId: string, status: UserPresence['status']): Promise<void> {\n    const key = `${this.prefix}:${userId}`;\n    const data = await redis.get(key);\n    if (data) {\n      const presence: UserPresence = JSON.parse(data);\n      presence.status = status;\n      presence.lastSeen = Date.now();\n      await redis.setex(key, this.ttl, JSON.stringify(presence));\n    }\n  }\n\n  async heartbeat(userId: string): Promise<void> {\n    const key = `${this.prefix}:${userId}`;\n    await redis.expire(key, this.ttl);\n  }\n\n  async setOffline(userId: string): Promise<void> {\n    await redis.del(`${this.prefix}:${userId}`);\n  }\n\n  async getPresence(userId: string): Promise<UserPresence | null> {\n    const data = await redis.get(`${this.prefix}:${userId}`);\n    return data ? JSON.parse(data) : null;\n  }\n\n  async getOnlineUsers(userIds: string[]): Promise<Map<string, UserPresence>> {\n    if (userIds.length === 0) return new Map();\n\n    const keys = userIds.map((id) => `${this.prefix}:${id}`);\n    const results = await redis.mget(keys);\n\n    const presenceMap = new Map<string, UserPresence>();\n    results.forEach((data, index) => {\n      if (data) {\n        presenceMap.set(userIds[index], JSON.parse(data));\n      }\n    });\n\n    return presenceMap;\n  }\n\n  async getAllOnlineUsers(): Promise<string[]> {\n    const keys = await redis.keys(`${this.prefix}:*`);\n    return keys.map((key) => key.replace(`${this.prefix}:`, ''));\n  }\n}\n\nexport const presence = new PresenceManager();\n```\n\n**Best Practices:**\n- Use heartbeats with TTL for presence\n- Batch presence queries for efficiency\n- Consider eventual consistency for presence\n- Implement away detection based on activity\n- Clean up presence on disconnect\n\n**Gotchas:**\n- Network issues can cause false offline status\n- High-frequency updates increase Redis load\n- Presence across multiple servers needs coordination\n- Browser tab switching affects activity detection\n\n## Real-World Examples\n\n### Example 1: Chat Application\n\n```typescript\n// src/components/chat.tsx\n'use client';\n\nimport { useState, useEffect, useRef } from 'react';\nimport { useSocket } from '@/hooks/useSocket';\n\ninterface Message {\n  id: string;\n  content: string;\n  sender: string;\n  timestamp: number;\n}\n\nexport function Chat({ roomId }: { roomId: string }) {\n  const [messages, setMessages] = useState<Message[]>([]);\n  const [input, setInput] = useState('');\n  const [typing, setTyping] = useState<string[]>([]);\n  const messagesEndRef = useRef<HTMLDivElement>(null);\n\n  const { isConnected, emit, on, joinRoom, leaveRoom } = useSocket({\n    token: 'user-token',\n  });\n\n  useEffect(() => {\n    if (!isConnected) return;\n\n    joinRoom(roomId);\n\n    const unsubMessage = on<Message>('message', (msg) => {\n      setMessages((prev) => [...prev, msg]);\n    });\n\n    const unsubTyping = on<{ oderId: string; isTyping: boolean }>('typing', (data) => {\n      setTyping((prev) =>\n        data.isTyping\n          ? [...prev.filter((id) => id !== data.userId), data.userId]\n          : prev.filter((id) => id !== data.userId)\n      );\n    });\n\n    return () => {\n      unsubMessage();\n      unsubTyping();\n      leaveRoom(roomId);\n    };\n  }, [isConnected, roomId]);\n\n  useEffect(() => {\n    messagesEndRef.current?.scrollIntoView({ behavior: 'smooth' });\n  }, [messages]);\n\n  const sendMessage = () => {\n    if (!input.trim()) return;\n    emit('sendMessage', { room: roomId, content: input });\n    setInput('');\n  };\n\n  const handleTyping = (isTyping: boolean) => {\n    emit('typing', { room: roomId, isTyping });\n  };\n\n  return (\n    <div className=\"flex flex-col h-full\">\n      <div className=\"flex-1 overflow-y-auto p-4 space-y-2\">\n        {messages.map((msg) => (\n          <div key={msg.id} className=\"p-2 bg-muted rounded\">\n            <span className=\"font-bold\">{msg.sender}: </span>\n            {msg.content}\n          </div>\n        ))}\n        <div ref={messagesEndRef} />\n      </div>\n\n      {typing.length > 0 && (\n        <div className=\"px-4 text-sm text-muted-foreground\">\n          {typing.join(', ')} {typing.length === 1 ? 'is' : 'are'} typing...\n        </div>\n      )}\n\n      <div className=\"p-4 border-t flex gap-2\">\n        <input\n          value={input}\n          onChange={(e) => setInput(e.target.value)}\n          onFocus={() => handleTyping(true)}\n          onBlur={() => handleTyping(false)}\n          onKeyDown={(e) => e.key === 'Enter' && sendMessage()}\n          placeholder=\"Type a message...\"\n          className=\"flex-1 px-3 py-2 border rounded\"\n        />\n        <button onClick={sendMessage} className=\"px-4 py-2 bg-primary text-white rounded\">\n          Send\n        </button>\n      </div>\n    </div>\n  );\n}\n```\n\n### Example 2: Live Dashboard Updates\n\n```typescript\n// src/components/live-dashboard.tsx\n'use client';\n\nimport { useEffect, useState } from 'react';\nimport { useWebSocket } from '@/hooks/useWebSocket';\n\ninterface DashboardData {\n  activeUsers: number;\n  revenue: number;\n  orders: number;\n  lastUpdated: string;\n}\n\nexport function LiveDashboard() {\n  const [data, setData] = useState<DashboardData | null>(null);\n\n  const { status, lastMessage } = useWebSocket({\n    url: `${process.env.NEXT_PUBLIC_WS_URL}/dashboard`,\n    token: 'dashboard-token',\n    onMessage: (msg) => {\n      if (msg.type === 'dashboard_update') {\n        setData(msg.payload);\n      }\n    },\n  });\n\n  return (\n    <div>\n      <div className=\"flex items-center gap-2 mb-4\">\n        <div className={`w-2 h-2 rounded-full ${status === 'connected' ? 'bg-green-500' : 'bg-red-500'}`} />\n        <span className=\"text-sm text-muted-foreground\">\n          {status === 'connected' ? 'Live' : 'Reconnecting...'}\n        </span>\n      </div>\n\n      {data && (\n        <div className=\"grid grid-cols-3 gap-4\">\n          <div className=\"p-4 border rounded\">\n            <div className=\"text-2xl font-bold\">{data.activeUsers}</div>\n            <div className=\"text-sm text-muted-foreground\">Active Users</div>\n          </div>\n          <div className=\"p-4 border rounded\">\n            <div className=\"text-2xl font-bold\">${data.revenue}</div>\n            <div className=\"text-sm text-muted-foreground\">Revenue</div>\n          </div>\n          <div className=\"p-4 border rounded\">\n            <div className=\"text-2xl font-bold\">{data.orders}</div>\n            <div className=\"text-sm text-muted-foreground\">Orders</div>\n          </div>\n        </div>\n      )}\n    </div>\n  );\n}\n```\n\n## Related Skills\n\n- **redis-expert** - Redis pub/sub for scaling\n- **react-advanced** - React patterns for real-time UIs\n- **nextjs-expert** - Next.js WebSocket integration\n- **authentication** - Securing WebSocket connections\n\n## Further Reading\n\n- [MDN WebSocket API](https://developer.mozilla.org/en-US/docs/Web/API/WebSocket)\n- [Socket.io Documentation](https://socket.io/docs/v4/)\n- [ws Library](https://github.com/websockets/ws)\n- [Redis Pub/Sub](https://redis.io/docs/manual/pubsub/)\n- [WebSocket Security](https://owasp.org/www-project-web-security-testing-guide/)\n\n---\n\n*This skill is part of OPUS 67 v5.1 - \"The Precision Update\"*\n"}
