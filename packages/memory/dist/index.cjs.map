{"version":3,"sources":["../src/storage.ts","../src/supabase-storage.ts","../src/index.ts","../src/memory.ts","../src/types.ts","../src/storage-factory.ts"],"sourcesContent":["/**\n * Memory Storage\n * File-based persistent storage for memory entries\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport type {\n  MemoryEntry,\n  MemoryNamespace,\n  MemoryQuery,\n  MemoryStats,\n  MemoryConfig,\n} from \"./types.js\";\nimport type { IMemoryStorage } from \"./storage-interface.js\";\n\nexport class MemoryStorage implements IMemoryStorage {\n  private basePath: string;\n  private entriesPath: string;\n  private namespacesPath: string;\n  private indexPath: string;\n\n  constructor(config: MemoryConfig) {\n    this.basePath = config.storagePath;\n    this.entriesPath = path.join(this.basePath, \"entries\");\n    this.namespacesPath = path.join(this.basePath, \"namespaces\");\n    this.indexPath = path.join(this.basePath, \"index.json\");\n\n    this.ensureDirectories();\n  }\n\n  /**\n   * Ensure storage directories exist\n   */\n  private ensureDirectories(): void {\n    [this.basePath, this.entriesPath, this.namespacesPath].forEach((dir) => {\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n    });\n  }\n\n  /**\n   * Store a memory entry\n   */\n  async store(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    const nsPath = path.join(this.entriesPath, namespace);\n    if (!fs.existsSync(nsPath)) {\n      fs.mkdirSync(nsPath, { recursive: true });\n    }\n\n    const filePath = path.join(nsPath, `${entry.id}.json`);\n    fs.writeFileSync(filePath, JSON.stringify(entry, null, 2));\n\n    // Update index\n    await this.updateIndex(entry, namespace, \"add\");\n  }\n\n  /**\n   * Retrieve a memory entry by ID\n   */\n  async get(id: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const filePath = path.join(this.entriesPath, namespace, `${id}.json`);\n    if (!fs.existsSync(filePath)) {\n      return null;\n    }\n\n    const content = fs.readFileSync(filePath, \"utf-8\");\n    return JSON.parse(content) as MemoryEntry;\n  }\n\n  /**\n   * Retrieve a memory entry by key\n   */\n  async getByKey(key: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const index = await this.loadIndex();\n    const entry = index.keyIndex[`${namespace}:${key}`];\n    if (!entry) {\n      return null;\n    }\n    return this.get(entry.id, namespace);\n  }\n\n  /**\n   * Update a memory entry\n   */\n  async update(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    await this.store(entry, namespace);\n  }\n\n  /**\n   * Delete a memory entry\n   */\n  async delete(id: string, namespace: string = \"default\"): Promise<boolean> {\n    const filePath = path.join(this.entriesPath, namespace, `${id}.json`);\n    if (!fs.existsSync(filePath)) {\n      return false;\n    }\n\n    const entry = await this.get(id, namespace);\n    fs.unlinkSync(filePath);\n\n    if (entry) {\n      await this.updateIndex(entry, namespace, \"remove\");\n    }\n\n    return true;\n  }\n\n  /**\n   * Query memory entries\n   */\n  async query(q: MemoryQuery): Promise<MemoryEntry[]> {\n    const namespace = q.namespace || \"default\";\n    const nsPath = path.join(this.entriesPath, namespace);\n\n    if (!fs.existsSync(nsPath)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(nsPath).filter((f) => f.endsWith(\".json\"));\n    let entries: MemoryEntry[] = [];\n\n    for (const file of files) {\n      const content = fs.readFileSync(path.join(nsPath, file), \"utf-8\");\n      const entry = JSON.parse(content) as MemoryEntry;\n\n      // Apply filters\n      if (q.key && entry.key !== q.key) continue;\n      if (q.keyPattern && !new RegExp(q.keyPattern).test(entry.key)) continue;\n      if (q.type && entry.type !== q.type) continue;\n      if (q.minConfidence && entry.confidence < q.minConfidence) continue;\n      if (q.tags && q.tags.length > 0) {\n        const hasAllTags = q.tags.every((tag) => entry.tags.includes(tag));\n        if (!hasAllTags) continue;\n      }\n\n      entries.push(entry);\n    }\n\n    // Sort\n    const sortBy = q.sortBy || \"createdAt\";\n    const sortOrder = q.sortOrder || \"desc\";\n    entries.sort((a, b) => {\n      const aVal = a[sortBy];\n      const bVal = b[sortBy];\n      if (sortOrder === \"asc\") {\n        return aVal < bVal ? -1 : 1;\n      }\n      return aVal > bVal ? -1 : 1;\n    });\n\n    // Pagination\n    const offset = q.offset || 0;\n    const limit = q.limit || 100;\n    return entries.slice(offset, offset + limit);\n  }\n\n  /**\n   * Get all namespaces\n   */\n  async getNamespaces(): Promise<MemoryNamespace[]> {\n    const nsFile = path.join(this.namespacesPath, \"namespaces.json\");\n    if (!fs.existsSync(nsFile)) {\n      return [\n        {\n          id: \"default\",\n          name: \"Default\",\n          description: \"Default memory namespace\",\n          createdAt: new Date().toISOString(),\n        },\n      ];\n    }\n    const content = fs.readFileSync(nsFile, \"utf-8\");\n    return JSON.parse(content) as MemoryNamespace[];\n  }\n\n  /**\n   * Create a namespace\n   */\n  async createNamespace(namespace: MemoryNamespace): Promise<void> {\n    const namespaces = await this.getNamespaces();\n    namespaces.push(namespace);\n\n    const nsFile = path.join(this.namespacesPath, \"namespaces.json\");\n    fs.writeFileSync(nsFile, JSON.stringify(namespaces, null, 2));\n  }\n\n  /**\n   * Get memory stats\n   */\n  async getStats(): Promise<MemoryStats> {\n    const index = await this.loadIndex();\n    const now = Date.now();\n    const oneDayFromNow = now + 24 * 60 * 60 * 1000;\n\n    let expiringSoon = 0;\n    for (const entry of Object.values(index.keyIndex)) {\n      if (entry.expiresAt) {\n        const expiresAt = new Date(entry.expiresAt).getTime();\n        if (expiresAt > now && expiresAt < oneDayFromNow) {\n          expiringSoon++;\n        }\n      }\n    }\n\n    // Calculate storage size\n    let storageSize = 0;\n    const calculateSize = (dir: string): void => {\n      if (!fs.existsSync(dir)) return;\n      const items = fs.readdirSync(dir);\n      for (const item of items) {\n        const fullPath = path.join(dir, item);\n        const stat = fs.statSync(fullPath);\n        if (stat.isDirectory()) {\n          calculateSize(fullPath);\n        } else {\n          storageSize += stat.size;\n        }\n      }\n    };\n    calculateSize(this.basePath);\n\n    return {\n      totalEntries: index.totalEntries,\n      byType: index.byType,\n      byNamespace: index.byNamespace,\n      storageSize,\n      oldestEntry: index.oldestEntry,\n      newestEntry: index.newestEntry,\n      expiringSoon,\n    };\n  }\n\n  /**\n   * Get expired entries\n   */\n  async getExpiredEntries(): Promise<MemoryEntry[]> {\n    const index = await this.loadIndex();\n    const now = new Date().toISOString();\n    const expired: MemoryEntry[] = [];\n\n    for (const [key, entry] of Object.entries(index.keyIndex)) {\n      if (entry.expiresAt && entry.expiresAt < now) {\n        const [namespace] = key.split(\":\");\n        const fullEntry = await this.get(entry.id, namespace);\n        if (fullEntry) {\n          expired.push(fullEntry);\n        }\n      }\n    }\n\n    return expired;\n  }\n\n  /**\n   * Load index from disk\n   */\n  private async loadIndex(): Promise<MemoryIndex> {\n    if (!fs.existsSync(this.indexPath)) {\n      return this.createEmptyIndex();\n    }\n\n    const content = fs.readFileSync(this.indexPath, \"utf-8\");\n    return JSON.parse(content) as MemoryIndex;\n  }\n\n  /**\n   * Save index to disk\n   */\n  private async saveIndex(index: MemoryIndex): Promise<void> {\n    fs.writeFileSync(this.indexPath, JSON.stringify(index, null, 2));\n  }\n\n  /**\n   * Create empty index\n   */\n  private createEmptyIndex(): MemoryIndex {\n    return {\n      totalEntries: 0,\n      keyIndex: {},\n      byType: {\n        fact: 0,\n        preference: 0,\n        context: 0,\n        decision: 0,\n        outcome: 0,\n      },\n      byNamespace: {},\n      oldestEntry: null,\n      newestEntry: null,\n    };\n  }\n\n  /**\n   * Update index\n   */\n  private async updateIndex(\n    entry: MemoryEntry,\n    namespace: string,\n    action: \"add\" | \"remove\"\n  ): Promise<void> {\n    const index = await this.loadIndex();\n    const key = `${namespace}:${entry.key}`;\n\n    if (action === \"add\") {\n      // Check if updating existing\n      const isNew = !index.keyIndex[key];\n\n      index.keyIndex[key] = {\n        id: entry.id,\n        type: entry.type,\n        expiresAt: entry.expiresAt,\n      };\n\n      if (isNew) {\n        index.totalEntries++;\n        index.byType[entry.type] = (index.byType[entry.type] || 0) + 1;\n        index.byNamespace[namespace] = (index.byNamespace[namespace] || 0) + 1;\n      }\n\n      // Update oldest/newest\n      if (!index.oldestEntry || entry.createdAt < index.oldestEntry) {\n        index.oldestEntry = entry.createdAt;\n      }\n      if (!index.newestEntry || entry.createdAt > index.newestEntry) {\n        index.newestEntry = entry.createdAt;\n      }\n    } else {\n      // Remove\n      const existing = index.keyIndex[key];\n      if (existing) {\n        delete index.keyIndex[key];\n        index.totalEntries--;\n        index.byType[entry.type] = Math.max(0, (index.byType[entry.type] || 0) - 1);\n        index.byNamespace[namespace] = Math.max(\n          0,\n          (index.byNamespace[namespace] || 0) - 1\n        );\n      }\n    }\n\n    await this.saveIndex(index);\n  }\n}\n\n// Index structure for fast lookups\ninterface MemoryIndex {\n  totalEntries: number;\n  keyIndex: Record<string, { id: string; type: MemoryEntry[\"type\"]; expiresAt?: string }>;\n  byType: Record<MemoryEntry[\"type\"], number>;\n  byNamespace: Record<string, number>;\n  oldestEntry: string | null;\n  newestEntry: string | null;\n}\n","/**\n * Supabase Memory Storage\n * Cloud-based persistent storage using Supabase\n */\n\nimport type {\n  MemoryEntry,\n  MemoryNamespace,\n  MemoryQuery,\n  MemoryStats,\n} from \"./types.js\";\nimport type { IMemoryStorage } from \"./storage-interface.js\";\n\ninterface SupabaseConfig {\n  url: string;\n  key: string;\n  tablePrefix?: string;\n}\n\ninterface SupabaseClient {\n  from: (table: string) => SupabaseQueryBuilder;\n}\n\ninterface SupabaseQueryBuilder {\n  select: (columns?: string) => SupabaseQueryBuilder;\n  insert: (data: unknown) => SupabaseQueryBuilder;\n  update: (data: unknown) => SupabaseQueryBuilder;\n  upsert: (data: unknown) => SupabaseQueryBuilder;\n  delete: () => SupabaseQueryBuilder;\n  eq: (column: string, value: unknown) => SupabaseQueryBuilder;\n  lt: (column: string, value: unknown) => SupabaseQueryBuilder;\n  gte: (column: string, value: unknown) => SupabaseQueryBuilder;\n  contains: (column: string, value: unknown) => SupabaseQueryBuilder;\n  ilike: (column: string, pattern: string) => SupabaseQueryBuilder;\n  order: (column: string, options?: { ascending?: boolean }) => SupabaseQueryBuilder;\n  range: (from: number, to: number) => SupabaseQueryBuilder;\n  single: () => SupabaseQueryBuilder;\n  maybeSingle: () => SupabaseQueryBuilder;\n  then: <T>(resolve: (result: { data: T | null; error: Error | null }) => void) => Promise<void>;\n}\n\n/**\n * Supabase-backed memory storage\n *\n * Required Supabase tables (run these SQL commands in Supabase):\n *\n * ```sql\n * -- Memory entries table\n * CREATE TABLE gicm_memory_entries (\n *   id TEXT PRIMARY KEY,\n *   key TEXT NOT NULL,\n *   value JSONB,\n *   type TEXT NOT NULL CHECK (type IN ('fact', 'preference', 'context', 'decision', 'outcome')),\n *   confidence REAL DEFAULT 1 CHECK (confidence >= 0 AND confidence <= 1),\n *   source TEXT,\n *   tags TEXT[] DEFAULT '{}',\n *   namespace TEXT DEFAULT 'default',\n *   expires_at TIMESTAMPTZ,\n *   created_at TIMESTAMPTZ DEFAULT NOW(),\n *   updated_at TIMESTAMPTZ DEFAULT NOW(),\n *   access_count INTEGER DEFAULT 0,\n *   last_accessed_at TIMESTAMPTZ,\n *   UNIQUE(namespace, key)\n * );\n *\n * -- Namespaces table\n * CREATE TABLE gicm_memory_namespaces (\n *   id TEXT PRIMARY KEY,\n *   name TEXT NOT NULL,\n *   description TEXT,\n *   parent_id TEXT,\n *   created_at TIMESTAMPTZ DEFAULT NOW()\n * );\n *\n * -- Indexes for fast queries\n * CREATE INDEX idx_entries_namespace ON gicm_memory_entries(namespace);\n * CREATE INDEX idx_entries_type ON gicm_memory_entries(type);\n * CREATE INDEX idx_entries_expires ON gicm_memory_entries(expires_at) WHERE expires_at IS NOT NULL;\n * CREATE INDEX idx_entries_tags ON gicm_memory_entries USING GIN(tags);\n *\n * -- Insert default namespace\n * INSERT INTO gicm_memory_namespaces (id, name, description)\n * VALUES ('default', 'Default', 'Default memory namespace');\n * ```\n */\nexport class SupabaseStorage implements IMemoryStorage {\n  private client: SupabaseClient | null = null;\n  private config: SupabaseConfig;\n  private entriesTable: string;\n  private namespacesTable: string;\n\n  constructor(config: SupabaseConfig) {\n    this.config = config;\n    const prefix = config.tablePrefix || \"gicm_memory\";\n    this.entriesTable = `${prefix}_entries`;\n    this.namespacesTable = `${prefix}_namespaces`;\n  }\n\n  /**\n   * Lazy initialize Supabase client\n   */\n  private async getClient(): Promise<SupabaseClient> {\n    if (this.client) return this.client;\n\n    try {\n      const { createClient } = await import(\"@supabase/supabase-js\");\n      this.client = createClient(this.config.url, this.config.key) as unknown as SupabaseClient;\n      return this.client;\n    } catch {\n      throw new Error(\n        \"Supabase client not available. Install @supabase/supabase-js: pnpm add @supabase/supabase-js\"\n      );\n    }\n  }\n\n  /**\n   * Convert DB row to MemoryEntry\n   */\n  private toMemoryEntry(row: Record<string, unknown>): MemoryEntry {\n    return {\n      id: row.id as string,\n      key: row.key as string,\n      value: row.value,\n      type: row.type as MemoryEntry[\"type\"],\n      confidence: row.confidence as number,\n      source: row.source as string | undefined,\n      tags: (row.tags as string[]) || [],\n      expiresAt: row.expires_at as string | undefined,\n      createdAt: row.created_at as string,\n      updatedAt: row.updated_at as string,\n      accessCount: row.access_count as number,\n      lastAccessedAt: row.last_accessed_at as string | undefined,\n    };\n  }\n\n  /**\n   * Convert MemoryEntry to DB row\n   */\n  private toDbRow(entry: MemoryEntry, namespace: string): Record<string, unknown> {\n    return {\n      id: entry.id,\n      key: entry.key,\n      value: entry.value,\n      type: entry.type,\n      confidence: entry.confidence,\n      source: entry.source,\n      tags: entry.tags,\n      namespace,\n      expires_at: entry.expiresAt,\n      created_at: entry.createdAt,\n      updated_at: entry.updatedAt,\n      access_count: entry.accessCount,\n      last_accessed_at: entry.lastAccessedAt,\n    };\n  }\n\n  async store(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    const client = await this.getClient();\n    const row = this.toDbRow(entry, namespace);\n\n    const { error } = await client\n      .from(this.entriesTable)\n      .upsert(row) as { data: unknown; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to store memory: ${error.message}`);\n    }\n  }\n\n  async get(id: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const client = await this.getClient();\n\n    const { data, error } = await client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .eq(\"id\", id)\n      .eq(\"namespace\", namespace)\n      .maybeSingle() as { data: Record<string, unknown> | null; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to get memory: ${error.message}`);\n    }\n\n    return data ? this.toMemoryEntry(data) : null;\n  }\n\n  async getByKey(key: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const client = await this.getClient();\n\n    const { data, error } = await client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .eq(\"key\", key)\n      .eq(\"namespace\", namespace)\n      .maybeSingle() as { data: Record<string, unknown> | null; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to get memory by key: ${error.message}`);\n    }\n\n    return data ? this.toMemoryEntry(data) : null;\n  }\n\n  async update(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    await this.store(entry, namespace);\n  }\n\n  async delete(id: string, namespace: string = \"default\"): Promise<boolean> {\n    const client = await this.getClient();\n\n    const { error } = await client\n      .from(this.entriesTable)\n      .delete()\n      .eq(\"id\", id)\n      .eq(\"namespace\", namespace) as { data: unknown; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to delete memory: ${error.message}`);\n    }\n\n    return true;\n  }\n\n  async query(q: MemoryQuery): Promise<MemoryEntry[]> {\n    const client = await this.getClient();\n    const namespace = q.namespace || \"default\";\n\n    let query = client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .eq(\"namespace\", namespace);\n\n    if (q.key) {\n      query = query.eq(\"key\", q.key);\n    }\n\n    if (q.keyPattern) {\n      query = query.ilike(\"key\", `%${q.keyPattern}%`);\n    }\n\n    if (q.type) {\n      query = query.eq(\"type\", q.type);\n    }\n\n    if (q.minConfidence) {\n      query = query.gte(\"confidence\", q.minConfidence);\n    }\n\n    if (q.tags && q.tags.length > 0) {\n      query = query.contains(\"tags\", q.tags);\n    }\n\n    // Sort\n    const sortBy = q.sortBy || \"created_at\";\n    const sortColumn = sortBy === \"createdAt\" ? \"created_at\" :\n                       sortBy === \"updatedAt\" ? \"updated_at\" :\n                       sortBy === \"accessCount\" ? \"access_count\" : sortBy;\n    query = query.order(sortColumn, { ascending: q.sortOrder === \"asc\" });\n\n    // Pagination\n    const offset = q.offset || 0;\n    const limit = q.limit || 100;\n    query = query.range(offset, offset + limit - 1);\n\n    const { data, error } = await query as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to query memories: ${error.message}`);\n    }\n\n    return (data || []).map((row) => this.toMemoryEntry(row));\n  }\n\n  async getNamespaces(): Promise<MemoryNamespace[]> {\n    const client = await this.getClient();\n\n    const { data, error } = await client\n      .from(this.namespacesTable)\n      .select(\"*\") as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    if (error) {\n      // Return default if table doesn't exist or other error\n      return [\n        {\n          id: \"default\",\n          name: \"Default\",\n          description: \"Default memory namespace\",\n          createdAt: new Date().toISOString(),\n        },\n      ];\n    }\n\n    return (data || []).map((row) => ({\n      id: row.id as string,\n      name: row.name as string,\n      description: row.description as string | undefined,\n      parentId: row.parent_id as string | undefined,\n      createdAt: row.created_at as string,\n    }));\n  }\n\n  async createNamespace(namespace: MemoryNamespace): Promise<void> {\n    const client = await this.getClient();\n\n    const { error } = await client\n      .from(this.namespacesTable)\n      .insert({\n        id: namespace.id,\n        name: namespace.name,\n        description: namespace.description,\n        parent_id: namespace.parentId,\n        created_at: namespace.createdAt,\n      }) as { data: unknown; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to create namespace: ${error.message}`);\n    }\n  }\n\n  async getStats(): Promise<MemoryStats> {\n    const client = await this.getClient();\n\n    // Get counts by type\n    const { data: typeData } = await client\n      .from(this.entriesTable)\n      .select(\"type\") as { data: { type: string }[] | null; error: Error | null };\n\n    const byType: Record<MemoryEntry[\"type\"], number> = {\n      fact: 0,\n      preference: 0,\n      context: 0,\n      decision: 0,\n      outcome: 0,\n    };\n\n    const byNamespace: Record<string, number> = {};\n    let totalEntries = 0;\n\n    // Get all entries for stats (could be optimized with SQL aggregation)\n    const { data: allData } = await client\n      .from(this.entriesTable)\n      .select(\"type, namespace, created_at\") as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    let oldestEntry: string | null = null;\n    let newestEntry: string | null = null;\n\n    for (const row of allData || []) {\n      totalEntries++;\n      const type = row.type as MemoryEntry[\"type\"];\n      const ns = row.namespace as string;\n      const createdAt = row.created_at as string;\n\n      byType[type] = (byType[type] || 0) + 1;\n      byNamespace[ns] = (byNamespace[ns] || 0) + 1;\n\n      if (!oldestEntry || createdAt < oldestEntry) oldestEntry = createdAt;\n      if (!newestEntry || createdAt > newestEntry) newestEntry = createdAt;\n    }\n\n    // Get expiring soon count\n    const now = new Date();\n    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);\n\n    const { data: expiringData } = await client\n      .from(this.entriesTable)\n      .select(\"id\")\n      .gte(\"expires_at\", now.toISOString())\n      .lt(\"expires_at\", tomorrow.toISOString()) as { data: { id: string }[] | null; error: Error | null };\n\n    return {\n      totalEntries,\n      byType,\n      byNamespace,\n      storageSize: 0, // Not applicable for cloud storage\n      oldestEntry,\n      newestEntry,\n      expiringSoon: expiringData?.length || 0,\n    };\n  }\n\n  async getExpiredEntries(): Promise<MemoryEntry[]> {\n    const client = await this.getClient();\n    const now = new Date().toISOString();\n\n    const { data, error } = await client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .lt(\"expires_at\", now) as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    if (error) {\n      return [];\n    }\n\n    return (data || []).map((row) => this.toMemoryEntry(row));\n  }\n}\n","/**\n * @gicm/memory\n * AI Memory - Persistent context storage across sessions\n */\n\n// Main Memory class\nexport { Memory } from \"./memory.js\";\n\n// Storage backends\nexport { MemoryStorage } from \"./storage.js\";\nexport { SupabaseStorage } from \"./supabase-storage.js\";\n\n// Storage interface and factory\nexport type { IMemoryStorage, StorageType, StorageOptions } from \"./storage-interface.js\";\nexport { createStorage, getStorageTypeFromEnv } from \"./storage-factory.js\";\n\n// Types\nexport type {\n  MemoryConfig,\n  MemoryEntry,\n  MemoryEvents,\n  MemoryQuery,\n  MemoryStats,\n  MemoryNamespace,\n  CreateMemoryInput,\n  UpdateMemoryInput,\n} from \"./types.js\";\nexport { DEFAULT_MEMORY_CONFIG, MemoryEntrySchema } from \"./types.js\";\n","/**\n * AI Memory\n * Main memory class providing persistent context storage across sessions\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport pino from \"pino\";\nimport { randomUUID } from \"crypto\";\nimport type {\n  MemoryConfig,\n  MemoryEntry,\n  MemoryEvents,\n  MemoryQuery,\n  MemoryStats,\n  CreateMemoryInput,\n  UpdateMemoryInput,\n  MemoryNamespace,\n} from \"./types.js\";\nimport { DEFAULT_MEMORY_CONFIG, MemoryEntrySchema } from \"./types.js\";\nimport { MemoryStorage } from \"./storage.js\";\n\nexport class Memory extends EventEmitter<MemoryEvents> {\n  private config: MemoryConfig;\n  private storage: MemoryStorage;\n  private logger: pino.Logger;\n  private cleanupTimer: NodeJS.Timeout | null = null;\n\n  constructor(config: Partial<MemoryConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_MEMORY_CONFIG, ...config };\n    this.storage = new MemoryStorage(this.config);\n    this.logger = pino({\n      level: \"info\",\n      transport: {\n        target: \"pino-pretty\",\n        options: { colorize: true },\n      },\n    });\n  }\n\n  /**\n   * Start the memory system (including cleanup timer)\n   */\n  start(): void {\n    this.startCleanupTimer();\n    this.logger.info(\"Memory system started\");\n  }\n\n  /**\n   * Stop the memory system\n   */\n  stop(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n    this.logger.info(\"Memory system stopped\");\n  }\n\n  /**\n   * Remember something\n   */\n  async remember(input: CreateMemoryInput): Promise<MemoryEntry> {\n    const now = new Date().toISOString();\n    const entry: MemoryEntry = {\n      id: randomUUID(),\n      key: input.key,\n      value: input.value,\n      type: input.type,\n      confidence: input.confidence ?? 1,\n      source: input.source,\n      tags: input.tags || [],\n      createdAt: now,\n      updatedAt: now,\n      accessCount: 0,\n    };\n\n    // Set expiration if provided\n    if (input.expiresIn) {\n      const expiresAt = new Date(Date.now() + input.expiresIn * 1000);\n      entry.expiresAt = expiresAt.toISOString();\n    } else if (this.config.defaultExpiration) {\n      const expiresAt = new Date(\n        Date.now() + this.config.defaultExpiration * 24 * 60 * 60 * 1000\n      );\n      entry.expiresAt = expiresAt.toISOString();\n    }\n\n    // Validate entry\n    MemoryEntrySchema.parse(entry);\n\n    // Store\n    const namespace = input.namespace || \"default\";\n    await this.storage.store(entry, namespace);\n\n    this.logger.info({ key: entry.key, type: entry.type }, \"Memory stored\");\n    this.emit(\"stored\", entry);\n\n    return entry;\n  }\n\n  /**\n   * Recall a memory by key\n   */\n  async recall(key: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const entry = await this.storage.getByKey(key, namespace);\n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (entry.expiresAt && new Date(entry.expiresAt) < new Date()) {\n      await this.forget(entry.id, namespace);\n      return null;\n    }\n\n    // Update access stats\n    entry.accessCount++;\n    entry.lastAccessedAt = new Date().toISOString();\n    await this.storage.update(entry, namespace);\n\n    this.emit(\"retrieved\", entry);\n    return entry;\n  }\n\n  /**\n   * Recall a memory by ID\n   */\n  async recallById(id: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const entry = await this.storage.get(id, namespace);\n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (entry.expiresAt && new Date(entry.expiresAt) < new Date()) {\n      await this.forget(id, namespace);\n      return null;\n    }\n\n    // Update access stats\n    entry.accessCount++;\n    entry.lastAccessedAt = new Date().toISOString();\n    await this.storage.update(entry, namespace);\n\n    this.emit(\"retrieved\", entry);\n    return entry;\n  }\n\n  /**\n   * Update a memory\n   */\n  async update(\n    key: string,\n    updates: UpdateMemoryInput,\n    namespace: string = \"default\"\n  ): Promise<MemoryEntry | null> {\n    const entry = await this.storage.getByKey(key, namespace);\n    if (!entry) {\n      return null;\n    }\n\n    // Apply updates\n    if (updates.value !== undefined) {\n      entry.value = updates.value;\n    }\n    if (updates.confidence !== undefined) {\n      entry.confidence = updates.confidence;\n    }\n    if (updates.tags !== undefined) {\n      entry.tags = updates.tags;\n    }\n    if (updates.expiresIn !== undefined) {\n      const expiresAt = new Date(Date.now() + updates.expiresIn * 1000);\n      entry.expiresAt = expiresAt.toISOString();\n    }\n\n    entry.updatedAt = new Date().toISOString();\n\n    await this.storage.update(entry, namespace);\n\n    this.logger.info({ key: entry.key }, \"Memory updated\");\n    this.emit(\"updated\", entry);\n\n    return entry;\n  }\n\n  /**\n   * Forget a memory\n   */\n  async forget(idOrKey: string, namespace: string = \"default\"): Promise<boolean> {\n    // Try by ID first\n    let deleted = await this.storage.delete(idOrKey, namespace);\n\n    // If not found, try by key\n    if (!deleted) {\n      const entry = await this.storage.getByKey(idOrKey, namespace);\n      if (entry) {\n        deleted = await this.storage.delete(entry.id, namespace);\n      }\n    }\n\n    if (deleted) {\n      this.logger.info({ id: idOrKey }, \"Memory forgotten\");\n      this.emit(\"deleted\", idOrKey);\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Search memories\n   */\n  async search(query: MemoryQuery): Promise<MemoryEntry[]> {\n    const entries = await this.storage.query(query);\n\n    // Filter out expired entries\n    const now = new Date();\n    return entries.filter((e) => {\n      if (e.expiresAt && new Date(e.expiresAt) < now) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Get all facts\n   */\n  async getFacts(namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ type: \"fact\", namespace });\n  }\n\n  /**\n   * Get all preferences\n   */\n  async getPreferences(namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ type: \"preference\", namespace });\n  }\n\n  /**\n   * Get memories by tags\n   */\n  async getByTags(tags: string[], namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ tags, namespace });\n  }\n\n  /**\n   * Get recent decisions\n   */\n  async getRecentDecisions(\n    limit: number = 10,\n    namespace: string = \"default\"\n  ): Promise<MemoryEntry[]> {\n    return this.search({\n      type: \"decision\",\n      namespace,\n      limit,\n      sortBy: \"createdAt\",\n      sortOrder: \"desc\",\n    });\n  }\n\n  /**\n   * Get memory stats\n   */\n  async getStats(): Promise<MemoryStats> {\n    return this.storage.getStats();\n  }\n\n  /**\n   * Create a namespace\n   */\n  async createNamespace(\n    name: string,\n    description?: string,\n    parentId?: string\n  ): Promise<MemoryNamespace> {\n    const namespace: MemoryNamespace = {\n      id: name.toLowerCase().replace(/\\s+/g, \"-\"),\n      name,\n      description,\n      parentId,\n      createdAt: new Date().toISOString(),\n    };\n\n    await this.storage.createNamespace(namespace);\n    return namespace;\n  }\n\n  /**\n   * Get all namespaces\n   */\n  async getNamespaces(): Promise<MemoryNamespace[]> {\n    return this.storage.getNamespaces();\n  }\n\n  /**\n   * Start cleanup timer for expired entries\n   */\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(async () => {\n      await this.cleanup();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  private async cleanup(): Promise<void> {\n    const expired = await this.storage.getExpiredEntries();\n    if (expired.length === 0) {\n      return;\n    }\n\n    this.logger.info({ count: expired.length }, \"Cleaning up expired memories\");\n\n    for (const entry of expired) {\n      await this.storage.delete(entry.id);\n    }\n\n    this.emit(\"expired\", expired);\n  }\n\n  /**\n   * Export all memories for a namespace\n   */\n  async export(namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ namespace, limit: this.config.maxEntries });\n  }\n\n  /**\n   * Import memories into a namespace\n   */\n  async import(entries: MemoryEntry[], namespace: string = \"default\"): Promise<number> {\n    let imported = 0;\n    for (const entry of entries) {\n      await this.storage.store(entry, namespace);\n      imported++;\n    }\n    this.logger.info({ count: imported, namespace }, \"Memories imported\");\n    return imported;\n  }\n}\n","/**\n * AI Memory Types\n * Type definitions for persistent context storage\n */\n\nimport { z } from \"zod\";\n\n// Memory entry schema\nexport const MemoryEntrySchema = z.object({\n  id: z.string(),\n  key: z.string(),\n  value: z.unknown(),\n  type: z.enum([\"fact\", \"preference\", \"context\", \"decision\", \"outcome\"]),\n  confidence: z.number().min(0).max(1).default(1),\n  source: z.string().optional(),\n  tags: z.array(z.string()).default([]),\n  expiresAt: z.string().datetime().optional(),\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n  accessCount: z.number().default(0),\n  lastAccessedAt: z.string().datetime().optional(),\n});\n\nexport type MemoryEntry = z.infer<typeof MemoryEntrySchema>;\n\n// Memory namespace for scoping\nexport const MemoryNamespaceSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string().optional(),\n  parentId: z.string().optional(),\n  createdAt: z.string().datetime(),\n});\n\nexport type MemoryNamespace = z.infer<typeof MemoryNamespaceSchema>;\n\n// Memory config\nexport const MemoryConfigSchema = z.object({\n  storagePath: z.string().default(\".gicm/memory\"),\n  maxEntries: z.number().default(10000),\n  defaultExpiration: z.number().optional(), // Days\n  cleanupInterval: z.number().default(3600000), // 1 hour in ms\n  enableCompression: z.boolean().default(false),\n  encryptionKey: z.string().optional(),\n});\n\nexport type MemoryConfig = z.infer<typeof MemoryConfigSchema>;\n\n// Memory query\nexport interface MemoryQuery {\n  key?: string;\n  keyPattern?: string;\n  type?: MemoryEntry[\"type\"];\n  tags?: string[];\n  minConfidence?: number;\n  namespace?: string;\n  limit?: number;\n  offset?: number;\n  sortBy?: \"createdAt\" | \"updatedAt\" | \"accessCount\" | \"confidence\";\n  sortOrder?: \"asc\" | \"desc\";\n}\n\n// Memory events\nexport interface MemoryEvents {\n  stored: (entry: MemoryEntry) => void;\n  retrieved: (entry: MemoryEntry) => void;\n  updated: (entry: MemoryEntry) => void;\n  deleted: (id: string) => void;\n  expired: (entries: MemoryEntry[]) => void;\n  error: (error: Error) => void;\n}\n\n// Memory stats\nexport interface MemoryStats {\n  totalEntries: number;\n  byType: Record<MemoryEntry[\"type\"], number>;\n  byNamespace: Record<string, number>;\n  storageSize: number;\n  oldestEntry: string | null;\n  newestEntry: string | null;\n  expiringSoon: number; // Entries expiring within 24 hours\n}\n\n// Input types for creating/updating memories\nexport interface CreateMemoryInput {\n  key: string;\n  value: unknown;\n  type: MemoryEntry[\"type\"];\n  confidence?: number;\n  source?: string;\n  tags?: string[];\n  expiresIn?: number; // Seconds\n  namespace?: string;\n}\n\nexport interface UpdateMemoryInput {\n  value?: unknown;\n  confidence?: number;\n  tags?: string[];\n  expiresIn?: number; // Seconds\n}\n\n// Default config values\nexport const DEFAULT_MEMORY_CONFIG: MemoryConfig = {\n  storagePath: \".gicm/memory\",\n  maxEntries: 10000,\n  cleanupInterval: 3600000,\n  enableCompression: false,\n};\n","/**\n * Storage Factory\n * Creates storage backend based on configuration\n */\n\nimport type { IMemoryStorage, StorageOptions, StorageType } from \"./storage-interface.js\";\nimport type { MemoryConfig } from \"./types.js\";\n\n/**\n * Create a storage backend based on options\n */\nexport async function createStorage(options: StorageOptions): Promise<IMemoryStorage> {\n  switch (options.type) {\n    case \"supabase\": {\n      if (!options.supabaseUrl || !options.supabaseKey) {\n        throw new Error(\"Supabase storage requires supabaseUrl and supabaseKey\");\n      }\n      const { SupabaseStorage } = await import(\"./supabase-storage.js\");\n      return new SupabaseStorage({\n        url: options.supabaseUrl,\n        key: options.supabaseKey,\n        tablePrefix: options.supabaseTablePrefix,\n      });\n    }\n\n    case \"file\":\n    default: {\n      const { MemoryStorage } = await import(\"./storage.js\");\n      const config: MemoryConfig = {\n        storagePath: options.storagePath || \".gicm/memory\",\n        maxEntries: 10000,\n        cleanupInterval: 3600000,\n        enableCompression: false,\n      };\n      return new MemoryStorage(config);\n    }\n  }\n}\n\n/**\n * Get storage type from environment\n */\nexport function getStorageTypeFromEnv(): StorageOptions {\n  const type = (process.env.GICM_MEMORY_STORAGE || \"file\") as StorageType;\n\n  if (type === \"supabase\") {\n    return {\n      type: \"supabase\",\n      supabaseUrl: process.env.SUPABASE_URL,\n      supabaseKey: process.env.SUPABASE_ANON_KEY || process.env.SUPABASE_SERVICE_KEY,\n      supabaseTablePrefix: process.env.GICM_MEMORY_TABLE_PREFIX || \"gicm_memory\",\n    };\n  }\n\n  return {\n    type: \"file\",\n    storagePath: process.env.GICM_MEMORY_PATH || \".gicm/memory\",\n  };\n}\n"],"mappings":"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","names":["pino","SupabaseStorage","MemoryStorage"]}