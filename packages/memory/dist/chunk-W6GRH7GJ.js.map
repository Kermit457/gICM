{"version":3,"sources":["../src/storage.ts"],"sourcesContent":["/**\n * Memory Storage\n * File-based persistent storage for memory entries\n */\n\nimport * as fs from \"fs\";\nimport * as path from \"path\";\nimport type {\n  MemoryEntry,\n  MemoryNamespace,\n  MemoryQuery,\n  MemoryStats,\n  MemoryConfig,\n} from \"./types.js\";\nimport type { IMemoryStorage } from \"./storage-interface.js\";\n\nexport class MemoryStorage implements IMemoryStorage {\n  private basePath: string;\n  private entriesPath: string;\n  private namespacesPath: string;\n  private indexPath: string;\n\n  constructor(config: MemoryConfig) {\n    this.basePath = config.storagePath;\n    this.entriesPath = path.join(this.basePath, \"entries\");\n    this.namespacesPath = path.join(this.basePath, \"namespaces\");\n    this.indexPath = path.join(this.basePath, \"index.json\");\n\n    this.ensureDirectories();\n  }\n\n  /**\n   * Ensure storage directories exist\n   */\n  private ensureDirectories(): void {\n    [this.basePath, this.entriesPath, this.namespacesPath].forEach((dir) => {\n      if (!fs.existsSync(dir)) {\n        fs.mkdirSync(dir, { recursive: true });\n      }\n    });\n  }\n\n  /**\n   * Store a memory entry\n   */\n  async store(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    const nsPath = path.join(this.entriesPath, namespace);\n    if (!fs.existsSync(nsPath)) {\n      fs.mkdirSync(nsPath, { recursive: true });\n    }\n\n    const filePath = path.join(nsPath, `${entry.id}.json`);\n    fs.writeFileSync(filePath, JSON.stringify(entry, null, 2));\n\n    // Update index\n    await this.updateIndex(entry, namespace, \"add\");\n  }\n\n  /**\n   * Retrieve a memory entry by ID\n   */\n  async get(id: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const filePath = path.join(this.entriesPath, namespace, `${id}.json`);\n    if (!fs.existsSync(filePath)) {\n      return null;\n    }\n\n    const content = fs.readFileSync(filePath, \"utf-8\");\n    return JSON.parse(content) as MemoryEntry;\n  }\n\n  /**\n   * Retrieve a memory entry by key\n   */\n  async getByKey(key: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const index = await this.loadIndex();\n    const entry = index.keyIndex[`${namespace}:${key}`];\n    if (!entry) {\n      return null;\n    }\n    return this.get(entry.id, namespace);\n  }\n\n  /**\n   * Update a memory entry\n   */\n  async update(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    await this.store(entry, namespace);\n  }\n\n  /**\n   * Delete a memory entry\n   */\n  async delete(id: string, namespace: string = \"default\"): Promise<boolean> {\n    const filePath = path.join(this.entriesPath, namespace, `${id}.json`);\n    if (!fs.existsSync(filePath)) {\n      return false;\n    }\n\n    const entry = await this.get(id, namespace);\n    fs.unlinkSync(filePath);\n\n    if (entry) {\n      await this.updateIndex(entry, namespace, \"remove\");\n    }\n\n    return true;\n  }\n\n  /**\n   * Query memory entries\n   */\n  async query(q: MemoryQuery): Promise<MemoryEntry[]> {\n    const namespace = q.namespace || \"default\";\n    const nsPath = path.join(this.entriesPath, namespace);\n\n    if (!fs.existsSync(nsPath)) {\n      return [];\n    }\n\n    const files = fs.readdirSync(nsPath).filter((f) => f.endsWith(\".json\"));\n    let entries: MemoryEntry[] = [];\n\n    for (const file of files) {\n      const content = fs.readFileSync(path.join(nsPath, file), \"utf-8\");\n      const entry = JSON.parse(content) as MemoryEntry;\n\n      // Apply filters\n      if (q.key && entry.key !== q.key) continue;\n      if (q.keyPattern && !new RegExp(q.keyPattern).test(entry.key)) continue;\n      if (q.type && entry.type !== q.type) continue;\n      if (q.minConfidence && entry.confidence < q.minConfidence) continue;\n      if (q.tags && q.tags.length > 0) {\n        const hasAllTags = q.tags.every((tag) => entry.tags.includes(tag));\n        if (!hasAllTags) continue;\n      }\n\n      entries.push(entry);\n    }\n\n    // Sort\n    const sortBy = q.sortBy || \"createdAt\";\n    const sortOrder = q.sortOrder || \"desc\";\n    entries.sort((a, b) => {\n      const aVal = a[sortBy];\n      const bVal = b[sortBy];\n      if (sortOrder === \"asc\") {\n        return aVal < bVal ? -1 : 1;\n      }\n      return aVal > bVal ? -1 : 1;\n    });\n\n    // Pagination\n    const offset = q.offset || 0;\n    const limit = q.limit || 100;\n    return entries.slice(offset, offset + limit);\n  }\n\n  /**\n   * Get all namespaces\n   */\n  async getNamespaces(): Promise<MemoryNamespace[]> {\n    const nsFile = path.join(this.namespacesPath, \"namespaces.json\");\n    if (!fs.existsSync(nsFile)) {\n      return [\n        {\n          id: \"default\",\n          name: \"Default\",\n          description: \"Default memory namespace\",\n          createdAt: new Date().toISOString(),\n        },\n      ];\n    }\n    const content = fs.readFileSync(nsFile, \"utf-8\");\n    return JSON.parse(content) as MemoryNamespace[];\n  }\n\n  /**\n   * Create a namespace\n   */\n  async createNamespace(namespace: MemoryNamespace): Promise<void> {\n    const namespaces = await this.getNamespaces();\n    namespaces.push(namespace);\n\n    const nsFile = path.join(this.namespacesPath, \"namespaces.json\");\n    fs.writeFileSync(nsFile, JSON.stringify(namespaces, null, 2));\n  }\n\n  /**\n   * Get memory stats\n   */\n  async getStats(): Promise<MemoryStats> {\n    const index = await this.loadIndex();\n    const now = Date.now();\n    const oneDayFromNow = now + 24 * 60 * 60 * 1000;\n\n    let expiringSoon = 0;\n    for (const entry of Object.values(index.keyIndex)) {\n      if (entry.expiresAt) {\n        const expiresAt = new Date(entry.expiresAt).getTime();\n        if (expiresAt > now && expiresAt < oneDayFromNow) {\n          expiringSoon++;\n        }\n      }\n    }\n\n    // Calculate storage size\n    let storageSize = 0;\n    const calculateSize = (dir: string): void => {\n      if (!fs.existsSync(dir)) return;\n      const items = fs.readdirSync(dir);\n      for (const item of items) {\n        const fullPath = path.join(dir, item);\n        const stat = fs.statSync(fullPath);\n        if (stat.isDirectory()) {\n          calculateSize(fullPath);\n        } else {\n          storageSize += stat.size;\n        }\n      }\n    };\n    calculateSize(this.basePath);\n\n    return {\n      totalEntries: index.totalEntries,\n      byType: index.byType,\n      byNamespace: index.byNamespace,\n      storageSize,\n      oldestEntry: index.oldestEntry,\n      newestEntry: index.newestEntry,\n      expiringSoon,\n    };\n  }\n\n  /**\n   * Get expired entries\n   */\n  async getExpiredEntries(): Promise<MemoryEntry[]> {\n    const index = await this.loadIndex();\n    const now = new Date().toISOString();\n    const expired: MemoryEntry[] = [];\n\n    for (const [key, entry] of Object.entries(index.keyIndex)) {\n      if (entry.expiresAt && entry.expiresAt < now) {\n        const [namespace] = key.split(\":\");\n        const fullEntry = await this.get(entry.id, namespace);\n        if (fullEntry) {\n          expired.push(fullEntry);\n        }\n      }\n    }\n\n    return expired;\n  }\n\n  /**\n   * Load index from disk\n   */\n  private async loadIndex(): Promise<MemoryIndex> {\n    if (!fs.existsSync(this.indexPath)) {\n      return this.createEmptyIndex();\n    }\n\n    const content = fs.readFileSync(this.indexPath, \"utf-8\");\n    return JSON.parse(content) as MemoryIndex;\n  }\n\n  /**\n   * Save index to disk\n   */\n  private async saveIndex(index: MemoryIndex): Promise<void> {\n    fs.writeFileSync(this.indexPath, JSON.stringify(index, null, 2));\n  }\n\n  /**\n   * Create empty index\n   */\n  private createEmptyIndex(): MemoryIndex {\n    return {\n      totalEntries: 0,\n      keyIndex: {},\n      byType: {\n        fact: 0,\n        preference: 0,\n        context: 0,\n        decision: 0,\n        outcome: 0,\n      },\n      byNamespace: {},\n      oldestEntry: null,\n      newestEntry: null,\n    };\n  }\n\n  /**\n   * Update index\n   */\n  private async updateIndex(\n    entry: MemoryEntry,\n    namespace: string,\n    action: \"add\" | \"remove\"\n  ): Promise<void> {\n    const index = await this.loadIndex();\n    const key = `${namespace}:${entry.key}`;\n\n    if (action === \"add\") {\n      // Check if updating existing\n      const isNew = !index.keyIndex[key];\n\n      index.keyIndex[key] = {\n        id: entry.id,\n        type: entry.type,\n        expiresAt: entry.expiresAt,\n      };\n\n      if (isNew) {\n        index.totalEntries++;\n        index.byType[entry.type] = (index.byType[entry.type] || 0) + 1;\n        index.byNamespace[namespace] = (index.byNamespace[namespace] || 0) + 1;\n      }\n\n      // Update oldest/newest\n      if (!index.oldestEntry || entry.createdAt < index.oldestEntry) {\n        index.oldestEntry = entry.createdAt;\n      }\n      if (!index.newestEntry || entry.createdAt > index.newestEntry) {\n        index.newestEntry = entry.createdAt;\n      }\n    } else {\n      // Remove\n      const existing = index.keyIndex[key];\n      if (existing) {\n        delete index.keyIndex[key];\n        index.totalEntries--;\n        index.byType[entry.type] = Math.max(0, (index.byType[entry.type] || 0) - 1);\n        index.byNamespace[namespace] = Math.max(\n          0,\n          (index.byNamespace[namespace] || 0) - 1\n        );\n      }\n    }\n\n    await this.saveIndex(index);\n  }\n}\n\n// Index structure for fast lookups\ninterface MemoryIndex {\n  totalEntries: number;\n  keyIndex: Record<string, { id: string; type: MemoryEntry[\"type\"]; expiresAt?: string }>;\n  byType: Record<MemoryEntry[\"type\"], number>;\n  byNamespace: Record<string, number>;\n  oldestEntry: string | null;\n  newestEntry: string | null;\n}\n"],"mappings":"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","names":[]}