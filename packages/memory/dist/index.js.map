{"version":3,"sources":["../src/memory.ts","../src/types.ts","../src/storage-factory.ts"],"sourcesContent":["/**\n * AI Memory\n * Main memory class providing persistent context storage across sessions\n */\n\nimport { EventEmitter } from \"eventemitter3\";\nimport pino from \"pino\";\nimport { randomUUID } from \"crypto\";\nimport type {\n  MemoryConfig,\n  MemoryEntry,\n  MemoryEvents,\n  MemoryQuery,\n  MemoryStats,\n  CreateMemoryInput,\n  UpdateMemoryInput,\n  MemoryNamespace,\n} from \"./types.js\";\nimport { DEFAULT_MEMORY_CONFIG, MemoryEntrySchema } from \"./types.js\";\nimport { MemoryStorage } from \"./storage.js\";\n\nexport class Memory extends EventEmitter<MemoryEvents> {\n  private config: MemoryConfig;\n  private storage: MemoryStorage;\n  private logger: pino.Logger;\n  private cleanupTimer: NodeJS.Timeout | null = null;\n\n  constructor(config: Partial<MemoryConfig> = {}) {\n    super();\n    this.config = { ...DEFAULT_MEMORY_CONFIG, ...config };\n    this.storage = new MemoryStorage(this.config);\n    this.logger = pino({\n      level: \"info\",\n      transport: {\n        target: \"pino-pretty\",\n        options: { colorize: true },\n      },\n    });\n  }\n\n  /**\n   * Start the memory system (including cleanup timer)\n   */\n  start(): void {\n    this.startCleanupTimer();\n    this.logger.info(\"Memory system started\");\n  }\n\n  /**\n   * Stop the memory system\n   */\n  stop(): void {\n    if (this.cleanupTimer) {\n      clearInterval(this.cleanupTimer);\n      this.cleanupTimer = null;\n    }\n    this.logger.info(\"Memory system stopped\");\n  }\n\n  /**\n   * Remember something\n   */\n  async remember(input: CreateMemoryInput): Promise<MemoryEntry> {\n    const now = new Date().toISOString();\n    const entry: MemoryEntry = {\n      id: randomUUID(),\n      key: input.key,\n      value: input.value,\n      type: input.type,\n      confidence: input.confidence ?? 1,\n      source: input.source,\n      tags: input.tags || [],\n      createdAt: now,\n      updatedAt: now,\n      accessCount: 0,\n    };\n\n    // Set expiration if provided\n    if (input.expiresIn) {\n      const expiresAt = new Date(Date.now() + input.expiresIn * 1000);\n      entry.expiresAt = expiresAt.toISOString();\n    } else if (this.config.defaultExpiration) {\n      const expiresAt = new Date(\n        Date.now() + this.config.defaultExpiration * 24 * 60 * 60 * 1000\n      );\n      entry.expiresAt = expiresAt.toISOString();\n    }\n\n    // Validate entry\n    MemoryEntrySchema.parse(entry);\n\n    // Store\n    const namespace = input.namespace || \"default\";\n    await this.storage.store(entry, namespace);\n\n    this.logger.info({ key: entry.key, type: entry.type }, \"Memory stored\");\n    this.emit(\"stored\", entry);\n\n    return entry;\n  }\n\n  /**\n   * Recall a memory by key\n   */\n  async recall(key: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const entry = await this.storage.getByKey(key, namespace);\n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (entry.expiresAt && new Date(entry.expiresAt) < new Date()) {\n      await this.forget(entry.id, namespace);\n      return null;\n    }\n\n    // Update access stats\n    entry.accessCount++;\n    entry.lastAccessedAt = new Date().toISOString();\n    await this.storage.update(entry, namespace);\n\n    this.emit(\"retrieved\", entry);\n    return entry;\n  }\n\n  /**\n   * Recall a memory by ID\n   */\n  async recallById(id: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const entry = await this.storage.get(id, namespace);\n    if (!entry) {\n      return null;\n    }\n\n    // Check if expired\n    if (entry.expiresAt && new Date(entry.expiresAt) < new Date()) {\n      await this.forget(id, namespace);\n      return null;\n    }\n\n    // Update access stats\n    entry.accessCount++;\n    entry.lastAccessedAt = new Date().toISOString();\n    await this.storage.update(entry, namespace);\n\n    this.emit(\"retrieved\", entry);\n    return entry;\n  }\n\n  /**\n   * Update a memory\n   */\n  async update(\n    key: string,\n    updates: UpdateMemoryInput,\n    namespace: string = \"default\"\n  ): Promise<MemoryEntry | null> {\n    const entry = await this.storage.getByKey(key, namespace);\n    if (!entry) {\n      return null;\n    }\n\n    // Apply updates\n    if (updates.value !== undefined) {\n      entry.value = updates.value;\n    }\n    if (updates.confidence !== undefined) {\n      entry.confidence = updates.confidence;\n    }\n    if (updates.tags !== undefined) {\n      entry.tags = updates.tags;\n    }\n    if (updates.expiresIn !== undefined) {\n      const expiresAt = new Date(Date.now() + updates.expiresIn * 1000);\n      entry.expiresAt = expiresAt.toISOString();\n    }\n\n    entry.updatedAt = new Date().toISOString();\n\n    await this.storage.update(entry, namespace);\n\n    this.logger.info({ key: entry.key }, \"Memory updated\");\n    this.emit(\"updated\", entry);\n\n    return entry;\n  }\n\n  /**\n   * Forget a memory\n   */\n  async forget(idOrKey: string, namespace: string = \"default\"): Promise<boolean> {\n    // Try by ID first\n    let deleted = await this.storage.delete(idOrKey, namespace);\n\n    // If not found, try by key\n    if (!deleted) {\n      const entry = await this.storage.getByKey(idOrKey, namespace);\n      if (entry) {\n        deleted = await this.storage.delete(entry.id, namespace);\n      }\n    }\n\n    if (deleted) {\n      this.logger.info({ id: idOrKey }, \"Memory forgotten\");\n      this.emit(\"deleted\", idOrKey);\n    }\n\n    return deleted;\n  }\n\n  /**\n   * Search memories\n   */\n  async search(query: MemoryQuery): Promise<MemoryEntry[]> {\n    const entries = await this.storage.query(query);\n\n    // Filter out expired entries\n    const now = new Date();\n    return entries.filter((e) => {\n      if (e.expiresAt && new Date(e.expiresAt) < now) {\n        return false;\n      }\n      return true;\n    });\n  }\n\n  /**\n   * Get all facts\n   */\n  async getFacts(namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ type: \"fact\", namespace });\n  }\n\n  /**\n   * Get all preferences\n   */\n  async getPreferences(namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ type: \"preference\", namespace });\n  }\n\n  /**\n   * Get memories by tags\n   */\n  async getByTags(tags: string[], namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ tags, namespace });\n  }\n\n  /**\n   * Get recent decisions\n   */\n  async getRecentDecisions(\n    limit: number = 10,\n    namespace: string = \"default\"\n  ): Promise<MemoryEntry[]> {\n    return this.search({\n      type: \"decision\",\n      namespace,\n      limit,\n      sortBy: \"createdAt\",\n      sortOrder: \"desc\",\n    });\n  }\n\n  /**\n   * Get memory stats\n   */\n  async getStats(): Promise<MemoryStats> {\n    return this.storage.getStats();\n  }\n\n  /**\n   * Create a namespace\n   */\n  async createNamespace(\n    name: string,\n    description?: string,\n    parentId?: string\n  ): Promise<MemoryNamespace> {\n    const namespace: MemoryNamespace = {\n      id: name.toLowerCase().replace(/\\s+/g, \"-\"),\n      name,\n      description,\n      parentId,\n      createdAt: new Date().toISOString(),\n    };\n\n    await this.storage.createNamespace(namespace);\n    return namespace;\n  }\n\n  /**\n   * Get all namespaces\n   */\n  async getNamespaces(): Promise<MemoryNamespace[]> {\n    return this.storage.getNamespaces();\n  }\n\n  /**\n   * Start cleanup timer for expired entries\n   */\n  private startCleanupTimer(): void {\n    this.cleanupTimer = setInterval(async () => {\n      await this.cleanup();\n    }, this.config.cleanupInterval);\n  }\n\n  /**\n   * Clean up expired entries\n   */\n  private async cleanup(): Promise<void> {\n    const expired = await this.storage.getExpiredEntries();\n    if (expired.length === 0) {\n      return;\n    }\n\n    this.logger.info({ count: expired.length }, \"Cleaning up expired memories\");\n\n    for (const entry of expired) {\n      await this.storage.delete(entry.id);\n    }\n\n    this.emit(\"expired\", expired);\n  }\n\n  /**\n   * Export all memories for a namespace\n   */\n  async export(namespace: string = \"default\"): Promise<MemoryEntry[]> {\n    return this.search({ namespace, limit: this.config.maxEntries });\n  }\n\n  /**\n   * Import memories into a namespace\n   */\n  async import(entries: MemoryEntry[], namespace: string = \"default\"): Promise<number> {\n    let imported = 0;\n    for (const entry of entries) {\n      await this.storage.store(entry, namespace);\n      imported++;\n    }\n    this.logger.info({ count: imported, namespace }, \"Memories imported\");\n    return imported;\n  }\n}\n","/**\n * AI Memory Types\n * Type definitions for persistent context storage\n */\n\nimport { z } from \"zod\";\n\n// Memory entry schema\nexport const MemoryEntrySchema = z.object({\n  id: z.string(),\n  key: z.string(),\n  value: z.unknown(),\n  type: z.enum([\"fact\", \"preference\", \"context\", \"decision\", \"outcome\"]),\n  confidence: z.number().min(0).max(1).default(1),\n  source: z.string().optional(),\n  tags: z.array(z.string()).default([]),\n  expiresAt: z.string().datetime().optional(),\n  createdAt: z.string().datetime(),\n  updatedAt: z.string().datetime(),\n  accessCount: z.number().default(0),\n  lastAccessedAt: z.string().datetime().optional(),\n});\n\nexport type MemoryEntry = z.infer<typeof MemoryEntrySchema>;\n\n// Memory namespace for scoping\nexport const MemoryNamespaceSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  description: z.string().optional(),\n  parentId: z.string().optional(),\n  createdAt: z.string().datetime(),\n});\n\nexport type MemoryNamespace = z.infer<typeof MemoryNamespaceSchema>;\n\n// Memory config\nexport const MemoryConfigSchema = z.object({\n  storagePath: z.string().default(\".gicm/memory\"),\n  maxEntries: z.number().default(10000),\n  defaultExpiration: z.number().optional(), // Days\n  cleanupInterval: z.number().default(3600000), // 1 hour in ms\n  enableCompression: z.boolean().default(false),\n  encryptionKey: z.string().optional(),\n});\n\nexport type MemoryConfig = z.infer<typeof MemoryConfigSchema>;\n\n// Memory query\nexport interface MemoryQuery {\n  key?: string;\n  keyPattern?: string;\n  type?: MemoryEntry[\"type\"];\n  tags?: string[];\n  minConfidence?: number;\n  namespace?: string;\n  limit?: number;\n  offset?: number;\n  sortBy?: \"createdAt\" | \"updatedAt\" | \"accessCount\" | \"confidence\";\n  sortOrder?: \"asc\" | \"desc\";\n}\n\n// Memory events\nexport interface MemoryEvents {\n  stored: (entry: MemoryEntry) => void;\n  retrieved: (entry: MemoryEntry) => void;\n  updated: (entry: MemoryEntry) => void;\n  deleted: (id: string) => void;\n  expired: (entries: MemoryEntry[]) => void;\n  error: (error: Error) => void;\n}\n\n// Memory stats\nexport interface MemoryStats {\n  totalEntries: number;\n  byType: Record<MemoryEntry[\"type\"], number>;\n  byNamespace: Record<string, number>;\n  storageSize: number;\n  oldestEntry: string | null;\n  newestEntry: string | null;\n  expiringSoon: number; // Entries expiring within 24 hours\n}\n\n// Input types for creating/updating memories\nexport interface CreateMemoryInput {\n  key: string;\n  value: unknown;\n  type: MemoryEntry[\"type\"];\n  confidence?: number;\n  source?: string;\n  tags?: string[];\n  expiresIn?: number; // Seconds\n  namespace?: string;\n}\n\nexport interface UpdateMemoryInput {\n  value?: unknown;\n  confidence?: number;\n  tags?: string[];\n  expiresIn?: number; // Seconds\n}\n\n// Default config values\nexport const DEFAULT_MEMORY_CONFIG: MemoryConfig = {\n  storagePath: \".gicm/memory\",\n  maxEntries: 10000,\n  cleanupInterval: 3600000,\n  enableCompression: false,\n};\n","/**\n * Storage Factory\n * Creates storage backend based on configuration\n */\n\nimport type { IMemoryStorage, StorageOptions, StorageType } from \"./storage-interface.js\";\nimport type { MemoryConfig } from \"./types.js\";\n\n/**\n * Create a storage backend based on options\n */\nexport async function createStorage(options: StorageOptions): Promise<IMemoryStorage> {\n  switch (options.type) {\n    case \"supabase\": {\n      if (!options.supabaseUrl || !options.supabaseKey) {\n        throw new Error(\"Supabase storage requires supabaseUrl and supabaseKey\");\n      }\n      const { SupabaseStorage } = await import(\"./supabase-storage.js\");\n      return new SupabaseStorage({\n        url: options.supabaseUrl,\n        key: options.supabaseKey,\n        tablePrefix: options.supabaseTablePrefix,\n      });\n    }\n\n    case \"file\":\n    default: {\n      const { MemoryStorage } = await import(\"./storage.js\");\n      const config: MemoryConfig = {\n        storagePath: options.storagePath || \".gicm/memory\",\n        maxEntries: 10000,\n        cleanupInterval: 3600000,\n        enableCompression: false,\n      };\n      return new MemoryStorage(config);\n    }\n  }\n}\n\n/**\n * Get storage type from environment\n */\nexport function getStorageTypeFromEnv(): StorageOptions {\n  const type = (process.env.GICM_MEMORY_STORAGE || \"file\") as StorageType;\n\n  if (type === \"supabase\") {\n    return {\n      type: \"supabase\",\n      supabaseUrl: process.env.SUPABASE_URL,\n      supabaseKey: process.env.SUPABASE_ANON_KEY || process.env.SUPABASE_SERVICE_KEY,\n      supabaseTablePrefix: process.env.GICM_MEMORY_TABLE_PREFIX || \"gicm_memory\",\n    };\n  }\n\n  return {\n    type: \"file\",\n    storagePath: process.env.GICM_MEMORY_PATH || \".gicm/memory\",\n  };\n}\n"],"mappings":"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","names":["SupabaseStorage","MemoryStorage"]}