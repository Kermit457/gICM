{"version":3,"sources":["../src/supabase-storage.ts"],"sourcesContent":["/**\n * Supabase Memory Storage\n * Cloud-based persistent storage using Supabase\n */\n\nimport type {\n  MemoryEntry,\n  MemoryNamespace,\n  MemoryQuery,\n  MemoryStats,\n} from \"./types.js\";\nimport type { IMemoryStorage } from \"./storage-interface.js\";\n\ninterface SupabaseConfig {\n  url: string;\n  key: string;\n  tablePrefix?: string;\n}\n\ninterface SupabaseClient {\n  from: (table: string) => SupabaseQueryBuilder;\n}\n\ninterface SupabaseQueryBuilder {\n  select: (columns?: string) => SupabaseQueryBuilder;\n  insert: (data: unknown) => SupabaseQueryBuilder;\n  update: (data: unknown) => SupabaseQueryBuilder;\n  upsert: (data: unknown) => SupabaseQueryBuilder;\n  delete: () => SupabaseQueryBuilder;\n  eq: (column: string, value: unknown) => SupabaseQueryBuilder;\n  lt: (column: string, value: unknown) => SupabaseQueryBuilder;\n  gte: (column: string, value: unknown) => SupabaseQueryBuilder;\n  contains: (column: string, value: unknown) => SupabaseQueryBuilder;\n  ilike: (column: string, pattern: string) => SupabaseQueryBuilder;\n  order: (column: string, options?: { ascending?: boolean }) => SupabaseQueryBuilder;\n  range: (from: number, to: number) => SupabaseQueryBuilder;\n  single: () => SupabaseQueryBuilder;\n  maybeSingle: () => SupabaseQueryBuilder;\n  then: <T>(resolve: (result: { data: T | null; error: Error | null }) => void) => Promise<void>;\n}\n\n/**\n * Supabase-backed memory storage\n *\n * Required Supabase tables (run these SQL commands in Supabase):\n *\n * ```sql\n * -- Memory entries table\n * CREATE TABLE gicm_memory_entries (\n *   id TEXT PRIMARY KEY,\n *   key TEXT NOT NULL,\n *   value JSONB,\n *   type TEXT NOT NULL CHECK (type IN ('fact', 'preference', 'context', 'decision', 'outcome')),\n *   confidence REAL DEFAULT 1 CHECK (confidence >= 0 AND confidence <= 1),\n *   source TEXT,\n *   tags TEXT[] DEFAULT '{}',\n *   namespace TEXT DEFAULT 'default',\n *   expires_at TIMESTAMPTZ,\n *   created_at TIMESTAMPTZ DEFAULT NOW(),\n *   updated_at TIMESTAMPTZ DEFAULT NOW(),\n *   access_count INTEGER DEFAULT 0,\n *   last_accessed_at TIMESTAMPTZ,\n *   UNIQUE(namespace, key)\n * );\n *\n * -- Namespaces table\n * CREATE TABLE gicm_memory_namespaces (\n *   id TEXT PRIMARY KEY,\n *   name TEXT NOT NULL,\n *   description TEXT,\n *   parent_id TEXT,\n *   created_at TIMESTAMPTZ DEFAULT NOW()\n * );\n *\n * -- Indexes for fast queries\n * CREATE INDEX idx_entries_namespace ON gicm_memory_entries(namespace);\n * CREATE INDEX idx_entries_type ON gicm_memory_entries(type);\n * CREATE INDEX idx_entries_expires ON gicm_memory_entries(expires_at) WHERE expires_at IS NOT NULL;\n * CREATE INDEX idx_entries_tags ON gicm_memory_entries USING GIN(tags);\n *\n * -- Insert default namespace\n * INSERT INTO gicm_memory_namespaces (id, name, description)\n * VALUES ('default', 'Default', 'Default memory namespace');\n * ```\n */\nexport class SupabaseStorage implements IMemoryStorage {\n  private client: SupabaseClient | null = null;\n  private config: SupabaseConfig;\n  private entriesTable: string;\n  private namespacesTable: string;\n\n  constructor(config: SupabaseConfig) {\n    this.config = config;\n    const prefix = config.tablePrefix || \"gicm_memory\";\n    this.entriesTable = `${prefix}_entries`;\n    this.namespacesTable = `${prefix}_namespaces`;\n  }\n\n  /**\n   * Lazy initialize Supabase client\n   */\n  private async getClient(): Promise<SupabaseClient> {\n    if (this.client) return this.client;\n\n    try {\n      const { createClient } = await import(\"@supabase/supabase-js\");\n      this.client = createClient(this.config.url, this.config.key) as unknown as SupabaseClient;\n      return this.client;\n    } catch {\n      throw new Error(\n        \"Supabase client not available. Install @supabase/supabase-js: pnpm add @supabase/supabase-js\"\n      );\n    }\n  }\n\n  /**\n   * Convert DB row to MemoryEntry\n   */\n  private toMemoryEntry(row: Record<string, unknown>): MemoryEntry {\n    return {\n      id: row.id as string,\n      key: row.key as string,\n      value: row.value,\n      type: row.type as MemoryEntry[\"type\"],\n      confidence: row.confidence as number,\n      source: row.source as string | undefined,\n      tags: (row.tags as string[]) || [],\n      expiresAt: row.expires_at as string | undefined,\n      createdAt: row.created_at as string,\n      updatedAt: row.updated_at as string,\n      accessCount: row.access_count as number,\n      lastAccessedAt: row.last_accessed_at as string | undefined,\n    };\n  }\n\n  /**\n   * Convert MemoryEntry to DB row\n   */\n  private toDbRow(entry: MemoryEntry, namespace: string): Record<string, unknown> {\n    return {\n      id: entry.id,\n      key: entry.key,\n      value: entry.value,\n      type: entry.type,\n      confidence: entry.confidence,\n      source: entry.source,\n      tags: entry.tags,\n      namespace,\n      expires_at: entry.expiresAt,\n      created_at: entry.createdAt,\n      updated_at: entry.updatedAt,\n      access_count: entry.accessCount,\n      last_accessed_at: entry.lastAccessedAt,\n    };\n  }\n\n  async store(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    const client = await this.getClient();\n    const row = this.toDbRow(entry, namespace);\n\n    const { error } = await client\n      .from(this.entriesTable)\n      .upsert(row) as { data: unknown; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to store memory: ${error.message}`);\n    }\n  }\n\n  async get(id: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const client = await this.getClient();\n\n    const { data, error } = await client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .eq(\"id\", id)\n      .eq(\"namespace\", namespace)\n      .maybeSingle() as { data: Record<string, unknown> | null; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to get memory: ${error.message}`);\n    }\n\n    return data ? this.toMemoryEntry(data) : null;\n  }\n\n  async getByKey(key: string, namespace: string = \"default\"): Promise<MemoryEntry | null> {\n    const client = await this.getClient();\n\n    const { data, error } = await client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .eq(\"key\", key)\n      .eq(\"namespace\", namespace)\n      .maybeSingle() as { data: Record<string, unknown> | null; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to get memory by key: ${error.message}`);\n    }\n\n    return data ? this.toMemoryEntry(data) : null;\n  }\n\n  async update(entry: MemoryEntry, namespace: string = \"default\"): Promise<void> {\n    await this.store(entry, namespace);\n  }\n\n  async delete(id: string, namespace: string = \"default\"): Promise<boolean> {\n    const client = await this.getClient();\n\n    const { error } = await client\n      .from(this.entriesTable)\n      .delete()\n      .eq(\"id\", id)\n      .eq(\"namespace\", namespace) as { data: unknown; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to delete memory: ${error.message}`);\n    }\n\n    return true;\n  }\n\n  async query(q: MemoryQuery): Promise<MemoryEntry[]> {\n    const client = await this.getClient();\n    const namespace = q.namespace || \"default\";\n\n    let query = client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .eq(\"namespace\", namespace);\n\n    if (q.key) {\n      query = query.eq(\"key\", q.key);\n    }\n\n    if (q.keyPattern) {\n      query = query.ilike(\"key\", `%${q.keyPattern}%`);\n    }\n\n    if (q.type) {\n      query = query.eq(\"type\", q.type);\n    }\n\n    if (q.minConfidence) {\n      query = query.gte(\"confidence\", q.minConfidence);\n    }\n\n    if (q.tags && q.tags.length > 0) {\n      query = query.contains(\"tags\", q.tags);\n    }\n\n    // Sort\n    const sortBy = q.sortBy || \"created_at\";\n    const sortColumn = sortBy === \"createdAt\" ? \"created_at\" :\n                       sortBy === \"updatedAt\" ? \"updated_at\" :\n                       sortBy === \"accessCount\" ? \"access_count\" : sortBy;\n    query = query.order(sortColumn, { ascending: q.sortOrder === \"asc\" });\n\n    // Pagination\n    const offset = q.offset || 0;\n    const limit = q.limit || 100;\n    query = query.range(offset, offset + limit - 1);\n\n    const { data, error } = await query as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to query memories: ${error.message}`);\n    }\n\n    return (data || []).map((row) => this.toMemoryEntry(row));\n  }\n\n  async getNamespaces(): Promise<MemoryNamespace[]> {\n    const client = await this.getClient();\n\n    const { data, error } = await client\n      .from(this.namespacesTable)\n      .select(\"*\") as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    if (error) {\n      // Return default if table doesn't exist or other error\n      return [\n        {\n          id: \"default\",\n          name: \"Default\",\n          description: \"Default memory namespace\",\n          createdAt: new Date().toISOString(),\n        },\n      ];\n    }\n\n    return (data || []).map((row) => ({\n      id: row.id as string,\n      name: row.name as string,\n      description: row.description as string | undefined,\n      parentId: row.parent_id as string | undefined,\n      createdAt: row.created_at as string,\n    }));\n  }\n\n  async createNamespace(namespace: MemoryNamespace): Promise<void> {\n    const client = await this.getClient();\n\n    const { error } = await client\n      .from(this.namespacesTable)\n      .insert({\n        id: namespace.id,\n        name: namespace.name,\n        description: namespace.description,\n        parent_id: namespace.parentId,\n        created_at: namespace.createdAt,\n      }) as { data: unknown; error: Error | null };\n\n    if (error) {\n      throw new Error(`Failed to create namespace: ${error.message}`);\n    }\n  }\n\n  async getStats(): Promise<MemoryStats> {\n    const client = await this.getClient();\n\n    // Get counts by type\n    const { data: typeData } = await client\n      .from(this.entriesTable)\n      .select(\"type\") as { data: { type: string }[] | null; error: Error | null };\n\n    const byType: Record<MemoryEntry[\"type\"], number> = {\n      fact: 0,\n      preference: 0,\n      context: 0,\n      decision: 0,\n      outcome: 0,\n    };\n\n    const byNamespace: Record<string, number> = {};\n    let totalEntries = 0;\n\n    // Get all entries for stats (could be optimized with SQL aggregation)\n    const { data: allData } = await client\n      .from(this.entriesTable)\n      .select(\"type, namespace, created_at\") as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    let oldestEntry: string | null = null;\n    let newestEntry: string | null = null;\n\n    for (const row of allData || []) {\n      totalEntries++;\n      const type = row.type as MemoryEntry[\"type\"];\n      const ns = row.namespace as string;\n      const createdAt = row.created_at as string;\n\n      byType[type] = (byType[type] || 0) + 1;\n      byNamespace[ns] = (byNamespace[ns] || 0) + 1;\n\n      if (!oldestEntry || createdAt < oldestEntry) oldestEntry = createdAt;\n      if (!newestEntry || createdAt > newestEntry) newestEntry = createdAt;\n    }\n\n    // Get expiring soon count\n    const now = new Date();\n    const tomorrow = new Date(now.getTime() + 24 * 60 * 60 * 1000);\n\n    const { data: expiringData } = await client\n      .from(this.entriesTable)\n      .select(\"id\")\n      .gte(\"expires_at\", now.toISOString())\n      .lt(\"expires_at\", tomorrow.toISOString()) as { data: { id: string }[] | null; error: Error | null };\n\n    return {\n      totalEntries,\n      byType,\n      byNamespace,\n      storageSize: 0, // Not applicable for cloud storage\n      oldestEntry,\n      newestEntry,\n      expiringSoon: expiringData?.length || 0,\n    };\n  }\n\n  async getExpiredEntries(): Promise<MemoryEntry[]> {\n    const client = await this.getClient();\n    const now = new Date().toISOString();\n\n    const { data, error } = await client\n      .from(this.entriesTable)\n      .select(\"*\")\n      .lt(\"expires_at\", now) as { data: Record<string, unknown>[] | null; error: Error | null };\n\n    if (error) {\n      return [];\n    }\n\n    return (data || []).map((row) => this.toMemoryEntry(row));\n  }\n}\n"],"mappings":"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","names":[]}