{"version":3,"sources":["../src/security/secrets.ts","../src/security/rate-limiter.ts","../src/security/auth.ts","../src/security/headers.ts"],"sourcesContent":["/**\n * Secrets Manager for gICM platform\n *\n * Secure handling of API keys, credentials, and sensitive configuration.\n * Supports multiple backends: environment variables, encrypted files, external stores.\n */\n\nimport { z } from \"zod\";\nimport { createHash, createCipheriv, createDecipheriv, randomBytes } from \"crypto\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport const SecretMetadataSchema = z.object({\n  name: z.string(),\n  createdAt: z.number(),\n  updatedAt: z.number(),\n  expiresAt: z.number().optional(),\n  rotationDue: z.number().optional(),\n  tags: z.array(z.string()).optional(),\n  version: z.number().default(1),\n});\n\nexport type SecretMetadata = z.infer<typeof SecretMetadataSchema>;\n\nexport interface SecretValue {\n  value: string;\n  metadata: SecretMetadata;\n}\n\nexport interface SecretBackend {\n  name: string;\n  get(key: string): Promise<string | null>;\n  set(key: string, value: string, metadata?: Partial<SecretMetadata>): Promise<void>;\n  delete(key: string): Promise<boolean>;\n  list(): Promise<string[]>;\n  exists(key: string): Promise<boolean>;\n}\n\nexport interface SecretsManagerConfig {\n  /** Primary backend for secrets */\n  backend?: SecretBackend;\n  /** Encryption key for in-memory caching (32 bytes hex) */\n  encryptionKey?: string;\n  /** Cache TTL in ms (default: 5 minutes) */\n  cacheTtl?: number;\n  /** Prefix for environment variable lookups */\n  envPrefix?: string;\n  /** Callback when secret is accessed */\n  onAccess?: (key: string) => void;\n  /** Callback when secret is missing */\n  onMissing?: (key: string) => void;\n}\n\n// ============================================================================\n// Environment Backend\n// ============================================================================\n\n/**\n * Backend that reads secrets from environment variables\n */\nexport class EnvSecretBackend implements SecretBackend {\n  name = \"env\";\n  private prefix: string;\n\n  constructor(prefix = \"\") {\n    this.prefix = prefix;\n  }\n\n  private getEnvKey(key: string): string {\n    const normalized = key.toUpperCase().replace(/[.-]/g, \"_\");\n    return this.prefix ? `${this.prefix}_${normalized}` : normalized;\n  }\n\n  async get(key: string): Promise<string | null> {\n    return process.env[this.getEnvKey(key)] ?? null;\n  }\n\n  async set(key: string, value: string): Promise<void> {\n    process.env[this.getEnvKey(key)] = value;\n  }\n\n  async delete(key: string): Promise<boolean> {\n    const envKey = this.getEnvKey(key);\n    if (process.env[envKey]) {\n      delete process.env[envKey];\n      return true;\n    }\n    return false;\n  }\n\n  async list(): Promise<string[]> {\n    const keys: string[] = [];\n    const prefixLen = this.prefix ? this.prefix.length + 1 : 0;\n\n    for (const key of Object.keys(process.env)) {\n      if (!this.prefix || key.startsWith(`${this.prefix}_`)) {\n        keys.push(key.slice(prefixLen).toLowerCase().replace(/_/g, \"-\"));\n      }\n    }\n    return keys;\n  }\n\n  async exists(key: string): Promise<boolean> {\n    return this.getEnvKey(key) in process.env;\n  }\n}\n\n// ============================================================================\n// Memory Backend (with encryption)\n// ============================================================================\n\n/**\n * In-memory backend with AES-256 encryption\n */\nexport class MemorySecretBackend implements SecretBackend {\n  name = \"memory\";\n  private secrets: Map<string, { encrypted: Buffer; iv: Buffer; metadata: SecretMetadata }> =\n    new Map();\n  private key: Buffer;\n\n  constructor(encryptionKey?: string) {\n    // Use provided key or generate one\n    this.key = encryptionKey\n      ? Buffer.from(encryptionKey, \"hex\")\n      : randomBytes(32);\n\n    if (this.key.length !== 32) {\n      throw new Error(\"Encryption key must be 32 bytes (64 hex characters)\");\n    }\n  }\n\n  private encrypt(value: string): { encrypted: Buffer; iv: Buffer } {\n    const iv = randomBytes(16);\n    const cipher = createCipheriv(\"aes-256-cbc\", this.key, iv);\n    const encrypted = Buffer.concat([\n      cipher.update(value, \"utf8\"),\n      cipher.final(),\n    ]);\n    return { encrypted, iv };\n  }\n\n  private decrypt(encrypted: Buffer, iv: Buffer): string {\n    const decipher = createDecipheriv(\"aes-256-cbc\", this.key, iv);\n    return Buffer.concat([\n      decipher.update(encrypted),\n      decipher.final(),\n    ]).toString(\"utf8\");\n  }\n\n  async get(key: string): Promise<string | null> {\n    const secret = this.secrets.get(key);\n    if (!secret) return null;\n\n    // Check expiration\n    if (secret.metadata.expiresAt && Date.now() > secret.metadata.expiresAt) {\n      this.secrets.delete(key);\n      return null;\n    }\n\n    return this.decrypt(secret.encrypted, secret.iv);\n  }\n\n  async set(\n    key: string,\n    value: string,\n    metadata?: Partial<SecretMetadata>\n  ): Promise<void> {\n    const existing = this.secrets.get(key);\n    const { encrypted, iv } = this.encrypt(value);\n\n    const now = Date.now();\n    const fullMetadata: SecretMetadata = {\n      name: key,\n      createdAt: existing?.metadata.createdAt ?? now,\n      updatedAt: now,\n      version: (existing?.metadata.version ?? 0) + 1,\n      ...metadata,\n    };\n\n    this.secrets.set(key, { encrypted, iv, metadata: fullMetadata });\n  }\n\n  async delete(key: string): Promise<boolean> {\n    return this.secrets.delete(key);\n  }\n\n  async list(): Promise<string[]> {\n    return Array.from(this.secrets.keys());\n  }\n\n  async exists(key: string): Promise<boolean> {\n    return this.secrets.has(key);\n  }\n\n  getMetadata(key: string): SecretMetadata | null {\n    return this.secrets.get(key)?.metadata ?? null;\n  }\n}\n\n// ============================================================================\n// Composite Backend (fallback chain)\n// ============================================================================\n\n/**\n * Backend that tries multiple backends in order\n */\nexport class CompositeSecretBackend implements SecretBackend {\n  name = \"composite\";\n  private backends: SecretBackend[];\n\n  constructor(backends: SecretBackend[]) {\n    this.backends = backends;\n  }\n\n  async get(key: string): Promise<string | null> {\n    for (const backend of this.backends) {\n      const value = await backend.get(key);\n      if (value !== null) {\n        return value;\n      }\n    }\n    return null;\n  }\n\n  async set(key: string, value: string, metadata?: Partial<SecretMetadata>): Promise<void> {\n    // Set in the first backend\n    if (this.backends.length > 0) {\n      await this.backends[0].set(key, value, metadata);\n    }\n  }\n\n  async delete(key: string): Promise<boolean> {\n    let deleted = false;\n    for (const backend of this.backends) {\n      if (await backend.delete(key)) {\n        deleted = true;\n      }\n    }\n    return deleted;\n  }\n\n  async list(): Promise<string[]> {\n    const keys = new Set<string>();\n    for (const backend of this.backends) {\n      for (const key of await backend.list()) {\n        keys.add(key);\n      }\n    }\n    return Array.from(keys);\n  }\n\n  async exists(key: string): Promise<boolean> {\n    for (const backend of this.backends) {\n      if (await backend.exists(key)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\n// ============================================================================\n// SecretsManager\n// ============================================================================\n\n/**\n * SecretsManager handles secure storage and retrieval of secrets\n *\n * @example\n * const secrets = new SecretsManager({\n *   envPrefix: 'GICM',\n * });\n *\n * // Get API key (tries env, then backend)\n * const apiKey = await secrets.get('OPENAI_API_KEY');\n *\n * // Require a secret (throws if missing)\n * const requiredKey = await secrets.require('DATABASE_URL');\n *\n * // Get with default\n * const optional = await secrets.getOrDefault('LOG_LEVEL', 'info');\n */\nexport class SecretsManager {\n  private backend: SecretBackend;\n  private envBackend: EnvSecretBackend;\n  private cache: Map<string, { value: string; expiresAt: number }> = new Map();\n  private readonly config: Required<Omit<SecretsManagerConfig, \"backend\" | \"onAccess\" | \"onMissing\">> & {\n    onAccess?: (key: string) => void;\n    onMissing?: (key: string) => void;\n  };\n\n  constructor(config?: SecretsManagerConfig) {\n    this.config = {\n      encryptionKey: config?.encryptionKey ?? randomBytes(32).toString(\"hex\"),\n      cacheTtl: config?.cacheTtl ?? 5 * 60 * 1000, // 5 minutes\n      envPrefix: config?.envPrefix ?? \"\",\n      onAccess: config?.onAccess,\n      onMissing: config?.onMissing,\n    };\n\n    this.envBackend = new EnvSecretBackend(this.config.envPrefix);\n    this.backend = config?.backend ?? new MemorySecretBackend(this.config.encryptionKey);\n  }\n\n  /**\n   * Get a secret by key\n   * Tries: cache -> environment -> backend\n   */\n  async get(key: string): Promise<string | null> {\n    this.config.onAccess?.(key);\n\n    // Check cache\n    const cached = this.cache.get(key);\n    if (cached && Date.now() < cached.expiresAt) {\n      return cached.value;\n    }\n\n    // Try environment first\n    const envValue = await this.envBackend.get(key);\n    if (envValue !== null) {\n      this.cacheValue(key, envValue);\n      return envValue;\n    }\n\n    // Try backend\n    const backendValue = await this.backend.get(key);\n    if (backendValue !== null) {\n      this.cacheValue(key, backendValue);\n      return backendValue;\n    }\n\n    this.config.onMissing?.(key);\n    return null;\n  }\n\n  /**\n   * Get a secret or throw if not found\n   */\n  async require(key: string): Promise<string> {\n    const value = await this.get(key);\n    if (value === null) {\n      throw new Error(`Required secret not found: ${key}`);\n    }\n    return value;\n  }\n\n  /**\n   * Get a secret or return a default value\n   */\n  async getOrDefault(key: string, defaultValue: string): Promise<string> {\n    const value = await this.get(key);\n    return value ?? defaultValue;\n  }\n\n  /**\n   * Get multiple secrets at once\n   */\n  async getMany(keys: string[]): Promise<Map<string, string | null>> {\n    const results = new Map<string, string | null>();\n    await Promise.all(\n      keys.map(async (key) => {\n        results.set(key, await this.get(key));\n      })\n    );\n    return results;\n  }\n\n  /**\n   * Set a secret\n   */\n  async set(key: string, value: string, metadata?: Partial<SecretMetadata>): Promise<void> {\n    await this.backend.set(key, value, metadata);\n    this.cacheValue(key, value);\n  }\n\n  /**\n   * Delete a secret\n   */\n  async delete(key: string): Promise<boolean> {\n    this.cache.delete(key);\n    return this.backend.delete(key);\n  }\n\n  /**\n   * Check if a secret exists\n   */\n  async exists(key: string): Promise<boolean> {\n    return (await this.envBackend.exists(key)) || (await this.backend.exists(key));\n  }\n\n  /**\n   * List all secret keys\n   */\n  async list(): Promise<string[]> {\n    const envKeys = await this.envBackend.list();\n    const backendKeys = await this.backend.list();\n    return [...new Set([...envKeys, ...backendKeys])];\n  }\n\n  /**\n   * Clear the cache\n   */\n  clearCache(): void {\n    this.cache.clear();\n  }\n\n  /**\n   * Invalidate a specific cached value\n   */\n  invalidate(key: string): void {\n    this.cache.delete(key);\n  }\n\n  /**\n   * Get masked version of a secret (for logging)\n   */\n  async getMasked(key: string, visibleChars = 4): Promise<string | null> {\n    const value = await this.get(key);\n    if (!value) return null;\n\n    if (value.length <= visibleChars * 2) {\n      return \"*\".repeat(value.length);\n    }\n\n    const start = value.slice(0, visibleChars);\n    const end = value.slice(-visibleChars);\n    const middle = \"*\".repeat(Math.min(value.length - visibleChars * 2, 8));\n    return `${start}${middle}${end}`;\n  }\n\n  /**\n   * Hash a secret (for comparison without exposing)\n   */\n  async getHash(key: string): Promise<string | null> {\n    const value = await this.get(key);\n    if (!value) return null;\n    return createHash(\"sha256\").update(value).digest(\"hex\");\n  }\n\n  /**\n   * Validate that required secrets are present\n   */\n  async validate(requiredKeys: string[]): Promise<{\n    valid: boolean;\n    missing: string[];\n  }> {\n    const missing: string[] = [];\n\n    for (const key of requiredKeys) {\n      if (!(await this.exists(key))) {\n        missing.push(key);\n      }\n    }\n\n    return {\n      valid: missing.length === 0,\n      missing,\n    };\n  }\n\n  private cacheValue(key: string, value: string): void {\n    this.cache.set(key, {\n      value,\n      expiresAt: Date.now() + this.config.cacheTtl,\n    });\n  }\n}\n\n// ============================================================================\n// Utility functions\n// ============================================================================\n\n/**\n * Generate a secure random key\n */\nexport function generateSecretKey(bytes = 32): string {\n  return randomBytes(bytes).toString(\"hex\");\n}\n\n/**\n * Generate a secure API key with prefix\n */\nexport function generateApiKey(prefix = \"gicm\"): string {\n  const random = randomBytes(24).toString(\"base64url\");\n  return `${prefix}_${random}`;\n}\n\n/**\n * Validate API key format\n */\nexport function isValidApiKey(key: string, prefix = \"gicm\"): boolean {\n  const pattern = new RegExp(`^${prefix}_[A-Za-z0-9_-]{32}$`);\n  return pattern.test(key);\n}\n\n/**\n * Redact sensitive values from an object (for logging)\n */\nexport function redactSecrets<T extends Record<string, unknown>>(\n  obj: T,\n  sensitiveKeys: string[] = [\n    \"password\",\n    \"secret\",\n    \"key\",\n    \"token\",\n    \"api_key\",\n    \"apiKey\",\n    \"private\",\n    \"credential\",\n  ]\n): T {\n  const result = { ...obj };\n\n  for (const key of Object.keys(result)) {\n    const lowerKey = key.toLowerCase();\n    if (sensitiveKeys.some((sensitive) => lowerKey.includes(sensitive.toLowerCase()))) {\n      (result as Record<string, unknown>)[key] = \"[REDACTED]\";\n    } else if (typeof result[key] === \"object\" && result[key] !== null) {\n      (result as Record<string, unknown>)[key] = redactSecrets(\n        result[key] as Record<string, unknown>,\n        sensitiveKeys\n      );\n    }\n  }\n\n  return result;\n}\n\n/**\n * Create a secrets manager with common presets\n */\nexport function createSecretsManager(\n  preset: \"development\" | \"production\" | \"test\" = \"development\"\n): SecretsManager {\n  switch (preset) {\n    case \"production\":\n      return new SecretsManager({\n        envPrefix: \"GICM\",\n        cacheTtl: 60 * 1000, // 1 minute (shorter for rotation)\n        onMissing: (key) => {\n          console.warn(`[SECRETS] Missing required secret: ${key}`);\n        },\n      });\n\n    case \"test\":\n      return new SecretsManager({\n        backend: new MemorySecretBackend(),\n        cacheTtl: 0, // No caching in tests\n      });\n\n    case \"development\":\n    default:\n      return new SecretsManager({\n        envPrefix: \"GICM\",\n        cacheTtl: 5 * 60 * 1000, // 5 minutes\n      });\n  }\n}\n","/**\n * Rate Limiter for gICM platform\n *\n * Multiple algorithms:\n * - Token bucket (smooth rate limiting)\n * - Sliding window (accurate rate limiting)\n * - Fixed window (simple rate limiting)\n *\n * Features:\n * - Per-key rate limiting\n * - Configurable limits\n * - Burst allowance\n * - Statistics tracking\n */\n\nimport { z } from \"zod\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport const RateLimitConfigSchema = z.object({\n  /** Maximum requests per window */\n  maxRequests: z.number().min(1),\n  /** Window duration in milliseconds */\n  windowMs: z.number().min(1),\n  /** Algorithm to use */\n  algorithm: z.enum([\"token-bucket\", \"sliding-window\", \"fixed-window\"]).default(\"sliding-window\"),\n  /** Burst allowance (for token bucket) */\n  burstSize: z.number().optional(),\n  /** Key prefix for storage */\n  keyPrefix: z.string().default(\"ratelimit\"),\n});\n\nexport type RateLimitConfig = z.infer<typeof RateLimitConfigSchema>;\n\nexport interface RateLimitResult {\n  allowed: boolean;\n  remaining: number;\n  resetAt: number;\n  retryAfter?: number;\n}\n\nexport interface RateLimitStats {\n  totalRequests: number;\n  allowedRequests: number;\n  blockedRequests: number;\n  uniqueKeys: number;\n}\n\n// ============================================================================\n// RateLimitError\n// ============================================================================\n\nexport class RateLimitError extends Error {\n  constructor(\n    message: string,\n    public readonly retryAfter: number,\n    public readonly key?: string\n  ) {\n    super(message);\n    this.name = \"RateLimitError\";\n  }\n}\n\n// ============================================================================\n// Token Bucket Algorithm\n// ============================================================================\n\ninterface TokenBucket {\n  tokens: number;\n  lastRefill: number;\n}\n\nexport class TokenBucketLimiter {\n  private buckets: Map<string, TokenBucket> = new Map();\n  private readonly maxTokens: number;\n  private readonly refillRate: number; // tokens per ms\n  private readonly burstSize: number;\n\n  constructor(config: RateLimitConfig) {\n    this.maxTokens = config.maxRequests;\n    this.refillRate = config.maxRequests / config.windowMs;\n    this.burstSize = config.burstSize ?? config.maxRequests;\n  }\n\n  check(key: string, tokens = 1): RateLimitResult {\n    const now = Date.now();\n    let bucket = this.buckets.get(key);\n\n    if (!bucket) {\n      bucket = { tokens: this.burstSize, lastRefill: now };\n      this.buckets.set(key, bucket);\n    }\n\n    // Refill tokens based on time elapsed\n    const elapsed = now - bucket.lastRefill;\n    const refillAmount = elapsed * this.refillRate;\n    bucket.tokens = Math.min(this.burstSize, bucket.tokens + refillAmount);\n    bucket.lastRefill = now;\n\n    if (bucket.tokens >= tokens) {\n      bucket.tokens -= tokens;\n      return {\n        allowed: true,\n        remaining: Math.floor(bucket.tokens),\n        resetAt: now + Math.ceil((this.burstSize - bucket.tokens) / this.refillRate),\n      };\n    }\n\n    const retryAfter = Math.ceil((tokens - bucket.tokens) / this.refillRate);\n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: now + retryAfter,\n      retryAfter,\n    };\n  }\n\n  reset(key: string): void {\n    this.buckets.delete(key);\n  }\n\n  clear(): void {\n    this.buckets.clear();\n  }\n}\n\n// ============================================================================\n// Sliding Window Algorithm\n// ============================================================================\n\ninterface WindowEntry {\n  timestamp: number;\n  count: number;\n}\n\nexport class SlidingWindowLimiter {\n  private windows: Map<string, WindowEntry[]> = new Map();\n  private readonly maxRequests: number;\n  private readonly windowMs: number;\n\n  constructor(config: RateLimitConfig) {\n    this.maxRequests = config.maxRequests;\n    this.windowMs = config.windowMs;\n  }\n\n  check(key: string, weight = 1): RateLimitResult {\n    const now = Date.now();\n    const windowStart = now - this.windowMs;\n\n    // Get or create window entries\n    let entries = this.windows.get(key) ?? [];\n\n    // Remove expired entries\n    entries = entries.filter((e) => e.timestamp > windowStart);\n\n    // Count requests in current window\n    const currentCount = entries.reduce((sum, e) => sum + e.count, 0);\n\n    if (currentCount + weight <= this.maxRequests) {\n      entries.push({ timestamp: now, count: weight });\n      this.windows.set(key, entries);\n\n      return {\n        allowed: true,\n        remaining: this.maxRequests - currentCount - weight,\n        resetAt: entries.length > 0 ? entries[0].timestamp + this.windowMs : now + this.windowMs,\n      };\n    }\n\n    // Find when oldest entry will expire\n    const oldestEntry = entries[0];\n    const retryAfter = oldestEntry\n      ? oldestEntry.timestamp + this.windowMs - now\n      : this.windowMs;\n\n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: now + retryAfter,\n      retryAfter,\n    };\n  }\n\n  reset(key: string): void {\n    this.windows.delete(key);\n  }\n\n  clear(): void {\n    this.windows.clear();\n  }\n\n  // Cleanup old entries periodically\n  cleanup(): void {\n    const now = Date.now();\n    const windowStart = now - this.windowMs;\n\n    for (const [key, entries] of this.windows) {\n      const filtered = entries.filter((e) => e.timestamp > windowStart);\n      if (filtered.length === 0) {\n        this.windows.delete(key);\n      } else {\n        this.windows.set(key, filtered);\n      }\n    }\n  }\n}\n\n// ============================================================================\n// Fixed Window Algorithm\n// ============================================================================\n\ninterface FixedWindow {\n  count: number;\n  windowStart: number;\n}\n\nexport class FixedWindowLimiter {\n  private windows: Map<string, FixedWindow> = new Map();\n  private readonly maxRequests: number;\n  private readonly windowMs: number;\n\n  constructor(config: RateLimitConfig) {\n    this.maxRequests = config.maxRequests;\n    this.windowMs = config.windowMs;\n  }\n\n  check(key: string, weight = 1): RateLimitResult {\n    const now = Date.now();\n    const currentWindowStart = Math.floor(now / this.windowMs) * this.windowMs;\n    const windowEnd = currentWindowStart + this.windowMs;\n\n    let window = this.windows.get(key);\n\n    // Reset if in new window\n    if (!window || window.windowStart !== currentWindowStart) {\n      window = { count: 0, windowStart: currentWindowStart };\n      this.windows.set(key, window);\n    }\n\n    if (window.count + weight <= this.maxRequests) {\n      window.count += weight;\n      return {\n        allowed: true,\n        remaining: this.maxRequests - window.count,\n        resetAt: windowEnd,\n      };\n    }\n\n    return {\n      allowed: false,\n      remaining: 0,\n      resetAt: windowEnd,\n      retryAfter: windowEnd - now,\n    };\n  }\n\n  reset(key: string): void {\n    this.windows.delete(key);\n  }\n\n  clear(): void {\n    this.windows.clear();\n  }\n}\n\n// ============================================================================\n// RateLimiter (unified interface)\n// ============================================================================\n\n/**\n * RateLimiter with multiple algorithm support\n *\n * @example\n * const limiter = new RateLimiter({\n *   maxRequests: 100,\n *   windowMs: 60 * 1000, // 1 minute\n *   algorithm: 'sliding-window',\n * });\n *\n * // Check if request is allowed\n * const result = limiter.check('user:123');\n * if (!result.allowed) {\n *   throw new RateLimitError('Too many requests', result.retryAfter!);\n * }\n *\n * // Or use the convenience method\n * await limiter.limit('user:123'); // throws if rate limited\n */\nexport class RateLimiter {\n  private limiter: TokenBucketLimiter | SlidingWindowLimiter | FixedWindowLimiter;\n  private stats: RateLimitStats = {\n    totalRequests: 0,\n    allowedRequests: 0,\n    blockedRequests: 0,\n    uniqueKeys: 0,\n  };\n  private seenKeys: Set<string> = new Set();\n  private readonly keyPrefix: string;\n  private readonly normalizedConfig: RateLimitConfig;\n\n  constructor(config: RateLimitConfig) {\n    // Apply defaults for optional fields\n    this.normalizedConfig = {\n      ...config,\n      algorithm: config.algorithm ?? \"sliding-window\",\n      keyPrefix: config.keyPrefix ?? \"ratelimit\",\n    };\n    this.keyPrefix = this.normalizedConfig.keyPrefix!;\n\n    switch (this.normalizedConfig.algorithm) {\n      case \"token-bucket\":\n        this.limiter = new TokenBucketLimiter(this.normalizedConfig);\n        break;\n      case \"fixed-window\":\n        this.limiter = new FixedWindowLimiter(this.normalizedConfig);\n        break;\n      case \"sliding-window\":\n      default:\n        this.limiter = new SlidingWindowLimiter(this.normalizedConfig);\n    }\n  }\n\n  /**\n   * Check if a request is allowed\n   */\n  check(key: string, weight = 1): RateLimitResult {\n    const prefixedKey = `${this.keyPrefix}:${key}`;\n    const result = this.limiter.check(prefixedKey, weight);\n\n    // Update stats\n    this.stats.totalRequests++;\n    if (result.allowed) {\n      this.stats.allowedRequests++;\n    } else {\n      this.stats.blockedRequests++;\n    }\n    if (!this.seenKeys.has(key)) {\n      this.seenKeys.add(key);\n      this.stats.uniqueKeys++;\n    }\n\n    return result;\n  }\n\n  /**\n   * Limit a request - throws if rate limited\n   */\n  limit(key: string, weight = 1): void {\n    const result = this.check(key, weight);\n    if (!result.allowed) {\n      throw new RateLimitError(\n        `Rate limit exceeded for ${key}`,\n        result.retryAfter ?? 0,\n        key\n      );\n    }\n  }\n\n  /**\n   * Async limit with optional wait\n   */\n  async limitAsync(\n    key: string,\n    options?: { wait?: boolean; maxWait?: number }\n  ): Promise<RateLimitResult> {\n    const result = this.check(key);\n\n    if (result.allowed) {\n      return result;\n    }\n\n    if (options?.wait && result.retryAfter) {\n      const waitTime = options.maxWait\n        ? Math.min(result.retryAfter, options.maxWait)\n        : result.retryAfter;\n\n      if (waitTime > 0) {\n        await new Promise((resolve) => setTimeout(resolve, waitTime));\n        return this.check(key);\n      }\n    }\n\n    throw new RateLimitError(\n      `Rate limit exceeded for ${key}`,\n      result.retryAfter ?? 0,\n      key\n    );\n  }\n\n  /**\n   * Wrap an async function with rate limiting\n   */\n  wrap<T>(\n    key: string,\n    fn: () => Promise<T>,\n    options?: { wait?: boolean; maxWait?: number }\n  ): Promise<T> {\n    return this.limitAsync(key, options).then(() => fn());\n  }\n\n  /**\n   * Reset rate limit for a key\n   */\n  reset(key: string): void {\n    const prefixedKey = `${this.keyPrefix}:${key}`;\n    this.limiter.reset(prefixedKey);\n  }\n\n  /**\n   * Clear all rate limits\n   */\n  clear(): void {\n    this.limiter.clear();\n    this.stats = {\n      totalRequests: 0,\n      allowedRequests: 0,\n      blockedRequests: 0,\n      uniqueKeys: 0,\n    };\n    this.seenKeys.clear();\n  }\n\n  /**\n   * Get current stats\n   */\n  getStats(): RateLimitStats {\n    return { ...this.stats };\n  }\n\n  /**\n   * Get configuration\n   */\n  getConfig(): RateLimitConfig {\n    return { ...this.normalizedConfig };\n  }\n}\n\n// ============================================================================\n// Multi-tier Rate Limiter\n// ============================================================================\n\nexport interface TierConfig {\n  name: string;\n  config: RateLimitConfig;\n}\n\n/**\n * Multi-tier rate limiter for different limit levels\n *\n * @example\n * const limiter = new MultiTierRateLimiter([\n *   { name: 'per-second', config: { maxRequests: 10, windowMs: 1000, algorithm: 'sliding-window' } },\n *   { name: 'per-minute', config: { maxRequests: 100, windowMs: 60000, algorithm: 'sliding-window' } },\n *   { name: 'per-hour', config: { maxRequests: 1000, windowMs: 3600000, algorithm: 'sliding-window' } },\n * ]);\n *\n * // All tiers must pass\n * limiter.limit('user:123');\n */\nexport class MultiTierRateLimiter {\n  private tiers: Map<string, RateLimiter> = new Map();\n\n  constructor(tiers: TierConfig[]) {\n    for (const tier of tiers) {\n      this.tiers.set(tier.name, new RateLimiter(tier.config));\n    }\n  }\n\n  check(key: string): { allowed: boolean; failedTier?: string; result: RateLimitResult } {\n    let finalResult: RateLimitResult = {\n      allowed: true,\n      remaining: Infinity,\n      resetAt: 0,\n    };\n\n    for (const [name, limiter] of this.tiers) {\n      const result = limiter.check(key);\n\n      if (!result.allowed) {\n        return { allowed: false, failedTier: name, result };\n      }\n\n      // Track the most restrictive limit\n      if (result.remaining < finalResult.remaining) {\n        finalResult = result;\n      }\n    }\n\n    return { allowed: true, result: finalResult };\n  }\n\n  limit(key: string): void {\n    const { allowed, failedTier, result } = this.check(key);\n    if (!allowed) {\n      throw new RateLimitError(\n        `Rate limit exceeded (${failedTier}) for ${key}`,\n        result.retryAfter ?? 0,\n        key\n      );\n    }\n  }\n\n  reset(key: string): void {\n    for (const limiter of this.tiers.values()) {\n      limiter.reset(key);\n    }\n  }\n\n  clear(): void {\n    for (const limiter of this.tiers.values()) {\n      limiter.clear();\n    }\n  }\n\n  getStats(): Map<string, RateLimitStats> {\n    const stats = new Map<string, RateLimitStats>();\n    for (const [name, limiter] of this.tiers) {\n      stats.set(name, limiter.getStats());\n    }\n    return stats;\n  }\n}\n\n// ============================================================================\n// Utility functions\n// ============================================================================\n\n/**\n * Create a rate limiter for API requests\n */\nexport function createApiRateLimiter(\n  requestsPerMinute: number\n): RateLimiter {\n  return new RateLimiter({\n    maxRequests: requestsPerMinute,\n    windowMs: 60 * 1000,\n    algorithm: \"sliding-window\",\n    keyPrefix: \"api\",\n  });\n}\n\n/**\n * Create a rate limiter for LLM API calls\n */\nexport function createLLMRateLimiter(config?: {\n  requestsPerMinute?: number;\n  tokensPerMinute?: number;\n}): MultiTierRateLimiter {\n  return new MultiTierRateLimiter([\n    {\n      name: \"requests\",\n      config: {\n        maxRequests: config?.requestsPerMinute ?? 60,\n        windowMs: 60 * 1000,\n        algorithm: \"sliding-window\",\n        keyPrefix: \"llm-requests\",\n      },\n    },\n    {\n      name: \"tokens\",\n      config: {\n        maxRequests: config?.tokensPerMinute ?? 100000,\n        windowMs: 60 * 1000,\n        algorithm: \"sliding-window\",\n        keyPrefix: \"llm-tokens\",\n      },\n    },\n  ]);\n}\n\n/**\n * Create rate limiter headers for HTTP responses\n */\nexport function createRateLimitHeaders(result: RateLimitResult, limit: number): Record<string, string> {\n  return {\n    \"X-RateLimit-Limit\": String(limit),\n    \"X-RateLimit-Remaining\": String(result.remaining),\n    \"X-RateLimit-Reset\": String(Math.ceil(result.resetAt / 1000)),\n    ...(result.retryAfter && { \"Retry-After\": String(Math.ceil(result.retryAfter / 1000)) }),\n  };\n}\n","/**\n * API Authentication for gICM platform\n *\n * Features:\n * - API key authentication\n * - JWT token handling\n * - Bearer token middleware\n * - Session management\n * - Token refresh\n */\n\nimport { z } from \"zod\";\nimport { createHash, randomBytes, createHmac, timingSafeEqual } from \"crypto\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport const AuthConfigSchema = z.object({\n  /** JWT secret for signing tokens */\n  jwtSecret: z.string().min(32).optional(),\n  /** Token expiration in seconds */\n  tokenExpiration: z.number().default(3600), // 1 hour\n  /** Refresh token expiration in seconds */\n  refreshExpiration: z.number().default(604800), // 7 days\n  /** API key prefix for validation */\n  apiKeyPrefix: z.string().default(\"gicm\"),\n  /** Enable API key authentication */\n  enableApiKey: z.boolean().default(true),\n  /** Enable JWT authentication */\n  enableJwt: z.boolean().default(true),\n});\n\nexport type AuthConfig = z.infer<typeof AuthConfigSchema>;\n\nexport interface TokenPayload {\n  sub: string; // Subject (user ID)\n  iat: number; // Issued at\n  exp: number; // Expiration\n  scope?: string[]; // Permissions\n  metadata?: Record<string, unknown>;\n}\n\nexport interface AuthResult {\n  authenticated: boolean;\n  userId?: string;\n  scope?: string[];\n  expiresAt?: number;\n  error?: string;\n}\n\nexport interface Session {\n  id: string;\n  userId: string;\n  createdAt: number;\n  expiresAt: number;\n  lastActive: number;\n  metadata?: Record<string, unknown>;\n}\n\n// ============================================================================\n// JWT Implementation (Simple base64url encoding without external deps)\n// ============================================================================\n\nfunction base64urlEncode(data: string | Buffer): string {\n  const base64 = Buffer.from(data).toString(\"base64\");\n  return base64.replace(/\\+/g, \"-\").replace(/\\//g, \"_\").replace(/=/g, \"\");\n}\n\nfunction base64urlDecode(str: string): string {\n  let base64 = str.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  while (base64.length % 4) {\n    base64 += \"=\";\n  }\n  return Buffer.from(base64, \"base64\").toString(\"utf8\");\n}\n\n/**\n * Simple JWT encoder/decoder\n * Note: For production, consider using a proper JWT library\n */\nexport class JwtManager {\n  private readonly secret: string;\n  private readonly algorithm = \"HS256\";\n\n  constructor(secret: string) {\n    if (secret.length < 32) {\n      throw new Error(\"JWT secret must be at least 32 characters\");\n    }\n    this.secret = secret;\n  }\n\n  /**\n   * Sign a JWT token\n   */\n  sign(payload: TokenPayload): string {\n    const header = { alg: this.algorithm, typ: \"JWT\" };\n    const encodedHeader = base64urlEncode(JSON.stringify(header));\n    const encodedPayload = base64urlEncode(JSON.stringify(payload));\n\n    const signature = this.createSignature(`${encodedHeader}.${encodedPayload}`);\n\n    return `${encodedHeader}.${encodedPayload}.${signature}`;\n  }\n\n  /**\n   * Verify and decode a JWT token\n   */\n  verify(token: string): TokenPayload | null {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    const [encodedHeader, encodedPayload, signature] = parts;\n\n    // Verify signature\n    const expectedSignature = this.createSignature(\n      `${encodedHeader}.${encodedPayload}`\n    );\n\n    // Use timing-safe comparison\n    const sigBuffer = Buffer.from(signature);\n    const expectedBuffer = Buffer.from(expectedSignature);\n\n    if (\n      sigBuffer.length !== expectedBuffer.length ||\n      !timingSafeEqual(sigBuffer, expectedBuffer)\n    ) {\n      return null;\n    }\n\n    try {\n      const payload = JSON.parse(base64urlDecode(encodedPayload)) as TokenPayload;\n\n      // Check expiration\n      if (payload.exp && payload.exp < Math.floor(Date.now() / 1000)) {\n        return null;\n      }\n\n      return payload;\n    } catch {\n      return null;\n    }\n  }\n\n  /**\n   * Decode without verification (use only for debugging)\n   */\n  decode(token: string): TokenPayload | null {\n    const parts = token.split(\".\");\n    if (parts.length !== 3) {\n      return null;\n    }\n\n    try {\n      return JSON.parse(base64urlDecode(parts[1])) as TokenPayload;\n    } catch {\n      return null;\n    }\n  }\n\n  private createSignature(data: string): string {\n    const hmac = createHmac(\"sha256\", this.secret);\n    hmac.update(data);\n    return base64urlEncode(hmac.digest());\n  }\n}\n\n// ============================================================================\n// API Key Manager\n// ============================================================================\n\nexport interface ApiKeyInfo {\n  id: string;\n  key: string;\n  hashedKey: string;\n  userId: string;\n  name: string;\n  scope: string[];\n  createdAt: number;\n  expiresAt?: number;\n  lastUsed?: number;\n  metadata?: Record<string, unknown>;\n}\n\n/**\n * API Key Manager for creating and validating API keys\n */\nexport class ApiKeyManager {\n  private keys: Map<string, ApiKeyInfo> = new Map();\n  private readonly prefix: string;\n\n  constructor(prefix = \"gicm\") {\n    this.prefix = prefix;\n  }\n\n  /**\n   * Generate a new API key\n   */\n  generate(options: {\n    userId: string;\n    name: string;\n    scope?: string[];\n    expiresIn?: number;\n    metadata?: Record<string, unknown>;\n  }): ApiKeyInfo {\n    const id = randomBytes(8).toString(\"hex\");\n    const keyBytes = randomBytes(24);\n    const key = `${this.prefix}_${keyBytes.toString(\"hex\")}`;\n    const hashedKey = this.hashKey(key);\n\n    const now = Date.now();\n    const info: ApiKeyInfo = {\n      id,\n      key, // Only returned on creation\n      hashedKey,\n      userId: options.userId,\n      name: options.name,\n      scope: options.scope ?? [\"read\"],\n      createdAt: now,\n      expiresAt: options.expiresIn ? now + options.expiresIn * 1000 : undefined,\n      metadata: options.metadata,\n    };\n\n    this.keys.set(hashedKey, info);\n    return info;\n  }\n\n  /**\n   * Validate an API key\n   */\n  validate(key: string): ApiKeyInfo | null {\n    if (!key.startsWith(`${this.prefix}_`)) {\n      return null;\n    }\n\n    const hashedKey = this.hashKey(key);\n    const info = this.keys.get(hashedKey);\n\n    if (!info) {\n      return null;\n    }\n\n    // Check expiration\n    if (info.expiresAt && info.expiresAt < Date.now()) {\n      return null;\n    }\n\n    // Update last used\n    info.lastUsed = Date.now();\n\n    // Return without the actual key\n    return { ...info, key: \"\" };\n  }\n\n  /**\n   * Revoke an API key by ID\n   */\n  revoke(id: string): boolean {\n    for (const [hash, info] of this.keys) {\n      if (info.id === id) {\n        this.keys.delete(hash);\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * List all keys for a user (without actual key values)\n   */\n  listForUser(userId: string): Omit<ApiKeyInfo, \"key\" | \"hashedKey\">[] {\n    const result: Omit<ApiKeyInfo, \"key\" | \"hashedKey\">[] = [];\n    for (const info of this.keys.values()) {\n      if (info.userId === userId) {\n        const { key: _, hashedKey: __, ...rest } = info;\n        result.push(rest);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Register an existing hashed key (for loading from storage)\n   */\n  register(info: Omit<ApiKeyInfo, \"key\">): void {\n    this.keys.set(info.hashedKey, { ...info, key: \"\" });\n  }\n\n  /**\n   * Export all keys (hashed) for persistence\n   */\n  export(): Omit<ApiKeyInfo, \"key\">[] {\n    return Array.from(this.keys.values()).map(({ key: _, ...rest }) => rest);\n  }\n\n  private hashKey(key: string): string {\n    return createHash(\"sha256\").update(key).digest(\"hex\");\n  }\n}\n\n// ============================================================================\n// Session Manager\n// ============================================================================\n\n/**\n * In-memory session manager\n */\nexport class SessionManager {\n  private sessions: Map<string, Session> = new Map();\n  private readonly defaultTtl: number;\n\n  constructor(defaultTtlSeconds = 3600) {\n    this.defaultTtl = defaultTtlSeconds * 1000;\n  }\n\n  /**\n   * Create a new session\n   */\n  create(userId: string, ttl?: number, metadata?: Record<string, unknown>): Session {\n    const id = randomBytes(32).toString(\"hex\");\n    const now = Date.now();\n    const expiresAt = now + (ttl ?? this.defaultTtl);\n\n    const session: Session = {\n      id,\n      userId,\n      createdAt: now,\n      expiresAt,\n      lastActive: now,\n      metadata,\n    };\n\n    this.sessions.set(id, session);\n    return session;\n  }\n\n  /**\n   * Get a session by ID\n   */\n  get(sessionId: string): Session | null {\n    const session = this.sessions.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    // Check expiration\n    if (session.expiresAt < Date.now()) {\n      this.sessions.delete(sessionId);\n      return null;\n    }\n\n    // Update last active\n    session.lastActive = Date.now();\n    return session;\n  }\n\n  /**\n   * Extend session expiration\n   */\n  extend(sessionId: string, additionalMs?: number): Session | null {\n    const session = this.get(sessionId);\n    if (!session) {\n      return null;\n    }\n\n    session.expiresAt = Date.now() + (additionalMs ?? this.defaultTtl);\n    return session;\n  }\n\n  /**\n   * Destroy a session\n   */\n  destroy(sessionId: string): boolean {\n    return this.sessions.delete(sessionId);\n  }\n\n  /**\n   * Destroy all sessions for a user\n   */\n  destroyAllForUser(userId: string): number {\n    let count = 0;\n    for (const [id, session] of this.sessions) {\n      if (session.userId === userId) {\n        this.sessions.delete(id);\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * List active sessions for a user\n   */\n  listForUser(userId: string): Session[] {\n    const now = Date.now();\n    const result: Session[] = [];\n    for (const session of this.sessions.values()) {\n      if (session.userId === userId && session.expiresAt > now) {\n        result.push(session);\n      }\n    }\n    return result;\n  }\n\n  /**\n   * Clean up expired sessions\n   */\n  cleanup(): number {\n    const now = Date.now();\n    let count = 0;\n    for (const [id, session] of this.sessions) {\n      if (session.expiresAt < now) {\n        this.sessions.delete(id);\n        count++;\n      }\n    }\n    return count;\n  }\n\n  /**\n   * Get total active sessions count\n   */\n  get activeCount(): number {\n    const now = Date.now();\n    let count = 0;\n    for (const session of this.sessions.values()) {\n      if (session.expiresAt > now) {\n        count++;\n      }\n    }\n    return count;\n  }\n}\n\n// ============================================================================\n// Auth Middleware\n// ============================================================================\n\nexport interface AuthRequest {\n  headers: Record<string, string | undefined>;\n  cookies?: Record<string, string | undefined>;\n}\n\n/**\n * Authentication middleware for handling requests\n */\nexport class AuthMiddleware {\n  private readonly config: AuthConfig;\n  private jwtManager?: JwtManager;\n  private apiKeyManager?: ApiKeyManager;\n  private sessionManager?: SessionManager;\n\n  constructor(config: Partial<AuthConfig> = {}) {\n    this.config = AuthConfigSchema.parse(config);\n\n    if (this.config.enableJwt && this.config.jwtSecret) {\n      this.jwtManager = new JwtManager(this.config.jwtSecret);\n    }\n\n    if (this.config.enableApiKey) {\n      this.apiKeyManager = new ApiKeyManager(this.config.apiKeyPrefix);\n    }\n\n    this.sessionManager = new SessionManager(this.config.tokenExpiration);\n  }\n\n  /**\n   * Authenticate a request\n   */\n  authenticate(request: AuthRequest): AuthResult {\n    const authHeader = request.headers.authorization || request.headers.Authorization;\n\n    // Try Bearer token (JWT)\n    if (authHeader?.startsWith(\"Bearer \") && this.jwtManager) {\n      const token = authHeader.slice(7);\n      const payload = this.jwtManager.verify(token);\n\n      if (payload) {\n        return {\n          authenticated: true,\n          userId: payload.sub,\n          scope: payload.scope,\n          expiresAt: payload.exp * 1000,\n        };\n      }\n      return { authenticated: false, error: \"Invalid or expired token\" };\n    }\n\n    // Try API key from header\n    if (authHeader && this.apiKeyManager) {\n      const key = authHeader.startsWith(\"ApiKey \")\n        ? authHeader.slice(7)\n        : authHeader;\n\n      const info = this.apiKeyManager.validate(key);\n      if (info) {\n        return {\n          authenticated: true,\n          userId: info.userId,\n          scope: info.scope,\n          expiresAt: info.expiresAt,\n        };\n      }\n    }\n\n    // Try session cookie\n    const sessionId = request.cookies?.session;\n    if (sessionId && this.sessionManager) {\n      const session = this.sessionManager.get(sessionId);\n      if (session) {\n        return {\n          authenticated: true,\n          userId: session.userId,\n          expiresAt: session.expiresAt,\n        };\n      }\n    }\n\n    return { authenticated: false, error: \"No valid credentials provided\" };\n  }\n\n  /**\n   * Generate a JWT token for a user\n   */\n  generateToken(\n    userId: string,\n    options?: { scope?: string[]; metadata?: Record<string, unknown> }\n  ): string | null {\n    if (!this.jwtManager) {\n      return null;\n    }\n\n    const now = Math.floor(Date.now() / 1000);\n    const payload: TokenPayload = {\n      sub: userId,\n      iat: now,\n      exp: now + this.config.tokenExpiration,\n      scope: options?.scope,\n      metadata: options?.metadata,\n    };\n\n    return this.jwtManager.sign(payload);\n  }\n\n  /**\n   * Generate a refresh token\n   */\n  generateRefreshToken(userId: string): string {\n    const token = randomBytes(32).toString(\"hex\");\n    // In production, store this in a database with userId and expiration\n    return token;\n  }\n\n  /**\n   * Generate an API key\n   */\n  generateApiKey(options: {\n    userId: string;\n    name: string;\n    scope?: string[];\n    expiresIn?: number;\n  }): ApiKeyInfo | null {\n    if (!this.apiKeyManager) {\n      return null;\n    }\n    return this.apiKeyManager.generate(options);\n  }\n\n  /**\n   * Revoke an API key\n   */\n  revokeApiKey(keyId: string): boolean {\n    return this.apiKeyManager?.revoke(keyId) ?? false;\n  }\n\n  /**\n   * Create a session\n   */\n  createSession(\n    userId: string,\n    metadata?: Record<string, unknown>\n  ): Session | null {\n    if (!this.sessionManager) {\n      return null;\n    }\n    return this.sessionManager.create(userId, this.config.tokenExpiration, metadata);\n  }\n\n  /**\n   * Destroy a session\n   */\n  destroySession(sessionId: string): boolean {\n    return this.sessionManager?.destroy(sessionId) ?? false;\n  }\n\n  /**\n   * Get the JWT manager (for custom operations)\n   */\n  getJwtManager(): JwtManager | undefined {\n    return this.jwtManager;\n  }\n\n  /**\n   * Get the API key manager\n   */\n  getApiKeyManager(): ApiKeyManager | undefined {\n    return this.apiKeyManager;\n  }\n\n  /**\n   * Get the session manager\n   */\n  getSessionManager(): SessionManager | undefined {\n    return this.sessionManager;\n  }\n}\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Check if a scope array includes the required permissions\n */\nexport function hasScope(userScope: string[], required: string | string[]): boolean {\n  const requiredScopes = Array.isArray(required) ? required : [required];\n\n  // Wildcard check\n  if (userScope.includes(\"*\") || userScope.includes(\"admin\")) {\n    return true;\n  }\n\n  return requiredScopes.every((scope) => {\n    // Direct match\n    if (userScope.includes(scope)) {\n      return true;\n    }\n\n    // Hierarchical check (e.g., \"read:users\" matches \"read:*\")\n    const [action, resource] = scope.split(\":\");\n    if (resource && userScope.includes(`${action}:*`)) {\n      return true;\n    }\n\n    return false;\n  });\n}\n\n/**\n * Parse authorization header\n */\nexport function parseAuthHeader(\n  header: string\n): { type: \"bearer\" | \"apikey\" | \"basic\" | \"unknown\"; value: string } | null {\n  if (!header) {\n    return null;\n  }\n\n  const lower = header.toLowerCase();\n\n  if (lower.startsWith(\"bearer \")) {\n    return { type: \"bearer\", value: header.slice(7) };\n  }\n\n  if (lower.startsWith(\"apikey \")) {\n    return { type: \"apikey\", value: header.slice(7) };\n  }\n\n  if (lower.startsWith(\"basic \")) {\n    return { type: \"basic\", value: header.slice(6) };\n  }\n\n  // Might be a raw API key\n  if (header.includes(\"_\")) {\n    return { type: \"apikey\", value: header };\n  }\n\n  return { type: \"unknown\", value: header };\n}\n\n/**\n * Create a simple authentication guard\n */\nexport function createAuthGuard(\n  middleware: AuthMiddleware,\n  options?: { requiredScope?: string[] }\n) {\n  return (request: AuthRequest): AuthResult => {\n    const result = middleware.authenticate(request);\n\n    if (!result.authenticated) {\n      return result;\n    }\n\n    if (\n      options?.requiredScope &&\n      result.scope &&\n      !hasScope(result.scope, options.requiredScope)\n    ) {\n      return {\n        authenticated: false,\n        error: \"Insufficient permissions\",\n      };\n    }\n\n    return result;\n  };\n}\n\n/**\n * Hash a password (simple bcrypt-like approach using PBKDF2)\n */\nexport async function hashPassword(\n  password: string,\n  salt?: string\n): Promise<{ hash: string; salt: string }> {\n  const crypto = await import(\"crypto\");\n  const useSalt = salt ?? crypto.randomBytes(16).toString(\"hex\");\n\n  return new Promise((resolve, reject) => {\n    crypto.pbkdf2(password, useSalt, 100000, 64, \"sha512\", (err, derivedKey) => {\n      if (err) reject(err);\n      else\n        resolve({\n          hash: derivedKey.toString(\"hex\"),\n          salt: useSalt,\n        });\n    });\n  });\n}\n\n/**\n * Verify a password against a hash\n */\nexport async function verifyPassword(\n  password: string,\n  hash: string,\n  salt: string\n): Promise<boolean> {\n  const result = await hashPassword(password, salt);\n  return timingSafeEqual(Buffer.from(result.hash), Buffer.from(hash));\n}\n","/**\n * Security Headers for gICM platform\n *\n * Features:\n * - Content Security Policy (CSP)\n * - Cross-Origin Resource Sharing (CORS)\n * - HTTP Strict Transport Security (HSTS)\n * - XSS Protection\n * - Content Type Options\n * - Frame Options\n * - Referrer Policy\n */\n\nimport { z } from \"zod\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport const CspDirectiveSchema = z.object({\n  \"default-src\": z.array(z.string()).optional(),\n  \"script-src\": z.array(z.string()).optional(),\n  \"style-src\": z.array(z.string()).optional(),\n  \"img-src\": z.array(z.string()).optional(),\n  \"font-src\": z.array(z.string()).optional(),\n  \"connect-src\": z.array(z.string()).optional(),\n  \"media-src\": z.array(z.string()).optional(),\n  \"object-src\": z.array(z.string()).optional(),\n  \"frame-src\": z.array(z.string()).optional(),\n  \"frame-ancestors\": z.array(z.string()).optional(),\n  \"form-action\": z.array(z.string()).optional(),\n  \"base-uri\": z.array(z.string()).optional(),\n  \"worker-src\": z.array(z.string()).optional(),\n  \"manifest-src\": z.array(z.string()).optional(),\n  \"upgrade-insecure-requests\": z.boolean().optional(),\n  \"block-all-mixed-content\": z.boolean().optional(),\n  \"report-uri\": z.string().optional(),\n  \"report-to\": z.string().optional(),\n});\n\nexport type CspDirectives = z.infer<typeof CspDirectiveSchema>;\n\nexport const CorsConfigSchema = z.object({\n  /** Allowed origins (use '*' for any, or array of specific origins) */\n  allowedOrigins: z.union([z.literal(\"*\"), z.array(z.string())]).default(\"*\"),\n  /** Allowed HTTP methods */\n  allowedMethods: z\n    .array(z.string())\n    .default([\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"]),\n  /** Allowed headers */\n  allowedHeaders: z\n    .array(z.string())\n    .default([\"Content-Type\", \"Authorization\", \"X-Requested-With\"]),\n  /** Exposed headers */\n  exposedHeaders: z.array(z.string()).optional(),\n  /** Allow credentials */\n  credentials: z.boolean().default(false),\n  /** Max age for preflight cache (seconds) */\n  maxAge: z.number().default(86400),\n});\n\nexport type CorsConfig = z.infer<typeof CorsConfigSchema>;\n\nexport const SecurityHeadersConfigSchema = z.object({\n  /** Content Security Policy */\n  csp: CspDirectiveSchema.optional(),\n  /** Report-only CSP (for testing) */\n  cspReportOnly: z.boolean().default(false),\n  /** CORS configuration */\n  cors: CorsConfigSchema.optional(),\n  /** HTTP Strict Transport Security */\n  hsts: z\n    .object({\n      maxAge: z.number().default(31536000), // 1 year\n      includeSubDomains: z.boolean().default(true),\n      preload: z.boolean().default(false),\n    })\n    .optional(),\n  /** X-Content-Type-Options */\n  noSniff: z.boolean().default(true),\n  /** X-Frame-Options */\n  frameOptions: z.enum([\"DENY\", \"SAMEORIGIN\"]).default(\"DENY\"),\n  /** X-XSS-Protection (legacy but still useful) */\n  xssProtection: z.boolean().default(true),\n  /** Referrer-Policy */\n  referrerPolicy: z\n    .enum([\n      \"no-referrer\",\n      \"no-referrer-when-downgrade\",\n      \"origin\",\n      \"origin-when-cross-origin\",\n      \"same-origin\",\n      \"strict-origin\",\n      \"strict-origin-when-cross-origin\",\n      \"unsafe-url\",\n    ])\n    .default(\"strict-origin-when-cross-origin\"),\n  /** Permissions-Policy */\n  permissionsPolicy: z.record(z.array(z.string())).optional(),\n  /** Cross-Origin-Embedder-Policy */\n  coep: z.enum([\"require-corp\", \"credentialless\", \"unsafe-none\"]).optional(),\n  /** Cross-Origin-Opener-Policy */\n  coop: z.enum([\"same-origin\", \"same-origin-allow-popups\", \"unsafe-none\"]).optional(),\n  /** Cross-Origin-Resource-Policy */\n  corp: z.enum([\"same-site\", \"same-origin\", \"cross-origin\"]).optional(),\n});\n\nexport type SecurityHeadersConfig = z.infer<typeof SecurityHeadersConfigSchema>;\n\n// ============================================================================\n// CSP Builder\n// ============================================================================\n\n/**\n * Build a Content Security Policy string from directives\n */\nexport function buildCspString(directives: CspDirectives): string {\n  const parts: string[] = [];\n\n  for (const [key, value] of Object.entries(directives)) {\n    if (value === undefined) continue;\n\n    if (typeof value === \"boolean\") {\n      if (value) {\n        parts.push(key);\n      }\n    } else if (typeof value === \"string\") {\n      parts.push(`${key} ${value}`);\n    } else if (Array.isArray(value) && value.length > 0) {\n      parts.push(`${key} ${value.join(\" \")}`);\n    }\n  }\n\n  return parts.join(\"; \");\n}\n\n/**\n * CSP presets for common use cases\n */\nexport const CSP_PRESETS = {\n  strict: {\n    \"default-src\": [\"'self'\"],\n    \"script-src\": [\"'self'\"],\n    \"style-src\": [\"'self'\"],\n    \"img-src\": [\"'self'\", \"data:\"],\n    \"font-src\": [\"'self'\"],\n    \"connect-src\": [\"'self'\"],\n    \"object-src\": [\"'none'\"],\n    \"frame-ancestors\": [\"'none'\"],\n    \"form-action\": [\"'self'\"],\n    \"base-uri\": [\"'self'\"],\n    \"upgrade-insecure-requests\": true,\n  } as CspDirectives,\n\n  moderate: {\n    \"default-src\": [\"'self'\"],\n    \"script-src\": [\"'self'\", \"'unsafe-inline'\"],\n    \"style-src\": [\"'self'\", \"'unsafe-inline'\"],\n    \"img-src\": [\"'self'\", \"data:\", \"https:\"],\n    \"font-src\": [\"'self'\", \"https:\"],\n    \"connect-src\": [\"'self'\", \"https:\"],\n    \"object-src\": [\"'none'\"],\n    \"frame-ancestors\": [\"'self'\"],\n    \"upgrade-insecure-requests\": true,\n  } as CspDirectives,\n\n  relaxed: {\n    \"default-src\": [\"'self'\", \"https:\"],\n    \"script-src\": [\"'self'\", \"'unsafe-inline'\", \"'unsafe-eval'\", \"https:\"],\n    \"style-src\": [\"'self'\", \"'unsafe-inline'\", \"https:\"],\n    \"img-src\": [\"*\", \"data:\", \"blob:\"],\n    \"font-src\": [\"*\", \"data:\"],\n    \"connect-src\": [\"*\"],\n    \"object-src\": [\"'none'\"],\n  } as CspDirectives,\n\n  api: {\n    \"default-src\": [\"'none'\"],\n    \"frame-ancestors\": [\"'none'\"],\n    \"form-action\": [\"'none'\"],\n  } as CspDirectives,\n};\n\n// ============================================================================\n// CORS Handler\n// ============================================================================\n\nexport interface CorsHeaders {\n  \"Access-Control-Allow-Origin\": string;\n  \"Access-Control-Allow-Methods\"?: string;\n  \"Access-Control-Allow-Headers\"?: string;\n  \"Access-Control-Expose-Headers\"?: string;\n  \"Access-Control-Allow-Credentials\"?: string;\n  \"Access-Control-Max-Age\"?: string;\n}\n\n/**\n * Generate CORS headers for a request\n */\nexport function generateCorsHeaders(\n  origin: string | undefined,\n  config: CorsConfig,\n  isPreflight = false\n): CorsHeaders | null {\n  // Check if origin is allowed\n  let allowedOrigin: string | null = null;\n\n  if (config.allowedOrigins === \"*\") {\n    allowedOrigin = config.credentials ? (origin ?? \"*\") : \"*\";\n  } else if (origin && config.allowedOrigins.includes(origin)) {\n    allowedOrigin = origin;\n  } else if (origin && config.allowedOrigins.some((o) => o.endsWith(\"*\"))) {\n    // Handle wildcard subdomains (e.g., \"*.example.com\")\n    for (const pattern of config.allowedOrigins) {\n      if (pattern.endsWith(\"*\")) {\n        const prefix = pattern.slice(0, -1);\n        if (origin.startsWith(prefix)) {\n          allowedOrigin = origin;\n          break;\n        }\n      }\n    }\n  }\n\n  if (!allowedOrigin) {\n    return null;\n  }\n\n  const headers: CorsHeaders = {\n    \"Access-Control-Allow-Origin\": allowedOrigin,\n  };\n\n  if (config.credentials) {\n    headers[\"Access-Control-Allow-Credentials\"] = \"true\";\n  }\n\n  if (isPreflight) {\n    headers[\"Access-Control-Allow-Methods\"] = config.allowedMethods.join(\", \");\n    headers[\"Access-Control-Allow-Headers\"] = config.allowedHeaders.join(\", \");\n    headers[\"Access-Control-Max-Age\"] = String(config.maxAge);\n  }\n\n  if (config.exposedHeaders && config.exposedHeaders.length > 0) {\n    headers[\"Access-Control-Expose-Headers\"] = config.exposedHeaders.join(\", \");\n  }\n\n  return headers;\n}\n\n// ============================================================================\n// Security Headers Generator\n// ============================================================================\n\n/**\n * Generate all security headers based on configuration\n */\nexport function generateSecurityHeaders(\n  config: SecurityHeadersConfig,\n  options?: { origin?: string; isPreflight?: boolean }\n): Record<string, string> {\n  const headers: Record<string, string> = {};\n\n  // Content Security Policy\n  if (config.csp) {\n    const cspString = buildCspString(config.csp);\n    if (cspString) {\n      const headerName = config.cspReportOnly\n        ? \"Content-Security-Policy-Report-Only\"\n        : \"Content-Security-Policy\";\n      headers[headerName] = cspString;\n    }\n  }\n\n  // CORS\n  if (config.cors) {\n    const corsHeaders = generateCorsHeaders(\n      options?.origin,\n      config.cors,\n      options?.isPreflight\n    );\n    if (corsHeaders) {\n      Object.assign(headers, corsHeaders);\n    }\n  }\n\n  // HSTS\n  if (config.hsts) {\n    let hsts = `max-age=${config.hsts.maxAge}`;\n    if (config.hsts.includeSubDomains) {\n      hsts += \"; includeSubDomains\";\n    }\n    if (config.hsts.preload) {\n      hsts += \"; preload\";\n    }\n    headers[\"Strict-Transport-Security\"] = hsts;\n  }\n\n  // X-Content-Type-Options\n  if (config.noSniff) {\n    headers[\"X-Content-Type-Options\"] = \"nosniff\";\n  }\n\n  // X-Frame-Options\n  if (config.frameOptions) {\n    headers[\"X-Frame-Options\"] = config.frameOptions;\n  }\n\n  // X-XSS-Protection\n  if (config.xssProtection) {\n    headers[\"X-XSS-Protection\"] = \"1; mode=block\";\n  }\n\n  // Referrer-Policy\n  if (config.referrerPolicy) {\n    headers[\"Referrer-Policy\"] = config.referrerPolicy;\n  }\n\n  // Permissions-Policy\n  if (config.permissionsPolicy) {\n    const policy = Object.entries(config.permissionsPolicy)\n      .map(([feature, allowlist]) => {\n        if (allowlist.length === 0) {\n          return `${feature}=()`;\n        }\n        return `${feature}=(${allowlist.join(\" \")})`;\n      })\n      .join(\", \");\n    headers[\"Permissions-Policy\"] = policy;\n  }\n\n  // Cross-Origin headers\n  if (config.coep) {\n    headers[\"Cross-Origin-Embedder-Policy\"] = config.coep;\n  }\n  if (config.coop) {\n    headers[\"Cross-Origin-Opener-Policy\"] = config.coop;\n  }\n  if (config.corp) {\n    headers[\"Cross-Origin-Resource-Policy\"] = config.corp;\n  }\n\n  return headers;\n}\n\n// ============================================================================\n// Security Headers Middleware\n// ============================================================================\n\nexport interface HttpRequest {\n  method: string;\n  headers: Record<string, string | undefined>;\n  url?: string;\n}\n\nexport interface HttpResponse {\n  headers: Record<string, string>;\n  statusCode?: number;\n}\n\n/**\n * SecurityHeadersMiddleware applies security headers to responses\n */\nexport class SecurityHeadersMiddleware {\n  private readonly config: SecurityHeadersConfig;\n\n  constructor(config?: Partial<SecurityHeadersConfig>) {\n    this.config = SecurityHeadersConfigSchema.parse(config ?? {});\n  }\n\n  /**\n   * Apply security headers to a response\n   */\n  apply(request: HttpRequest, response: HttpResponse): HttpResponse {\n    const origin = request.headers.origin ?? request.headers.Origin;\n    const isPreflight = request.method === \"OPTIONS\";\n\n    const securityHeaders = generateSecurityHeaders(this.config, {\n      origin,\n      isPreflight,\n    });\n\n    return {\n      ...response,\n      headers: {\n        ...response.headers,\n        ...securityHeaders,\n      },\n    };\n  }\n\n  /**\n   * Handle CORS preflight request\n   */\n  handlePreflight(request: HttpRequest): HttpResponse | null {\n    if (request.method !== \"OPTIONS\") {\n      return null;\n    }\n\n    const origin = request.headers.origin ?? request.headers.Origin;\n\n    if (!this.config.cors || !origin) {\n      return null;\n    }\n\n    const corsHeaders = generateCorsHeaders(origin, this.config.cors, true);\n\n    if (!corsHeaders) {\n      return { headers: {}, statusCode: 403 };\n    }\n\n    // Filter out undefined values and create Record<string, string>\n    const headers: Record<string, string> = {};\n    for (const [key, value] of Object.entries(corsHeaders)) {\n      if (value !== undefined) {\n        headers[key] = value;\n      }\n    }\n\n    return {\n      headers,\n      statusCode: 204,\n    };\n  }\n\n  /**\n   * Get current configuration\n   */\n  getConfig(): SecurityHeadersConfig {\n    return { ...this.config };\n  }\n}\n\n// ============================================================================\n// Preset Configurations\n// ============================================================================\n\n/**\n * Pre-configured security header profiles\n */\nexport const SECURITY_PRESETS = {\n  /** Strict security for production APIs */\n  strictApi: {\n    csp: CSP_PRESETS.api,\n    hsts: { maxAge: 31536000, includeSubDomains: true, preload: true },\n    noSniff: true,\n    frameOptions: \"DENY\",\n    xssProtection: true,\n    referrerPolicy: \"no-referrer\",\n    coep: \"require-corp\",\n    coop: \"same-origin\",\n    corp: \"same-origin\",\n  } as SecurityHeadersConfig,\n\n  /** Moderate security for web applications */\n  webApp: {\n    csp: CSP_PRESETS.moderate,\n    hsts: { maxAge: 31536000, includeSubDomains: true },\n    noSniff: true,\n    frameOptions: \"SAMEORIGIN\",\n    xssProtection: true,\n    referrerPolicy: \"strict-origin-when-cross-origin\",\n  } as SecurityHeadersConfig,\n\n  /** Relaxed for development */\n  development: {\n    csp: CSP_PRESETS.relaxed,\n    cspReportOnly: true,\n    cors: {\n      allowedOrigins: \"*\",\n      allowedMethods: [\"GET\", \"POST\", \"PUT\", \"DELETE\", \"PATCH\", \"OPTIONS\"],\n      allowedHeaders: [\"*\"],\n      credentials: true,\n    },\n    noSniff: true,\n    frameOptions: \"SAMEORIGIN\",\n    xssProtection: true,\n    referrerPolicy: \"no-referrer-when-downgrade\",\n  } as SecurityHeadersConfig,\n\n  /** For public APIs with CORS */\n  publicApi: {\n    csp: CSP_PRESETS.api,\n    cors: {\n      allowedOrigins: \"*\",\n      allowedMethods: [\"GET\", \"POST\", \"OPTIONS\"],\n      allowedHeaders: [\"Content-Type\", \"Authorization\"],\n    },\n    hsts: { maxAge: 31536000, includeSubDomains: true },\n    noSniff: true,\n    frameOptions: \"DENY\",\n    xssProtection: true,\n    referrerPolicy: \"no-referrer\",\n  } as SecurityHeadersConfig,\n};\n\n// ============================================================================\n// Utility Functions\n// ============================================================================\n\n/**\n * Create a nonce for inline scripts/styles\n */\nexport function generateNonce(): string {\n  const crypto = globalThis.crypto ?? require(\"crypto\");\n  const bytes = new Uint8Array(16);\n  crypto.getRandomValues(bytes);\n  return Buffer.from(bytes).toString(\"base64\");\n}\n\n/**\n * Add nonce to CSP directives\n */\nexport function addNonceToCsp(\n  directives: CspDirectives,\n  nonce: string,\n  targets: (\"script-src\" | \"style-src\")[] = [\"script-src\", \"style-src\"]\n): CspDirectives {\n  const result = { ...directives };\n  const nonceValue = `'nonce-${nonce}'`;\n\n  for (const target of targets) {\n    const current = result[target] ?? [];\n    result[target] = [...current, nonceValue];\n  }\n\n  return result;\n}\n\n/**\n * Merge CSP directives\n */\nexport function mergeCspDirectives(\n  base: CspDirectives,\n  override: Partial<CspDirectives>\n): CspDirectives {\n  const result = { ...base };\n\n  for (const [key, value] of Object.entries(override)) {\n    if (value !== undefined) {\n      const k = key as keyof CspDirectives;\n      if (Array.isArray(value) && Array.isArray(result[k])) {\n        // Merge arrays\n        (result as Record<string, unknown>)[k] = [\n          ...(result[k] as string[]),\n          ...value,\n        ];\n      } else {\n        (result as Record<string, unknown>)[k] = value;\n      }\n    }\n  }\n\n  return result;\n}\n\n/**\n * Validate an origin against allowed origins\n */\nexport function isOriginAllowed(\n  origin: string,\n  allowedOrigins: string[] | \"*\"\n): boolean {\n  if (allowedOrigins === \"*\") {\n    return true;\n  }\n\n  for (const allowed of allowedOrigins) {\n    if (allowed === origin) {\n      return true;\n    }\n\n    // Handle wildcards (e.g., \"*.example.com\")\n    if (allowed.startsWith(\"*.\")) {\n      const domain = allowed.slice(2);\n      const originDomain = new URL(origin).hostname;\n      if (originDomain === domain || originDomain.endsWith(`.${domain}`)) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\n/**\n * Create security headers for static file serving\n */\nexport function createStaticFileHeaders(\n  contentType: string\n): Record<string, string> {\n  const headers: Record<string, string> = {\n    \"X-Content-Type-Options\": \"nosniff\",\n  };\n\n  // Add caching headers for static assets\n  if (\n    contentType.startsWith(\"image/\") ||\n    contentType.startsWith(\"font/\") ||\n    contentType === \"application/javascript\" ||\n    contentType === \"text/css\"\n  ) {\n    headers[\"Cache-Control\"] = \"public, max-age=31536000, immutable\";\n  }\n\n  // Specific headers for HTML\n  if (contentType === \"text/html\") {\n    headers[\"X-Frame-Options\"] = \"SAMEORIGIN\";\n    headers[\"X-XSS-Protection\"] = \"1; mode=block\";\n  }\n\n  return headers;\n}\n"],"mappings":"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","names":["z","z","createHash","randomBytes","z"]}