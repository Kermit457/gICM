{"version":3,"sources":["../src/resilience/retry.ts","../src/resilience/circuit-breaker.ts","../src/resilience/timeout.ts","../src/resilience/health-check.ts","../src/resilience/health-aggregator.ts","../src/resilience/live-guards.ts","../src/resilience/index.ts"],"sourcesContent":["/**\n * Retry with exponential backoff\n */\n\nexport interface RetryConfig {\n  maxAttempts: number;\n  initialDelay: number;\n  maxDelay: number;\n  backoffFactor: number;\n  jitter: boolean;\n  shouldRetry?: (error: Error, attempt: number) => boolean;\n  onRetry?: (error: Error, attempt: number, delay: number) => void;\n}\n\nconst DEFAULT_CONFIG: RetryConfig = {\n  maxAttempts: 3,\n  initialDelay: 1000,\n  maxDelay: 30000,\n  backoffFactor: 2,\n  jitter: true,\n};\n\nexport function calculateDelay(attempt: number, config: RetryConfig): number {\n  let delay = config.initialDelay * Math.pow(config.backoffFactor, attempt);\n  delay = Math.min(delay, config.maxDelay);\n\n  if (config.jitter) {\n    // Add +/- 25% jitter\n    const jitterRange = delay * 0.25;\n    delay = delay - jitterRange + Math.random() * jitterRange * 2;\n  }\n\n  return Math.floor(delay);\n}\n\nexport async function withRetry<T>(\n  fn: () => Promise<T>,\n  config?: Partial<RetryConfig>\n): Promise<T> {\n  const cfg: RetryConfig = { ...DEFAULT_CONFIG, ...config };\n  let lastError: Error = new Error(\"No attempts made\");\n\n  for (let attempt = 0; attempt < cfg.maxAttempts; attempt++) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error instanceof Error ? error : new Error(String(error));\n\n      // Check if we should retry\n      if (cfg.shouldRetry && !cfg.shouldRetry(lastError, attempt)) {\n        throw lastError;\n      }\n\n      // Last attempt - don't delay, just throw\n      if (attempt >= cfg.maxAttempts - 1) {\n        throw lastError;\n      }\n\n      // Calculate delay\n      const delay = calculateDelay(attempt, cfg);\n\n      // Notify\n      if (cfg.onRetry) {\n        cfg.onRetry(lastError, attempt + 1, delay);\n      }\n\n      // Wait before retry\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError;\n}\n\n/**\n * Retry decorator for class methods\n */\nexport function Retry(config?: Partial<RetryConfig>) {\n  return function (\n    _target: unknown,\n    _propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) {\n    const originalMethod = descriptor.value;\n\n    descriptor.value = async function (...args: unknown[]) {\n      return withRetry(() => originalMethod.apply(this, args), config);\n    };\n\n    return descriptor;\n  };\n}\n","/**\n * Circuit Breaker pattern to prevent cascade failures\n */\n\nexport enum CircuitState {\n  CLOSED = \"CLOSED\",\n  OPEN = \"OPEN\",\n  HALF_OPEN = \"HALF_OPEN\",\n}\n\nexport interface CircuitBreakerConfig {\n  name: string;\n  failureThreshold: number;\n  successThreshold: number;\n  timeout: number;\n  onStateChange?: (from: CircuitState, to: CircuitState) => void;\n  onFailure?: (error: Error) => void;\n}\n\nconst DEFAULT_CONFIG: Omit<CircuitBreakerConfig, \"name\"> = {\n  failureThreshold: 5,\n  successThreshold: 2,\n  timeout: 60000,\n};\n\nexport class CircuitBreakerOpenError extends Error {\n  constructor(name: string) {\n    super(`Circuit breaker \"${name}\" is OPEN`);\n    this.name = \"CircuitBreakerOpenError\";\n  }\n}\n\nexport class CircuitBreaker {\n  private state: CircuitState = CircuitState.CLOSED;\n  private failureCount = 0;\n  private successCount = 0;\n  private nextAttemptTime = 0;\n  private config: CircuitBreakerConfig;\n\n  constructor(config: Partial<CircuitBreakerConfig> & { name: string }) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n  }\n\n  async execute<T>(fn: () => Promise<T>): Promise<T> {\n    // Check if we should allow the request\n    if (!this.canExecute()) {\n      throw new CircuitBreakerOpenError(this.config.name);\n    }\n\n    try {\n      const result = await fn();\n      this.onSuccess();\n      return result;\n    } catch (error) {\n      this.onFailure(error instanceof Error ? error : new Error(String(error)));\n      throw error;\n    }\n  }\n\n  private canExecute(): boolean {\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        return true;\n\n      case CircuitState.OPEN:\n        // Check if timeout has passed\n        if (Date.now() >= this.nextAttemptTime) {\n          this.transition(CircuitState.HALF_OPEN);\n          return true;\n        }\n        return false;\n\n      case CircuitState.HALF_OPEN:\n        return true;\n\n      default:\n        return false;\n    }\n  }\n\n  private onSuccess(): void {\n    switch (this.state) {\n      case CircuitState.HALF_OPEN:\n        this.successCount++;\n        if (this.successCount >= this.config.successThreshold) {\n          this.transition(CircuitState.CLOSED);\n        }\n        break;\n\n      case CircuitState.CLOSED:\n        // Reset failure count on success\n        this.failureCount = 0;\n        break;\n    }\n  }\n\n  private onFailure(error: Error): void {\n    if (this.config.onFailure) {\n      this.config.onFailure(error);\n    }\n\n    switch (this.state) {\n      case CircuitState.CLOSED:\n        this.failureCount++;\n        if (this.failureCount >= this.config.failureThreshold) {\n          this.transition(CircuitState.OPEN);\n        }\n        break;\n\n      case CircuitState.HALF_OPEN:\n        // Single failure in half-open returns to open\n        this.transition(CircuitState.OPEN);\n        break;\n    }\n  }\n\n  private transition(newState: CircuitState): void {\n    const oldState = this.state;\n    this.state = newState;\n\n    // Reset counters\n    this.failureCount = 0;\n    this.successCount = 0;\n\n    // Set next attempt time for OPEN state\n    if (newState === CircuitState.OPEN) {\n      this.nextAttemptTime = Date.now() + this.config.timeout;\n    }\n\n    // Notify\n    if (this.config.onStateChange) {\n      this.config.onStateChange(oldState, newState);\n    }\n  }\n\n  getState(): CircuitState {\n    return this.state;\n  }\n\n  getStats(): {\n    state: CircuitState;\n    failures: number;\n    successes: number;\n    nextAttemptTime: number | null;\n  } {\n    return {\n      state: this.state,\n      failures: this.failureCount,\n      successes: this.successCount,\n      nextAttemptTime:\n        this.state === CircuitState.OPEN ? this.nextAttemptTime : null,\n    };\n  }\n\n  reset(): void {\n    this.transition(CircuitState.CLOSED);\n  }\n\n  forceOpen(): void {\n    this.transition(CircuitState.OPEN);\n  }\n}\n","/**\n * Timeout Manager for gICM platform\n *\n * Features:\n * - Promise-based timeout wrapper\n * - AbortController integration\n * - Cascading timeouts (parent â†’ child propagation)\n * - Deadline management\n * - Timeout statistics\n */\n\nimport { z } from \"zod\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport const TimeoutConfigSchema = z.object({\n  /** Timeout duration in milliseconds */\n  timeoutMs: z.number().min(0),\n  /** Optional name for debugging */\n  name: z.string().optional(),\n  /** Custom error message */\n  errorMessage: z.string().optional(),\n  /** Callback when timeout occurs */\n  onTimeout: z.function().args().returns(z.void()).optional(),\n});\n\nexport type TimeoutConfig = z.infer<typeof TimeoutConfigSchema>;\n\nexport class TimeoutError extends Error {\n  constructor(\n    message: string,\n    public readonly timeoutMs: number,\n    public readonly operationName?: string\n  ) {\n    super(message);\n    this.name = \"TimeoutError\";\n  }\n}\n\nexport interface TimeoutStats {\n  totalOperations: number;\n  timedOut: number;\n  completed: number;\n  averageDurationMs: number;\n  maxDurationMs: number;\n}\n\n// ============================================================================\n// withTimeout - Basic timeout wrapper\n// ============================================================================\n\n/**\n * Wrap a promise with a timeout\n *\n * @example\n * const result = await withTimeout(\n *   fetch('https://api.example.com/data'),\n *   { timeoutMs: 5000, name: 'api-fetch' }\n * );\n */\nexport async function withTimeout<T>(\n  promise: Promise<T>,\n  config: TimeoutConfig\n): Promise<T> {\n  const { timeoutMs, name, errorMessage, onTimeout } = config;\n\n  if (timeoutMs <= 0) {\n    return promise;\n  }\n\n  let timeoutId: ReturnType<typeof setTimeout>;\n\n  const timeoutPromise = new Promise<never>((_, reject) => {\n    timeoutId = setTimeout(() => {\n      onTimeout?.();\n      reject(\n        new TimeoutError(\n          errorMessage ?? `Operation${name ? ` \"${name}\"` : \"\"} timed out after ${timeoutMs}ms`,\n          timeoutMs,\n          name\n        )\n      );\n    }, timeoutMs);\n  });\n\n  try {\n    const result = await Promise.race([promise, timeoutPromise]);\n    clearTimeout(timeoutId!);\n    return result;\n  } catch (error) {\n    clearTimeout(timeoutId!);\n    throw error;\n  }\n}\n\n// ============================================================================\n// TimeoutController - AbortController integration\n// ============================================================================\n\n/**\n * TimeoutController wraps AbortController with timeout functionality\n *\n * @example\n * const controller = new TimeoutController(5000);\n * const response = await fetch(url, { signal: controller.signal });\n * controller.clear(); // Cleanup if completed before timeout\n */\nexport class TimeoutController {\n  private abortController: AbortController;\n  private timeoutId: ReturnType<typeof setTimeout> | null = null;\n  private _timedOut = false;\n\n  constructor(\n    public readonly timeoutMs: number,\n    private readonly name?: string\n  ) {\n    this.abortController = new AbortController();\n\n    if (timeoutMs > 0) {\n      this.timeoutId = setTimeout(() => {\n        this._timedOut = true;\n        this.abortController.abort(\n          new TimeoutError(\n            `Operation${name ? ` \"${name}\"` : \"\"} timed out after ${timeoutMs}ms`,\n            timeoutMs,\n            name\n          )\n        );\n      }, timeoutMs);\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal;\n  }\n\n  get timedOut(): boolean {\n    return this._timedOut;\n  }\n\n  get aborted(): boolean {\n    return this.abortController.signal.aborted;\n  }\n\n  /**\n   * Clear the timeout - call when operation completes successfully\n   */\n  clear(): void {\n    if (this.timeoutId) {\n      clearTimeout(this.timeoutId);\n      this.timeoutId = null;\n    }\n  }\n\n  /**\n   * Manually abort the operation\n   */\n  abort(reason?: unknown): void {\n    this.clear();\n    this.abortController.abort(reason);\n  }\n}\n\n// ============================================================================\n// Deadline - Cascading timeout management\n// ============================================================================\n\n/**\n * Deadline represents an absolute point in time when an operation must complete.\n * Useful for propagating timeouts through nested operations.\n *\n * @example\n * const deadline = Deadline.after(5000); // 5 seconds from now\n *\n * // Pass to nested operations\n * await operationA(deadline.remaining());\n * await operationB(deadline.remaining());\n *\n * // Check if expired\n * if (deadline.expired) {\n *   throw new TimeoutError('Deadline exceeded', 5000);\n * }\n */\nexport class Deadline {\n  private readonly expiresAt: number;\n\n  private constructor(expiresAt: number) {\n    this.expiresAt = expiresAt;\n  }\n\n  /**\n   * Create a deadline that expires after the given duration\n   */\n  static after(ms: number): Deadline {\n    return new Deadline(Date.now() + ms);\n  }\n\n  /**\n   * Create a deadline at a specific timestamp\n   */\n  static at(timestamp: number): Deadline {\n    return new Deadline(timestamp);\n  }\n\n  /**\n   * Create a deadline that never expires\n   */\n  static never(): Deadline {\n    return new Deadline(Number.MAX_SAFE_INTEGER);\n  }\n\n  /**\n   * Get remaining time in milliseconds (0 if expired)\n   */\n  remaining(): number {\n    return Math.max(0, this.expiresAt - Date.now());\n  }\n\n  /**\n   * Check if the deadline has expired\n   */\n  get expired(): boolean {\n    return Date.now() >= this.expiresAt;\n  }\n\n  /**\n   * Get the absolute expiration timestamp\n   */\n  get expirationTime(): number {\n    return this.expiresAt;\n  }\n\n  /**\n   * Create a child deadline with a shorter timeout\n   * The child will expire at whichever comes first: its own timeout or the parent deadline\n   */\n  child(maxMs: number): Deadline {\n    const childExpires = Date.now() + maxMs;\n    return new Deadline(Math.min(this.expiresAt, childExpires));\n  }\n\n  /**\n   * Throw if expired\n   */\n  check(operationName?: string): void {\n    if (this.expired) {\n      throw new TimeoutError(\n        `Deadline exceeded${operationName ? ` for \"${operationName}\"` : \"\"}`,\n        0,\n        operationName\n      );\n    }\n  }\n\n  /**\n   * Wrap a promise with this deadline\n   */\n  async wrap<T>(promise: Promise<T>, name?: string): Promise<T> {\n    const remaining = this.remaining();\n    if (remaining <= 0) {\n      throw new TimeoutError(\n        `Deadline already expired${name ? ` for \"${name}\"` : \"\"}`,\n        0,\n        name\n      );\n    }\n    return withTimeout(promise, { timeoutMs: remaining, name });\n  }\n\n  /**\n   * Create a TimeoutController bound to this deadline\n   */\n  controller(name?: string): TimeoutController {\n    return new TimeoutController(this.remaining(), name);\n  }\n}\n\n// ============================================================================\n// TimeoutManager - Centralized timeout tracking\n// ============================================================================\n\n/**\n * TimeoutManager tracks timeout statistics across operations\n *\n * @example\n * const manager = new TimeoutManager();\n *\n * // Execute with tracking\n * const result = await manager.execute(\n *   () => fetch('/api/data'),\n *   { timeoutMs: 5000, name: 'api-call' }\n * );\n *\n * // Get statistics\n * console.log(manager.stats);\n */\nexport class TimeoutManager {\n  private operations: Array<{\n    name?: string;\n    durationMs: number;\n    timedOut: boolean;\n    timestamp: number;\n  }> = [];\n\n  private readonly maxHistory: number;\n\n  constructor(maxHistory = 1000) {\n    this.maxHistory = maxHistory;\n  }\n\n  /**\n   * Execute a function with timeout tracking\n   */\n  async execute<T>(\n    fn: () => Promise<T>,\n    config: TimeoutConfig\n  ): Promise<T> {\n    const startTime = Date.now();\n    let timedOut = false;\n\n    try {\n      const result = await withTimeout(fn(), {\n        ...config,\n        onTimeout: () => {\n          timedOut = true;\n          config.onTimeout?.();\n        },\n      });\n      this.recordOperation(config.name, Date.now() - startTime, false);\n      return result;\n    } catch (error) {\n      this.recordOperation(config.name, Date.now() - startTime, timedOut || error instanceof TimeoutError);\n      throw error;\n    }\n  }\n\n  /**\n   * Execute with a deadline\n   */\n  async executeWithDeadline<T>(\n    fn: () => Promise<T>,\n    deadline: Deadline,\n    name?: string\n  ): Promise<T> {\n    return this.execute(fn, {\n      timeoutMs: deadline.remaining(),\n      name,\n    });\n  }\n\n  private recordOperation(name: string | undefined, durationMs: number, timedOut: boolean): void {\n    this.operations.push({\n      name,\n      durationMs,\n      timedOut,\n      timestamp: Date.now(),\n    });\n\n    // Trim history if too large\n    if (this.operations.length > this.maxHistory) {\n      this.operations = this.operations.slice(-this.maxHistory);\n    }\n  }\n\n  /**\n   * Get timeout statistics\n   */\n  get stats(): TimeoutStats {\n    if (this.operations.length === 0) {\n      return {\n        totalOperations: 0,\n        timedOut: 0,\n        completed: 0,\n        averageDurationMs: 0,\n        maxDurationMs: 0,\n      };\n    }\n\n    const timedOut = this.operations.filter((op) => op.timedOut).length;\n    const durations = this.operations.map((op) => op.durationMs);\n    const totalDuration = durations.reduce((a, b) => a + b, 0);\n\n    return {\n      totalOperations: this.operations.length,\n      timedOut,\n      completed: this.operations.length - timedOut,\n      averageDurationMs: totalDuration / this.operations.length,\n      maxDurationMs: Math.max(...durations),\n    };\n  }\n\n  /**\n   * Get timeout rate (percentage of operations that timed out)\n   */\n  get timeoutRate(): number {\n    if (this.operations.length === 0) return 0;\n    return this.stats.timedOut / this.stats.totalOperations;\n  }\n\n  /**\n   * Clear all recorded operations\n   */\n  clear(): void {\n    this.operations = [];\n  }\n\n  /**\n   * Get recent operations for debugging\n   */\n  getRecentOperations(count = 10): typeof this.operations {\n    return this.operations.slice(-count);\n  }\n}\n\n// ============================================================================\n// Utility functions\n// ============================================================================\n\n/**\n * Sleep for a given duration, respecting an optional abort signal\n */\nexport function sleep(ms: number, signal?: AbortSignal): Promise<void> {\n  return new Promise((resolve, reject) => {\n    if (signal?.aborted) {\n      reject(signal.reason ?? new Error(\"Aborted\"));\n      return;\n    }\n\n    const timeoutId = setTimeout(resolve, ms);\n\n    signal?.addEventListener(\"abort\", () => {\n      clearTimeout(timeoutId);\n      reject(signal.reason ?? new Error(\"Aborted\"));\n    });\n  });\n}\n\n/**\n * Race multiple promises with a timeout\n */\nexport async function raceWithTimeout<T>(\n  promises: Promise<T>[],\n  config: TimeoutConfig\n): Promise<T> {\n  return withTimeout(Promise.race(promises), config);\n}\n\n/**\n * Execute promises in sequence with per-operation timeout\n */\nexport async function sequenceWithTimeout<T>(\n  operations: Array<() => Promise<T>>,\n  perOperationTimeout: number,\n  totalDeadline?: Deadline\n): Promise<T[]> {\n  const results: T[] = [];\n\n  for (const [index, op] of operations.entries()) {\n    // Check total deadline if provided\n    if (totalDeadline?.expired) {\n      throw new TimeoutError(\n        `Sequence deadline expired at operation ${index}`,\n        0\n      );\n    }\n\n    // Use minimum of per-operation timeout and remaining deadline\n    const effectiveTimeout = totalDeadline\n      ? Math.min(perOperationTimeout, totalDeadline.remaining())\n      : perOperationTimeout;\n\n    const result = await withTimeout(op(), {\n      timeoutMs: effectiveTimeout,\n      name: `sequence-op-${index}`,\n    });\n    results.push(result);\n  }\n\n  return results;\n}\n","/**\n * Health monitoring for services\n */\n\nexport interface HealthCheck {\n  name: string;\n  check: () => Promise<boolean>;\n  critical?: boolean;\n  timeout?: number;\n}\n\nexport type HealthStatus = \"healthy\" | \"degraded\" | \"unhealthy\";\n\nexport interface CheckResult {\n  status: \"pass\" | \"fail\";\n  responseTime: number;\n  error?: string;\n  critical: boolean;\n}\n\nexport interface HealthResult {\n  status: HealthStatus;\n  checks: Record<string, CheckResult>;\n  timestamp: string;\n  uptime: number;\n}\n\nconst DEFAULT_TIMEOUT = 5000;\n\nexport class HealthMonitor {\n  private checks: Map<string, HealthCheck> = new Map();\n  private startTime = Date.now();\n\n  register(check: HealthCheck): void {\n    this.checks.set(check.name, {\n      ...check,\n      timeout: check.timeout ?? DEFAULT_TIMEOUT,\n      critical: check.critical ?? false,\n    });\n  }\n\n  unregister(name: string): void {\n    this.checks.delete(name);\n  }\n\n  async runCheck(check: HealthCheck): Promise<CheckResult> {\n    const startTime = Date.now();\n\n    try {\n      // Run check with timeout\n      const result = await Promise.race([\n        check.check(),\n        new Promise<boolean>((_, reject) =>\n          setTimeout(\n            () => reject(new Error(\"Health check timeout\")),\n            check.timeout ?? DEFAULT_TIMEOUT\n          )\n        ),\n      ]);\n\n      return {\n        status: result ? \"pass\" : \"fail\",\n        responseTime: Date.now() - startTime,\n        critical: check.critical ?? false,\n      };\n    } catch (error) {\n      return {\n        status: \"fail\",\n        responseTime: Date.now() - startTime,\n        error: error instanceof Error ? error.message : String(error),\n        critical: check.critical ?? false,\n      };\n    }\n  }\n\n  async getStatus(): Promise<HealthResult> {\n    const results: Record<string, CheckResult> = {};\n    let hasCriticalFailure = false;\n    let hasNonCriticalFailure = false;\n\n    // Run all checks in parallel\n    const checkPromises = Array.from(this.checks.entries()).map(\n      async ([name, check]) => {\n        const result = await this.runCheck(check);\n        results[name] = result;\n\n        if (result.status === \"fail\") {\n          if (result.critical) {\n            hasCriticalFailure = true;\n          } else {\n            hasNonCriticalFailure = true;\n          }\n        }\n      }\n    );\n\n    await Promise.all(checkPromises);\n\n    // Determine overall status\n    let status: HealthStatus;\n    if (hasCriticalFailure) {\n      status = \"unhealthy\";\n    } else if (hasNonCriticalFailure) {\n      status = \"degraded\";\n    } else {\n      status = \"healthy\";\n    }\n\n    return {\n      status,\n      checks: results,\n      timestamp: new Date().toISOString(),\n      uptime: Date.now() - this.startTime,\n    };\n  }\n\n  isHealthy(): boolean {\n    // Quick check - returns false if any critical check would fail\n    // Note: This is synchronous and uses cached state if available\n    return true; // Override with actual cached state in production\n  }\n\n  getUptime(): number {\n    return Date.now() - this.startTime;\n  }\n\n  listChecks(): string[] {\n    return Array.from(this.checks.keys());\n  }\n}\n\n/**\n * Create a simple health check function\n */\nexport function createHealthCheck(\n  name: string,\n  check: () => Promise<boolean>,\n  options?: { critical?: boolean; timeout?: number }\n): HealthCheck {\n  return {\n    name,\n    check,\n    critical: options?.critical ?? false,\n    timeout: options?.timeout ?? DEFAULT_TIMEOUT,\n  };\n}\n","/**\n * Health Aggregator for gICM platform\n *\n * Aggregates health status from multiple services/engines into a unified view.\n * Supports service discovery, dependency tracking, and alert thresholds.\n */\n\nimport { z } from \"zod\";\nimport type { HealthStatus, HealthResult } from \"./health-check.js\";\n\n// ============================================================================\n// Types\n// ============================================================================\n\nexport const ServiceHealthSchema = z.object({\n  serviceId: z.string(),\n  name: z.string(),\n  status: z.enum([\"healthy\", \"degraded\", \"unhealthy\", \"unknown\"]),\n  lastCheck: z.number(),\n  lastHealthy: z.number().optional(),\n  responseTimeMs: z.number().optional(),\n  errorCount: z.number().default(0),\n  metadata: z.record(z.unknown()).optional(),\n});\n\nexport type ServiceHealth = z.infer<typeof ServiceHealthSchema>;\n\nexport const AggregatedHealthSchema = z.object({\n  overallStatus: z.enum([\"healthy\", \"degraded\", \"unhealthy\", \"unknown\"]),\n  services: z.array(ServiceHealthSchema),\n  summary: z.object({\n    healthy: z.number(),\n    degraded: z.number(),\n    unhealthy: z.number(),\n    unknown: z.number(),\n    total: z.number(),\n  }),\n  dependencies: z.record(z.array(z.string())).optional(),\n  timestamp: z.number(),\n});\n\nexport type AggregatedHealth = z.infer<typeof AggregatedHealthSchema>;\n\nexport interface ServiceConfig {\n  id: string;\n  name: string;\n  /** Function to check health */\n  healthCheck: () => Promise<HealthResult | boolean>;\n  /** How often to check (ms) */\n  interval?: number;\n  /** Services this depends on */\n  dependsOn?: string[];\n  /** Is this service critical for overall health? */\n  critical?: boolean;\n  /** Timeout for health check (ms) */\n  timeout?: number;\n  /** Metadata about the service */\n  metadata?: Record<string, unknown>;\n}\n\nexport interface AlertConfig {\n  /** Callback when status changes */\n  onStatusChange?: (\n    serviceId: string,\n    oldStatus: HealthStatus | \"unknown\",\n    newStatus: HealthStatus | \"unknown\"\n  ) => void;\n  /** Callback when service becomes unhealthy */\n  onUnhealthy?: (serviceId: string, health: ServiceHealth) => void;\n  /** Callback when service recovers */\n  onRecovered?: (serviceId: string, health: ServiceHealth) => void;\n  /** Callback for overall status change */\n  onOverallStatusChange?: (\n    oldStatus: HealthStatus | \"unknown\",\n    newStatus: HealthStatus | \"unknown\"\n  ) => void;\n}\n\nexport interface HealthAggregatorConfig {\n  /** Default check interval (ms) */\n  defaultInterval?: number;\n  /** Default timeout (ms) */\n  defaultTimeout?: number;\n  /** How long before marking service as unknown (ms) */\n  staleThreshold?: number;\n  /** Alert configuration */\n  alerts?: AlertConfig;\n}\n\n// ============================================================================\n// HealthAggregator\n// ============================================================================\n\n/**\n * HealthAggregator collects and aggregates health from multiple services\n *\n * @example\n * const aggregator = new HealthAggregator();\n *\n * aggregator.registerService({\n *   id: 'money-engine',\n *   name: 'Money Engine',\n *   healthCheck: async () => moneyEngine.health(),\n *   critical: true,\n * });\n *\n * aggregator.registerService({\n *   id: 'growth-engine',\n *   name: 'Growth Engine',\n *   healthCheck: async () => growthEngine.health(),\n *   dependsOn: ['money-engine'],\n * });\n *\n * // Start automatic polling\n * aggregator.startPolling();\n *\n * // Get aggregated health\n * const health = aggregator.getHealth();\n */\nexport class HealthAggregator {\n  private services: Map<string, ServiceConfig> = new Map();\n  private healthCache: Map<string, ServiceHealth> = new Map();\n  private pollingIntervals: Map<string, ReturnType<typeof setInterval>> =\n    new Map();\n  private lastOverallStatus: HealthStatus | \"unknown\" = \"unknown\";\n  private readonly config: Required<\n    Omit<HealthAggregatorConfig, \"alerts\">\n  > & { alerts?: AlertConfig };\n\n  constructor(config?: HealthAggregatorConfig) {\n    this.config = {\n      defaultInterval: config?.defaultInterval ?? 30000, // 30 seconds\n      defaultTimeout: config?.defaultTimeout ?? 5000, // 5 seconds\n      staleThreshold: config?.staleThreshold ?? 60000, // 1 minute\n      alerts: config?.alerts,\n    };\n  }\n\n  /**\n   * Register a service for health monitoring\n   */\n  registerService(service: ServiceConfig): void {\n    this.services.set(service.id, {\n      ...service,\n      interval: service.interval ?? this.config.defaultInterval,\n      timeout: service.timeout ?? this.config.defaultTimeout,\n    });\n\n    // Initialize health cache\n    this.healthCache.set(service.id, {\n      serviceId: service.id,\n      name: service.name,\n      status: \"unknown\",\n      lastCheck: 0,\n      errorCount: 0,\n      metadata: service.metadata,\n    });\n  }\n\n  /**\n   * Unregister a service\n   */\n  unregisterService(serviceId: string): void {\n    this.stopPolling(serviceId);\n    this.services.delete(serviceId);\n    this.healthCache.delete(serviceId);\n  }\n\n  /**\n   * Check health of a specific service\n   */\n  async checkService(serviceId: string): Promise<ServiceHealth> {\n    const service = this.services.get(serviceId);\n    if (!service) {\n      throw new Error(`Service not found: ${serviceId}`);\n    }\n\n    const startTime = Date.now();\n    const previousHealth = this.healthCache.get(serviceId);\n    const previousStatus = previousHealth?.status ?? \"unknown\";\n\n    try {\n      // Run health check with timeout\n      const checkPromise = service.healthCheck();\n      const timeoutPromise = new Promise<never>((_, reject) => {\n        setTimeout(\n          () => reject(new Error(\"Health check timeout\")),\n          service.timeout ?? this.config.defaultTimeout\n        );\n      });\n\n      const result = await Promise.race([checkPromise, timeoutPromise]);\n      const responseTime = Date.now() - startTime;\n\n      // Normalize result\n      let status: HealthStatus;\n      if (typeof result === \"boolean\") {\n        status = result ? \"healthy\" : \"unhealthy\";\n      } else {\n        status = result.status;\n      }\n\n      const health: ServiceHealth = {\n        serviceId,\n        name: service.name,\n        status,\n        lastCheck: Date.now(),\n        lastHealthy: status === \"healthy\" ? Date.now() : previousHealth?.lastHealthy,\n        responseTimeMs: responseTime,\n        errorCount: status === \"healthy\" ? 0 : (previousHealth?.errorCount ?? 0) + 1,\n        metadata: service.metadata,\n      };\n\n      this.healthCache.set(serviceId, health);\n\n      // Trigger alerts\n      this.triggerAlerts(serviceId, previousStatus, status, health);\n\n      return health;\n    } catch (error) {\n      const health: ServiceHealth = {\n        serviceId,\n        name: service.name,\n        status: \"unhealthy\",\n        lastCheck: Date.now(),\n        lastHealthy: previousHealth?.lastHealthy,\n        responseTimeMs: Date.now() - startTime,\n        errorCount: (previousHealth?.errorCount ?? 0) + 1,\n        metadata: {\n          ...service.metadata,\n          lastError: error instanceof Error ? error.message : String(error),\n        },\n      };\n\n      this.healthCache.set(serviceId, health);\n\n      // Trigger alerts\n      this.triggerAlerts(serviceId, previousStatus, \"unhealthy\", health);\n\n      return health;\n    }\n  }\n\n  /**\n   * Check all registered services\n   */\n  async checkAll(): Promise<Map<string, ServiceHealth>> {\n    const results = new Map<string, ServiceHealth>();\n\n    await Promise.all(\n      Array.from(this.services.keys()).map(async (serviceId) => {\n        const health = await this.checkService(serviceId);\n        results.set(serviceId, health);\n      })\n    );\n\n    return results;\n  }\n\n  /**\n   * Get aggregated health status\n   */\n  getHealth(): AggregatedHealth {\n    const services: ServiceHealth[] = [];\n    let healthy = 0;\n    let degraded = 0;\n    let unhealthy = 0;\n    let unknown = 0;\n\n    const now = Date.now();\n\n    for (const [serviceId, health] of this.healthCache) {\n      // Check if health data is stale\n      const isStale = now - health.lastCheck > this.config.staleThreshold;\n      const effectiveStatus = isStale ? \"unknown\" : health.status;\n\n      const serviceHealth: ServiceHealth = {\n        ...health,\n        status: effectiveStatus,\n      };\n      services.push(serviceHealth);\n\n      switch (effectiveStatus) {\n        case \"healthy\":\n          healthy++;\n          break;\n        case \"degraded\":\n          degraded++;\n          break;\n        case \"unhealthy\":\n          unhealthy++;\n          break;\n        default:\n          unknown++;\n      }\n    }\n\n    // Determine overall status\n    let overallStatus: HealthStatus | \"unknown\";\n    const hasCriticalUnhealthy = services.some((s) => {\n      const config = this.services.get(s.serviceId);\n      return config?.critical && s.status === \"unhealthy\";\n    });\n\n    if (hasCriticalUnhealthy || unhealthy > 0) {\n      overallStatus = \"unhealthy\";\n    } else if (degraded > 0 || unknown > 0) {\n      overallStatus = \"degraded\";\n    } else if (healthy > 0) {\n      overallStatus = \"healthy\";\n    } else {\n      overallStatus = \"unknown\";\n    }\n\n    // Check for overall status change\n    if (overallStatus !== this.lastOverallStatus) {\n      this.config.alerts?.onOverallStatusChange?.(\n        this.lastOverallStatus,\n        overallStatus\n      );\n      this.lastOverallStatus = overallStatus;\n    }\n\n    // Build dependency map\n    const dependencies: Record<string, string[]> = {};\n    for (const [id, service] of this.services) {\n      if (service.dependsOn && service.dependsOn.length > 0) {\n        dependencies[id] = service.dependsOn;\n      }\n    }\n\n    return {\n      overallStatus,\n      services,\n      summary: {\n        healthy,\n        degraded,\n        unhealthy,\n        unknown,\n        total: services.length,\n      },\n      dependencies: Object.keys(dependencies).length > 0 ? dependencies : undefined,\n      timestamp: now,\n    };\n  }\n\n  /**\n   * Get health of a specific service (cached)\n   */\n  getServiceHealth(serviceId: string): ServiceHealth | undefined {\n    return this.healthCache.get(serviceId);\n  }\n\n  /**\n   * Check if all critical services are healthy\n   */\n  isCriticalHealthy(): boolean {\n    for (const [serviceId, config] of this.services) {\n      if (config.critical) {\n        const health = this.healthCache.get(serviceId);\n        if (!health || health.status !== \"healthy\") {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Get services that depend on a given service\n   */\n  getDependents(serviceId: string): string[] {\n    const dependents: string[] = [];\n    for (const [id, config] of this.services) {\n      if (config.dependsOn?.includes(serviceId)) {\n        dependents.push(id);\n      }\n    }\n    return dependents;\n  }\n\n  /**\n   * Check if a service and its dependencies are healthy\n   */\n  isServiceReady(serviceId: string): boolean {\n    const service = this.services.get(serviceId);\n    if (!service) return false;\n\n    // Check own health\n    const health = this.healthCache.get(serviceId);\n    if (!health || health.status !== \"healthy\") {\n      return false;\n    }\n\n    // Check dependencies\n    if (service.dependsOn) {\n      for (const depId of service.dependsOn) {\n        const depHealth = this.healthCache.get(depId);\n        if (!depHealth || depHealth.status !== \"healthy\") {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Start polling for a specific service\n   */\n  startPolling(serviceId: string): void {\n    const service = this.services.get(serviceId);\n    if (!service) return;\n\n    // Stop existing polling if any\n    this.stopPolling(serviceId);\n\n    // Initial check\n    this.checkService(serviceId);\n\n    // Start interval\n    const interval = setInterval(() => {\n      this.checkService(serviceId);\n    }, service.interval ?? this.config.defaultInterval);\n\n    this.pollingIntervals.set(serviceId, interval);\n  }\n\n  /**\n   * Start polling for all services\n   */\n  startAllPolling(): void {\n    for (const serviceId of this.services.keys()) {\n      this.startPolling(serviceId);\n    }\n  }\n\n  /**\n   * Stop polling for a specific service\n   */\n  stopPolling(serviceId: string): void {\n    const interval = this.pollingIntervals.get(serviceId);\n    if (interval) {\n      clearInterval(interval);\n      this.pollingIntervals.delete(serviceId);\n    }\n  }\n\n  /**\n   * Stop all polling\n   */\n  stopAllPolling(): void {\n    for (const serviceId of this.pollingIntervals.keys()) {\n      this.stopPolling(serviceId);\n    }\n  }\n\n  /**\n   * Get list of registered services\n   */\n  listServices(): string[] {\n    return Array.from(this.services.keys());\n  }\n\n  /**\n   * Get service configuration\n   */\n  getServiceConfig(serviceId: string): ServiceConfig | undefined {\n    return this.services.get(serviceId);\n  }\n\n  private triggerAlerts(\n    serviceId: string,\n    previousStatus: HealthStatus | \"unknown\",\n    newStatus: HealthStatus | \"unknown\",\n    health: ServiceHealth\n  ): void {\n    if (!this.config.alerts) return;\n\n    // Status change\n    if (previousStatus !== newStatus) {\n      this.config.alerts.onStatusChange?.(serviceId, previousStatus, newStatus);\n\n      // Unhealthy\n      if (newStatus === \"unhealthy\") {\n        this.config.alerts.onUnhealthy?.(serviceId, health);\n      }\n\n      // Recovered\n      if (\n        previousStatus === \"unhealthy\" &&\n        (newStatus === \"healthy\" || newStatus === \"degraded\")\n      ) {\n        this.config.alerts.onRecovered?.(serviceId, health);\n      }\n    }\n  }\n}\n\n// ============================================================================\n// Utility functions\n// ============================================================================\n\n/**\n * Create a simple health check that pings a URL\n */\nexport function createHttpHealthCheck(\n  url: string,\n  options?: {\n    timeout?: number;\n    expectedStatus?: number;\n  }\n): () => Promise<boolean> {\n  return async () => {\n    const controller = new AbortController();\n    const timeout = setTimeout(\n      () => controller.abort(),\n      options?.timeout ?? 5000\n    );\n\n    try {\n      const response = await fetch(url, { signal: controller.signal });\n      clearTimeout(timeout);\n      return response.status === (options?.expectedStatus ?? 200);\n    } catch {\n      clearTimeout(timeout);\n      return false;\n    }\n  };\n}\n\n/**\n * Create a health check that calls a function\n */\nexport function createFunctionHealthCheck(\n  fn: () => Promise<boolean> | boolean\n): () => Promise<boolean> {\n  return async () => {\n    const result = await fn();\n    return result;\n  };\n}\n\n/**\n * Merge multiple health results into one\n */\nexport function mergeHealthResults(\n  results: HealthResult[]\n): HealthResult {\n  let hasCriticalFailure = false;\n  let hasNonCriticalFailure = false;\n  const checks: Record<string, { status: \"pass\" | \"fail\"; responseTime: number; critical: boolean; error?: string }> = {};\n\n  for (const result of results) {\n    for (const [name, check] of Object.entries(result.checks)) {\n      checks[name] = check;\n      if (check.status === \"fail\") {\n        if (check.critical) {\n          hasCriticalFailure = true;\n        } else {\n          hasNonCriticalFailure = true;\n        }\n      }\n    }\n  }\n\n  let status: HealthStatus;\n  if (hasCriticalFailure) {\n    status = \"unhealthy\";\n  } else if (hasNonCriticalFailure) {\n    status = \"degraded\";\n  } else {\n    status = \"healthy\";\n  }\n\n  return {\n    status,\n    checks,\n    timestamp: new Date().toISOString(),\n    uptime: Math.max(...results.map((r) => r.uptime)),\n  };\n}\n","/**\n * LIVE mode trading guards to prevent excessive losses\n */\n\nexport interface LiveModeConfig {\n  maxPositionUsd: number;\n  maxDailyLossUsd: number;\n  maxDrawdownPercent: number;\n  requireApproval: boolean;\n  coolDownAfterLossMs: number;\n  allowedTokens?: string[];\n  blockedTokens: string[];\n}\n\nconst DEFAULT_CONFIG: LiveModeConfig = {\n  maxPositionUsd: 1000,\n  maxDailyLossUsd: 100,\n  maxDrawdownPercent: 10,\n  requireApproval: true,\n  coolDownAfterLossMs: 3600000, // 1 hour\n  blockedTokens: [],\n};\n\nexport interface TradeRequest {\n  token: string;\n  side: \"buy\" | \"sell\";\n  amountUsd: number;\n  source: string;\n}\n\nexport interface GuardResult {\n  allowed: boolean;\n  reason?: string;\n  requiresApproval?: boolean;\n  approvalId?: string;\n  warnings: string[];\n}\n\nexport interface PendingApproval {\n  id: string;\n  request: TradeRequest;\n  createdAt: number;\n}\n\nexport class LiveModeGuard {\n  private config: LiveModeConfig;\n  private dailyPnL = 0;\n  private lastLossTime = 0;\n  private pendingApprovals: Map<string, PendingApproval> = new Map();\n  private dailyPnLResetTime: number;\n\n  constructor(config?: Partial<LiveModeConfig>) {\n    this.config = { ...DEFAULT_CONFIG, ...config };\n    this.dailyPnLResetTime = this.getNextMidnightUTC();\n  }\n\n  checkTrade(request: TradeRequest): GuardResult {\n    const warnings: string[] = [];\n\n    // Check daily reset\n    if (Date.now() > this.dailyPnLResetTime) {\n      this.dailyPnL = 0;\n      this.dailyPnLResetTime = this.getNextMidnightUTC();\n    }\n\n    // Check cool-down period\n    if (this.lastLossTime > 0) {\n      const coolDownRemaining =\n        this.lastLossTime + this.config.coolDownAfterLossMs - Date.now();\n      if (coolDownRemaining > 0) {\n        return {\n          allowed: false,\n          reason: `In cool-down period after loss. ${Math.ceil(coolDownRemaining / 60000)} minutes remaining.`,\n          warnings,\n        };\n      }\n    }\n\n    // Check blocked tokens\n    if (this.config.blockedTokens.includes(request.token)) {\n      return {\n        allowed: false,\n        reason: `Token ${request.token} is blocked`,\n        warnings,\n      };\n    }\n\n    // Check allowed tokens (if specified)\n    if (\n      this.config.allowedTokens &&\n      !this.config.allowedTokens.includes(request.token)\n    ) {\n      return {\n        allowed: false,\n        reason: `Token ${request.token} not in allowed list`,\n        warnings,\n      };\n    }\n\n    // Check position size\n    if (request.amountUsd > this.config.maxPositionUsd) {\n      return {\n        allowed: false,\n        reason: `Position $${request.amountUsd} exceeds max $${this.config.maxPositionUsd}`,\n        warnings,\n      };\n    }\n\n    // Check daily loss limit\n    if (this.dailyPnL < -this.config.maxDailyLossUsd) {\n      return {\n        allowed: false,\n        reason: `Daily loss limit reached: $${Math.abs(this.dailyPnL).toFixed(2)}`,\n        warnings,\n      };\n    }\n\n    // Add warnings for risky trades\n    if (request.amountUsd > this.config.maxPositionUsd * 0.5) {\n      warnings.push(\n        `Large position: ${((request.amountUsd / this.config.maxPositionUsd) * 100).toFixed(0)}% of max`\n      );\n    }\n\n    if (this.dailyPnL < -this.config.maxDailyLossUsd * 0.5) {\n      warnings.push(\n        `Approaching daily loss limit: $${Math.abs(this.dailyPnL).toFixed(2)} of $${this.config.maxDailyLossUsd}`\n      );\n    }\n\n    // Check if approval required\n    if (this.config.requireApproval) {\n      const approvalId = `${request.token}-${request.side}-${Date.now()}`;\n      this.pendingApprovals.set(approvalId, {\n        id: approvalId,\n        request,\n        createdAt: Date.now(),\n      });\n\n      return {\n        allowed: false,\n        requiresApproval: true,\n        approvalId,\n        reason: `Requires human approval (ID: ${approvalId})`,\n        warnings,\n      };\n    }\n\n    return { allowed: true, warnings };\n  }\n\n  approveTradeById(approvalId: string): TradeRequest | null {\n    const approval = this.pendingApprovals.get(approvalId);\n    if (approval) {\n      this.pendingApprovals.delete(approvalId);\n      return approval.request;\n    }\n    return null;\n  }\n\n  rejectTradeById(approvalId: string): void {\n    this.pendingApprovals.delete(approvalId);\n  }\n\n  recordTradeResult(pnl: number): void {\n    this.dailyPnL += pnl;\n    if (pnl < 0) {\n      this.lastLossTime = Date.now();\n    }\n  }\n\n  getStatus(): {\n    dailyPnL: number;\n    inCoolDown: boolean;\n    coolDownRemainingMs: number;\n    pendingApprovals: number;\n    config: LiveModeConfig;\n  } {\n    const inCoolDown =\n      this.lastLossTime > 0 &&\n      Date.now() < this.lastLossTime + this.config.coolDownAfterLossMs;\n\n    return {\n      dailyPnL: this.dailyPnL,\n      inCoolDown,\n      coolDownRemainingMs: inCoolDown\n        ? this.lastLossTime + this.config.coolDownAfterLossMs - Date.now()\n        : 0,\n      pendingApprovals: this.pendingApprovals.size,\n      config: this.config,\n    };\n  }\n\n  getPendingApprovals(): PendingApproval[] {\n    return Array.from(this.pendingApprovals.values());\n  }\n\n  resetDailyPnL(): void {\n    this.dailyPnL = 0;\n    this.dailyPnLResetTime = this.getNextMidnightUTC();\n  }\n\n  clearCoolDown(): void {\n    this.lastLossTime = 0;\n  }\n\n  private getNextMidnightUTC(): number {\n    const now = new Date();\n    const tomorrow = new Date(\n      Date.UTC(\n        now.getUTCFullYear(),\n        now.getUTCMonth(),\n        now.getUTCDate() + 1,\n        0,\n        0,\n        0,\n        0\n      )\n    );\n    return tomorrow.getTime();\n  }\n}\n","/**\n * Resilience utilities for gICM platform\n *\n * Provides:\n * - Retry with exponential backoff\n * - Circuit breaker pattern\n * - Timeout management\n * - Health monitoring\n * - LIVE mode trading guards\n */\n\n// Retry\nexport { withRetry, calculateDelay, Retry } from \"./retry.js\";\nexport type { RetryConfig } from \"./retry.js\";\n\n// Circuit Breaker\nexport {\n  CircuitBreaker,\n  CircuitBreakerOpenError,\n  CircuitState,\n} from \"./circuit-breaker.js\";\nexport type { CircuitBreakerConfig } from \"./circuit-breaker.js\";\n\n// Timeout\nexport {\n  withTimeout,\n  TimeoutController,\n  Deadline,\n  TimeoutManager,\n  TimeoutError,\n  sleep,\n  raceWithTimeout,\n  sequenceWithTimeout,\n} from \"./timeout.js\";\nexport type { TimeoutConfig, TimeoutStats } from \"./timeout.js\";\n\n// Health Check\nexport { HealthMonitor, createHealthCheck } from \"./health-check.js\";\nexport type {\n  HealthCheck,\n  HealthStatus,\n  HealthResult,\n  CheckResult,\n} from \"./health-check.js\";\n\n// Health Aggregator\nexport {\n  HealthAggregator,\n  createHttpHealthCheck,\n  createFunctionHealthCheck,\n  mergeHealthResults,\n} from \"./health-aggregator.js\";\nexport type {\n  ServiceHealth,\n  AggregatedHealth,\n  ServiceConfig,\n  AlertConfig,\n  HealthAggregatorConfig,\n} from \"./health-aggregator.js\";\n\n// LIVE Mode Guards\nexport { LiveModeGuard } from \"./live-guards.js\";\nexport type {\n  LiveModeConfig,\n  TradeRequest,\n  GuardResult,\n  PendingApproval,\n} from \"./live-guards.js\";\n\n/**\n * Convenience function to wrap with both retry and circuit breaker\n */\nimport { withRetry, type RetryConfig } from \"./retry.js\";\nimport { CircuitBreaker } from \"./circuit-breaker.js\";\n\nexport async function withResilience<T>(\n  fn: () => Promise<T>,\n  options?: {\n    retry?: Partial<RetryConfig>;\n    circuitBreaker?: CircuitBreaker;\n  }\n): Promise<T> {\n  const execute = async () => {\n    if (options?.circuitBreaker) {\n      return options.circuitBreaker.execute(fn);\n    }\n    return fn();\n  };\n\n  if (options?.retry) {\n    return withRetry(execute, options.retry);\n  }\n\n  return execute();\n}\n"],"mappings":"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","names":["CircuitState","DEFAULT_CONFIG","z","DEFAULT_CONFIG"]}