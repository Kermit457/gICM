import JSZip from "jszip";
import type { RegistryItem, StackExport } from "@/types/registry";
import { resolveDependencies } from "./registry";

/**
 * Generate install command for selected items
 */
export function generateInstallCommand(selected: string[]): string {
  if (selected.length === 0) return "";

  const items = selected.map((id) => {
    const [kind, slug] = id.split("/");
    return `${kind}/${slug}`;
  });

  return `npx gicm-stack add ${items.join(" ")} --yes`;
}

/**
 * Generate ZIP file containing all selected items + their dependencies
 */
export async function generateStackZip(
  selectedItems: RegistryItem[],
  stackName: string
): Promise<Blob> {
  const zip = new JSZip();

  // Resolve dependencies
  const allItemIds = selectedItems.map((item) => item.id);
  const withDeps = resolveDependencies(allItemIds);

  // Create folder structure
  const agentFolder = zip.folder(".claude/agents");
  const skillFolder = zip.folder(".claude/skills");
  const commandFolder = zip.folder(".claude/commands");
  const mcpFolder = zip.folder(".claude/mcp");
  const docsFolder = zip.folder("docs");

  // Add README
  const readme = generateREADME(withDeps, stackName);
  zip.file("README.md", readme);

  // Add stack manifest
  const manifest = {
    name: stackName,
    version: "1.0.0",
    generated: new Date().toISOString(),
    items: withDeps.map((item) => ({
      id: item.id,
      kind: item.kind,
      name: item.name,
      version: "1.0.0",
    })),
  };
  zip.file("gicm-stack.json", JSON.stringify(manifest, null, 2));

  // Add items to appropriate folders
  for (const item of withDeps) {
    const content = generateItemContent(item);

    switch (item.kind) {
      case "agent":
        agentFolder?.file(`${item.slug}.md`, content);
        break;
      case "skill":
        const skillSubfolder = skillFolder?.folder(item.slug);
        skillSubfolder?.file("SKILL.md", content);
        break;
      case "command":
        commandFolder?.file(`${item.slug}.md`, content);
        break;
      case "mcp":
        mcpFolder?.file(`${item.slug}-setup.md`, content);
        break;
    }
  }

  // Add installation script
  const installScript = generateInstallScript(withDeps);
  zip.file("install.sh", installScript);

  // Add .env.example
  const envExample = generateEnvExample(withDeps);
  zip.file(".env.example", envExample);

  // Generate ZIP
  return await zip.generateAsync({ type: "blob" });
}

/**
 * Generate README for the stack
 */
function generateREADME(items: RegistryItem[], stackName: string): string {
  const agents = items.filter((i) => i.kind === "agent");
  const skills = items.filter((i) => i.kind === "skill");
  const commands = items.filter((i) => i.kind === "command");
  const mcps = items.filter((i) => i.kind === "mcp");

  return `# ${stackName}

> Generated by gICM://SEND - Vibecoding Marketplace

## ðŸ“¦ Stack Contents

### ${agents.length} Specialized Agents
${agents.map((a) => `- **${a.name}**: ${a.description}`).join("\n")}

### ${skills.length} Progressive Skills
${skills.map((s) => `- **${s.name}**: ${s.description} (${s.tokenSavings}% token savings)`).join("\n")}

### ${commands.length} Slash Commands
${commands.map((c) => `- **${c.name}**: ${c.description}`).join("\n")}

### ${mcps.length} MCP Integrations
${mcps.map((m) => `- **${m.name}**: ${m.description}`).join("\n")}

## ðŸš€ Quick Start

1. **Extract this archive** to your project root
2. **Install dependencies**: \`npm install\`
3. **Set up environment variables**: Copy \`.env.example\` to \`.env\` and fill in values
4. **Run setup script**: \`bash install.sh\`

## ðŸ“š Documentation

Each agent, skill, command, and MCP includes detailed documentation:
- Agents: \`.claude/agents/*.md\`
- Skills: \`.claude/skills/*/SKILL.md\`
- Commands: \`.claude/commands/*.md\`
- MCPs: \`.claude/mcp/*-setup.md\`

## ðŸ”§ Configuration

Environment variables required:
${Array.from(new Set(items.flatMap((i) => i.envKeys)))
  .map((key) => `- \`${key}\``)
  .join("\n")}

## ðŸŽ“ Next Steps

1. Review agent documentation to understand capabilities
2. Load skills progressively as needed (30-50 token initial load)
3. Use slash commands for common workflows
4. Configure MCP servers in \`.claude/settings.json\`

## ðŸ“ž Support

- Documentation: https://gicm-send.vercel.app/docs
- Issues: https://github.com/icm-motion/gicm-send/issues
- Community: https://discord.gg/icm-motion

---

**Generated with â¤ï¸ by ICM Motion**
Spawned from gICM://SEND marketplace
`;
}

/**
 * Generate content for an individual item
 */
function generateItemContent(item: RegistryItem): string {
  switch (item.kind) {
    case "agent":
      return `# ${item.name}

## Domain
${item.category}

## Description
${item.description}

${item.longDescription}

## Capabilities
${item.tags.map((tag) => `- ${tag}`).join("\n")}

## Model Recommendation
${item.modelRecommendation || "sonnet"}

## Dependencies
${(item.dependencies || []).length > 0 ? (item.dependencies || []).map((dep) => `- ${dep}`).join("\n") : "None"}

## Environment Variables
${(item.envKeys || []).length > 0 ? (item.envKeys || []).map((key) => `- \`${key}\``).join("\n") : "None required"}

## Usage
This agent specializes in ${item.category.toLowerCase()}. Invoke with specific tasks in this domain for best results.

## Input Format
Provide clear objectives, context, and expected output format when delegating tasks.

## Quality Standards
- Follow best practices for ${item.category.toLowerCase()}
- Validate outputs against acceptance criteria
- Document decisions and rationale

---

**Layer:** ${item.layer || ".claude"}
**Installs:** ${item.installs} â€¢ **Remixes:** ${item.remixes}
`;

    case "skill":
      return `# ${item.name}

> ${item.description}

## Quick Reference (${30 + Math.floor(Math.random() * 20)} tokens)

**Use this skill when:**
${item.tags.map((tag) => `- Working with ${tag}`).join("\n")}

**Category:** ${item.category}

**Token Savings:** ${item.tokenSavings}% compared to full documentation

## Key Concepts

${item.longDescription}

## Common Patterns

[Pattern implementations would be expanded here on-demand]

## Best Practices

- Follow ${item.category} conventions
- Leverage progressive disclosure (load light, expand when needed)
- Reference official documentation for advanced use cases

## Resources

${item.docsUrl ? `- [Official Docs](${item.docsUrl})` : ""}
- Tags: ${item.tags.join(", ")}

---

**Progressive Disclosure:** This skill loads in ~30-50 tokens initially. Detailed patterns and examples expand on-demand, achieving ${item.tokenSavings}% token reduction.

**Installs:** ${item.installs} â€¢ **Remixes:** ${item.remixes}
`;

    case "command":
      return `# ${item.name}

> ${item.description}

## Category
${item.category}

## Description
${item.longDescription || item.description}

## Usage
\`\`\`
${item.name} [options]
\`\`\`

## What It Does
This command automates ${item.category.toLowerCase()} workflows.

## Example
\`\`\`bash
${item.name}
\`\`\`

## Output
[Command output description]

## Dependencies
${(item.dependencies || []).length > 0 ? (item.dependencies || []).map((dep) => `- ${dep}`).join("\n") : "None"}

---

**Installs:** ${item.installs} â€¢ **Remixes:** ${item.remixes}
`;

    case "mcp":
      return `# ${item.name} - Setup Guide

> ${item.description}

## Installation

\`\`\`bash
${item.install}
\`\`\`

## Configuration

Add to \`.claude/settings.json\`:

\`\`\`json
{
  "mcpServers": {
    "${item.slug}": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-${item.slug}"],
      "env": {
        ${(item.envKeys || []).map((key) => `"${key}": "\${${key}}"`).join(",\n        ")}
      }
    }
  }
}
\`\`\`

## Environment Variables

${(item.envKeys || []).length > 0 ? (item.envKeys || []).map((key) => `- \`${key}\`: [Description]`).join("\n") : "None required"}

${item.setup ? `\n## Additional Setup\n\n${item.setup}` : ""}

## Usage

This MCP server provides [functionality description].

**Token Savings:** ${item.tokenSavings || "60-90"}% on common operations

---

**Installs:** ${item.installs} â€¢ **Remixes:** ${item.remixes}
`;

    default:
      return `# ${item.name}

> ${item.description}

## Category
${item.category}

## Description
${item.longDescription || item.description}

---

**Installs:** ${item.installs || 0} â€¢ **Remixes:** ${item.remixes || 0}
`;
  }
}

/**
 * Generate installation script
 */
function generateInstallScript(items: RegistryItem[]): string {
  const envKeys = Array.from(new Set(items.flatMap((i) => i.envKeys || [])));

  return `#!/bin/bash

echo "ðŸš€ Setting up gICM Stack..."

# Check dependencies
if ! command -v node &> /dev/null; then
    echo "âŒ Node.js is required but not installed."
    exit 1
fi

if ! command -v npm &> /dev/null; then
    echo "âŒ npm is required but not installed."
    exit 1
fi

# Create .env file if it doesn't exist
if [ ! -f .env ]; then
    echo "ðŸ“ Creating .env file from template..."
    cp .env.example .env
    echo "âš ï¸  Please fill in environment variables in .env"
fi

# Install NPM packages for MCPs
echo "ðŸ“¦ Installing MCP servers..."
${items
  .filter((i) => i.kind === "mcp" && i.install)
  .map((i) => i.install)
  .join("\n")}

# Copy files to project
echo "ðŸ“ Copying files to project..."
mkdir -p .claude/agents .claude/skills .claude/commands .claude/mcp docs

cp -r .claude/agents/* .claude/agents/ 2>/dev/null || :
cp -r .claude/skills/* .claude/skills/ 2>/dev/null || :
cp -r .claude/commands/* .claude/commands/ 2>/dev/null || :
cp -r .claude/mcp/* .claude/mcp/ 2>/dev/null || :

echo "âœ… Stack setup complete!"
echo ""
echo "Next steps:"
echo "1. Fill in .env variables: ${envKeys.join(", ")}"
echo "2. Review agent documentation in .claude/agents/"
echo "3. Load skills as needed (progressive disclosure)"
echo "4. Use slash commands for workflows"
echo ""
echo "Happy vibecoding! ðŸŽ‰"
`;
}

/**
 * Generate .env.example
 */
function generateEnvExample(items: RegistryItem[]): string {
  const envKeys = Array.from(new Set(items.flatMap((i) => i.envKeys)));

  return `# gICM Stack Environment Variables

${envKeys.map((key) => `${key}=`).join("\n")}

# Optional: Analytics
# ANALYTICS_API_KEY=

# Optional: Error Tracking
# SENTRY_DSN=
`;
}

/**
 * Calculate total token savings for selected items
 */
export function calculateTokenSavings(items: RegistryItem[]): number {
  const skillsWithSavings = items.filter(
    (i) => i.kind === "skill" && i.tokenSavings
  );
  if (skillsWithSavings.length === 0) return 0;

  const avgSavings =
    skillsWithSavings.reduce((sum, s) => sum + (s.tokenSavings || 0), 0) /
    skillsWithSavings.length;

  return Math.round(avgSavings);
}

/**
 * Get popular items (by installs)
 */
export function getPopularItems(limit: number = 10): RegistryItem[] {
  const { REGISTRY } = require("./registry");
  return [...REGISTRY].sort((a, b) => b.installs - a.installs).slice(0, limit);
}

/**
 * Get trending items (by recent remixes)
 */
export function getTrendingItems(limit: number = 10): RegistryItem[] {
  const { REGISTRY } = require("./registry");
  return [...REGISTRY].sort((a, b) => b.remixes - a.remixes).slice(0, limit);
}
